<!DOCTYPE html>
<html lang="en" style="--bottom-details-height: 240px; --sidebar-width: 520.996px;"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SNQ Network Plotting Dashboard - Grouped Layout</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script>
        // Ensure D3.js is loaded and has required functions
        if (typeof d3 === 'undefined') {
            console.error('D3.js failed to load');
        } else {
            console.log('D3.js loaded successfully, version:', d3.version);
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
  
        body {
            font-family: 'Inter', 'SF Pro Text', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, 'Noto Sans', 'Liberation Sans', sans-serif;
            background: #f8f9fa;
            color: #2c3e50;
            line-height: 1.6;
            min-height: 100vh;
        }
  
        .dashboard-container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .main-content {
            flex: 1;
            overflow: auto;
            transition: margin-left 0.2s ease;
        }
  
        .sidebar {
            width: 340px;
            min-width: 280px;
            max-width: 600px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            box-shadow: 4px 0 20px rgba(0,0,0,0.1);
            position: relative;
            transition: width 0.2s ease;
        }

        .workflow-step {
            margin-bottom: 1.5rem;
            position: relative;
        }

        .workflow-step::before {
            content: attr(data-step);
            position: absolute;
            left: -15px;
            top: 0;
            width: 24px;
            height: 24px;
            background: #42a5f5;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            z-index: 1;
        }

        .workflow-step.completed::before {
            background: #4caf50;
        }

        .workflow-step.current::before {
            background: #ff9800;
            animation: pulse 2s infinite;
        }

        /* Red indicator for Overview step */
        .workflow-step.overview::before {
            background: #ef4444;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .step-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 0.5rem;
            padding-left: 20px;
        }

        .step-content {
            padding-left: 20px;
        }

        .child-selection-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 2px solid #42a5f5;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            box-shadow: 0 4px 12px rgba(66, 165, 245, 0.15);
        }

        .child-selection-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        #childSelect {
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        #childSelect:hover {
            border-color: #42a5f5 !important;
        }

        #childSelect:focus {
            outline: none;
            border-color: #42a5f5 !important;
            box-shadow: 0 0 0 3px rgba(66, 165, 245, 0.1);
        }

        #confidentialMode {
            transform: scale(1.1);
            transition: transform 0.2s ease;
        }

        #confidentialMode:hover {
            transform: scale(1.2);
        }

        .child-preview-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-top: 1rem;
            font-size: 0.9rem;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.7);
            padding: 0.5rem;
            border-radius: 6px;
            text-align: center;
        }

        .stat-value {
            font-weight: bold;
            color: #42a5f5;
            font-size: 1.1rem;
        }

        .stat-label {
            color: #666;
            font-size: 0.8rem;
        }

        .accordion {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            margin-bottom: 0.5rem;
            overflow: hidden;
        }

        .accordion-header {
            background: #f8f9fa;
            padding: 1rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
        }

        .accordion-header:hover {
            background: #e9ecef;
        }

        .accordion-header.active {
            background: #42a5f5;
            color: white;
        }

        .accordion-content {
            padding: 1rem;
            background: white;
            display: none;
        }

        .accordion-content.active {
            display: block;
        }

        .accordion-icon {
            transition: transform 0.2s ease;
        }

        .accordion-header.active .accordion-icon {
            transform: rotate(180deg);
        }

        .export-dropdown {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .export-dropdown select {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 6px;
        }

        .export-buttons {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        /* Export Preview Modal */
        .modal {
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #e9ecef;
        }

        .modal-header h3 {
            margin: 0;
            color: #333;
        }

        .modal-body {
            padding: 1.5rem;
        }

        .sidebar-resize-handle {
            position: absolute;
            right: -5px;
            top: 0;
            width: 10px;
            height: 100%;
            cursor: col-resize;
            background: transparent;
            z-index: 1000;
        }

        .sidebar-resize-handle:hover {
            background: rgba(66, 165, 245, 0.2);
        }

        .sidebar-resize-handle:active {
            background: rgba(66, 165, 245, 0.4);
        }

        .sidebar-toggle-btn {
            position: absolute;
            right: -30px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 60px;
            background: #42a5f5;
            border: none;
            border-radius: 0 8px 8px 0;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
        }

        .sidebar-toggle-btn:hover {
            background: #1976d2;
            width: 35px;
        }

        .sidebar.collapsed {
            width: 0;
            min-width: 0;
            overflow: hidden;
        }

        .sidebar.collapsed .sidebar-content {
            opacity: 0;
        }

        .sidebar.collapsed .header {
            opacity: 0;
        }
  
        .header {
            background: #ffffff;
            color: inherit;
            padding: 1.5rem 1rem;
            text-align: center;
        }
  
        .header h1 {
            font-size: 1.3rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            color: #800000;
            text-shadow: none;
        }
  
        .header .subtitle {
            font-size: 0.9rem;
            opacity: 0.9;
            font-weight: 300;
        }

        /* Header title with logo row */
        .header-title-row { 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            gap: 10px; 
        }
        .header-title-row .header-logo {
            max-height: 100px; 
            width: auto; 
            display: inline-block;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.25));
        }
  
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }
  
        .section {
            margin-bottom: 1.5rem;
            background: white;
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            overflow-x: visible;
        }
  
        .section h3 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #2c3e50;
            border-bottom: 2px solid #42a5f5;
            padding-bottom: 0.5rem;
        }
  
        .file-input {
            margin-bottom: 1rem;
        }
  
        .file-input label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #6c757d;
            font-size: 0.9rem;
        }
  
        .file-input input[type="file"] {
            width: 100%;
            padding: 0.75rem;
            border: 2px dashed #cbd5e0;
            border-radius: 8px;
            background: #f8f9fa;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }
  
        .file-input input[type="file"]:hover {
            border-color: #42a5f5;
            background: white;
        }
  
        .status {
            padding: 0.75rem;
            margin-top: 0.5rem;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 500;
        }
  
        .status.success {
            background: #d4edda;
            color: #155724;
            border-left: 4px solid #28a745;
        }
  
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border-left: 4px solid #dc3545;
        }
  
        .status.processing {
            background: #d1ecf1;
            color: #0c5460;
            border-left: 4px solid #17a2b8;
        }
  
        .btn {
            background: linear-gradient(135deg, #42a5f5 0%, #1976d2 100%);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            width: 100%;
        }
  
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.6);
        }
  
        .btn:disabled {
            background: #e9ecef;
            color: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
  
        .control-group {
            margin-bottom: 0.75rem;
        }
  
        .control-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #495057;
            font-size: 0.9rem;
        }
  
        .control-group select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ced4da;
            border-radius: 6px;
            background: white;
            font-size: 0.9rem;
        }
  
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
  
        .checkbox-group-container {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            padding: 0.25rem;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            background: #f9fafb;
        }
        
        .filter-category {
            margin-bottom: 0.75rem;
        }
        
        .filter-category-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            padding: 0.5rem;
            background: #f3f4f6;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            font-weight: 600;
            font-size: 0.9rem;
            color: #374151;
        }
        
        .filter-category-header:hover {
            background: #e5e7eb;
        }
        
        .filter-category-content {
            display: none;
            flex-direction: column;
            gap: 0.25rem;
            padding: 0.25rem;
        }
        
        .filter-category-content.expanded {
            display: flex;
        }
        
        .filter-category-toggle {
            font-size: 0.8rem;
            color: #6b7280;
            transition: transform 0.2s ease;
        }
        
        .filter-category-toggle.expanded {
            transform: rotate(90deg);
        }
  
        .checkbox-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }
  
        .main-content {
            flex: 1;
            position: relative;
            background: #f8f9fa;
            height: 100vh;
            overflow-y: auto;
        }
  
        .network-svg {
            width: 100%;
            height: 100%;
        }
  
        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(10px);
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            min-width: 200px;
        }
  
        .legend h4 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #2c3e50;
            text-align: center;
        }
  
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            font-weight: 500;
        }
  
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.2);
        }

        /* Fixed bottom details bar aligned to the right of the sidebar */
        .bottom-details-fixed {
            position: fixed;
            right: 0;
            left: var(--sidebar-width, 340px);
            bottom: 0;
            background: #ffffff;
            border-top: 1px solid #e5e7eb;
            box-shadow: 0 -8px 20px rgba(0,0,0,0.08);
            z-index: 1200;
            height: var(--bottom-details-height, 120px);
            min-height: 80px;
            max-height: 40vh;
            overflow: hidden;
            border-radius: 8px 8px 0 0;
        }
        .bottom-details-fixed .details-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            font-weight: 700;
            color: #111827;
            border-bottom: 1px solid #f1f5f9;
            cursor: move;
        }
        .bottom-details-fixed .details-body {
            padding: 8px 12px 10px 12px;
            height: calc(100% - 40px);
            overflow: auto;
        }

        /* Modern Two-thumb Range Slider */
        .range-filter-container {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 12px;
            align-items: center;
            margin: 8px 0;
        }
        
        .range-filter-label {
            font-weight: 500;
            color: #374151;
            font-size: 0.875rem;
        }
        
        .range-filter-value {
            font-weight: 600;
            color: #1f2937;
            font-size: 0.875rem;
            min-width: 80px;
            text-align: right;
        }
        
        .range-slider {
            position: relative;
            height: 20px;
            margin: 8px 0;
            cursor: pointer;
        }
        
        .range-slider .track {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            height: 4px;
            background: #e5e7eb;
            border-radius: 2px;
            width: 100%;
        }
        
        .range-slider .range {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            height: 4px;
            background: rgba(59, 130, 246, 0.7);
            border-radius: 2px;
            transition: all 0.1s ease;
        }
        
        .range-slider .thumb {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ffffff;
            border: 2px solid #3b82f6;
            cursor: grab;
            transition: all 0.1s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .range-slider .thumb:hover {
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }
        
        .range-slider .thumb:active {
            cursor: grabbing;
            transform: translate(-50%, -50%) scale(1.05);
        }
        
        .range-slider .thumb:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
        }
        
        .range-slider .thumb:focus-visible {
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
        }
        
        .range-reset-btn {
            background: none;
            border: 1px solid #d1d5db;
            color: #6b7280;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.1s ease;
        }
        
        .range-reset-btn:hover {
            background: #f3f4f6;
            color: #374151;
        }
        
        .range-reset-btn:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
        }

        /* Responsive grid for details */
        .details-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            column-gap: 10px;
            row-gap: 6px;
        }
        .details-grid-four {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            column-gap: 8px;
            row-gap: 4px;
        }
        
        .details-grid-two {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            column-gap: 12px;
            row-gap: 6px;
        }
        .details-full-row {
            grid-column: 1 / -1;
        }
        
        @media (max-width: 1200px) {
            .details-grid-four {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        @media (max-width: 768px) {
            .details-grid-four {
                grid-template-columns: repeat(2, 1fr);
            }
            .details-grid-two {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 480px) {
            .details-grid-four {
                grid-template-columns: 1fr;
            }
        }

        /* Compact typography for bottom details */
        .bottom-details-fixed .info-row {
            display: grid;
            grid-template-columns: auto 1fr;
            column-gap: 8px;
            align-items: baseline;
            padding: 2px 0;
        }
        .bottom-details-fixed .info-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: #374151;
            white-space: nowrap;
        }
        .bottom-details-fixed .info-value {
            font-size: 0.85rem;
            color: #111827;
            overflow: visible;
            text-overflow: unset;
            white-space: normal;
            word-break: break-word;
            line-height: 1.25;
        }
  
        .info-panel {
            position: absolute;
            background: rgba(255,255,255,0.98);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            max-height: 70vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15);
            display: none;
            z-index: 1000;
        }
  
        .info-panel h3 {
            margin-bottom: 1.5rem;
            color: #2c3e50;
            font-size: 1.3rem;
            font-weight: 700;
            border-bottom: 3px solid #42a5f5;
            padding-bottom: 0.5rem;
        }
  
        .info-row {
            display: grid;
            grid-template-columns: 1fr 1.5fr;
            gap: 1rem;
            margin-bottom: 0.75rem;
            padding: 0.5rem 0;
            border-bottom: 1px solid #f1f3f4;
        }
  
        .info-label {
            font-weight: 600;
            color: #495057;
        }
  
        .info-value {
            color: #2c3e50;
            font-weight: 500;
        }
  
        .context-box {
            cursor: pointer;
        }
  
        .context-box.clickable {
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.2));
        }
  
        .info-icon {
            pointer-events: none !important;
        }
        
        .info-icon path {
            fill: #8b0000 !important;
            opacity: 0.9 !important;
        }
  
        .node {
            cursor: pointer;
        }
  
        .ego-node {
            filter: drop-shadow(0 6px 12px rgba(231, 76, 60, 0.4));
        }
  
        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-size: 0.85rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 2000;
            max-width: 250px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
            display: none !important;
            visibility: hidden !important;
        }
  
        .breadcrumb {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255,255,255,0.9);
            backdrop-filter: blur(10px);
            padding: 0.75rem 1.5rem;
            border-radius: 25px;
            font-weight: 500;
            color: #495057;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            z-index: 100;
        }
  
        .close-panel {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6c757d;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
  
        .close-panel:hover {
            background: #f8f9fa;
            color: #495057;
        }
  
        /* Node selection states - only apply for context mode */
        .node--selected circle {
            stroke-width: 3px !important;
        }
  
        .node--neighbor circle {
            stroke-width: 3px !important;
        }
        
        /* Override fill colors only for context mode */
        .context-mode .node--selected circle {
            fill: #ef4444 !important;
        }
  
        .context-mode .node--neighbor circle {
            fill: #fb923c !important;
        }
  
        /* Edge states */
        .edge--active {
            stroke: #ef4444 !important;
            stroke-width: 3.5px !important;
            opacity: 0.5 !important;
        }
  
        /* Ensure proper layering - no z-index for SVG */
        .background-layer {
            /* Background elements (context boxes, ego connectors) */
            z-index: 1;
        }
  
        .edges-layer {
            /* Edges layer - above background, below nodes */
            z-index: 2;
        }
  
        .nodes-layer {
            /* Nodes layer - on top */
            z-index: 3;
        }
  
        /* Range slider styling */
        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
  
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #42a5f5;
            cursor: pointer;
        }
  
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #42a5f5;
            cursor: pointer;
            border: none;
        }
  
        /* Floating cards */
        .floating-card {
            position: fixed;
            background: rgba(255,255,255,0.98);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 16px;
            padding: 1.2rem;
            max-width: 300px;
            max-height: 60vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15);
            z-index: 2000;
            bottom: 20px;
            right: 20px;
            font-size: 0.9rem;
            line-height: 1.35;
        }
  
        .floating-card h3 {
            margin-bottom: 0.8rem;
            color: #2c3e50;
            font-size: 1rem;
            font-weight: 700;
            border-bottom: 2px solid #42a5f5;
            padding-bottom: 0.4rem;
        }
  
        .floating-card .info-label {
            font-size: 0.85rem;
            font-weight: 600;
        }
  
        .floating-card .info-value {
            font-size: 0.9rem;
        }
  
        /* Enhanced legend system */
        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(10px);
            padding: 1.2rem;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            min-width: 200px;
            max-width: 280px;
        }
  
        .legend-section {
            margin-bottom: 1.2rem;
        }
  
        .legend-section:last-child {
            margin-bottom: 0;
        }
  
        .legend-section h4 {
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 0.8rem;
            color: #2c3e50;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 0.4rem;
        }
  
        .size-legend-item {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            margin-bottom: 0.4rem;
            font-size: 0.8rem;
        }
  
        .size-circle {
            border-radius: 50%;
            background: #ccc;
            border: 1px solid #999;
            flex-shrink: 0;
        }
  
        /* Data processed banner */
        .success-banner {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
        }
  
        /* Responsive grid for summary tiles */
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: 12px;
            margin-bottom: 1rem;
        }
  
        /* Help overlay */
        .help-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 3000;
            display: none;
        }
  
        .help-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 16px;
            padding: 2rem;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
  
        /* Subtle hover effects only - no movement */
        .node:hover circle {
            stroke-width: 5px;
        }
  
        /* Search highlighting */
        .node.search-match circle {
            stroke: #ff6b35 !important;
            stroke-width: 4px !important;
            filter: drop-shadow(0 2px 4px rgba(255, 107, 53, 0.4));
        }
  
        /* Survey respondent indicator */
        .node.survey-respondent {
            position: relative;
        }
        
        .node.survey-respondent::after {
            content: '★';
            position: absolute;
            top: -5px;
            right: -5px;
            color: #ffd700;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            z-index: 10;
        }
  
        /* Page routing and transitions */
        .page {
            transition: opacity 200ms ease-in-out;
            min-height: 100vh;
        }
  
        .page.hidden {
            opacity: 0;
            pointer-events: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            z-index: -1;
        }
  
        /* Welcome page */
        .welcome-page {
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f8f9fa;
            padding: 1rem;
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            height: 100vh;
            overflow-y: auto;
        }
        
        /* University of Chicago Logo Styles */
        .logos-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 1rem;
            width: 100%;
            min-height: 120px;
            padding: 0.5rem 0;
        }
        
        .logo-image {
            max-width: 100% !important;
            width: auto !important;
            height: 120px !important;
            min-height: 120px !important;
            object-fit: contain !important;
            display: block !important;
            margin: 0 auto;
        }
  
        .welcome-card {
            background: white;
            border-radius: 16px;
            padding: 2rem 2rem 2.5rem 2rem;
            max-width: 1200px !important;
            width: 100%;
            text-align: center;
            margin-bottom: 1rem;
        }
  
        .welcome-title {
            font-size: 2rem;
            font-weight: 700;
            color: #8b0000;
            margin-bottom: 0.75rem;
            background: linear-gradient(135deg, #8b0000 0%, #a52a2a 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
  
        .welcome-subtitle {
            font-size: 1rem;
            color: #6c757d;
            margin-bottom: 1.5rem;
            line-height: 1.5;
        }
  
        .upload-zones {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
        }
  
        .upload-zone {
            border: 2px dashed #cbd5e0;
            border-radius: 12px;
            padding: 1rem 0.75rem;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            transition: all 0.3s ease;
            cursor: pointer;
            text-align: center;
            aspect-ratio: 1.1;
        }
  
        .upload-zone:hover {
            border-color: #8b0000;
            background: white;
            box-shadow: 0 4px 15px rgba(139, 0, 0, 0.1);
        }
  
        .upload-zone.loaded {
            border-color: #28a745;
            background: #d4edda;
        }
  
        .upload-zone.error {
            border-color: #dc3545;
            background: #f8d7da;
        }
  
        .upload-zone h4 {
            margin: 0 0 0.5rem 0;
            color: #495057;
            font-weight: 600;
        }
  
        .upload-zone p {
            margin: 0 0 1rem 0;
            font-size: 0.8rem; /* smaller to fit long filenames */
            color: #6c757d;
            max-width: 100%;
            white-space: normal; /* allow wrapping */
            word-break: break-word;
            overflow-wrap: anywhere;
        }
  
        .upload-status {
            font-size: 0.85rem;
            font-weight: 500;
            margin-top: 0.5rem;
        }
  
        .upload-status.success {
            color: #155724;
        }
  
        .upload-status.error {
            color: #721c24;
        }
        
        .local-usage-instructions {
            margin: 2rem 0;
        }
        
        .instruction-card {
            display: flex;
            align-items: flex-start;
            margin-bottom: 1.5rem;
            padding: 1.5rem;
            background: #f8f9fa;
            border-radius: 12px;
            border: 1px solid #e9ecef;
            transition: all 0.3s ease;
        }
        
        .instruction-card:hover {
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }
        
        .step-number {
            background: linear-gradient(135deg, #8B0000, #A52A2A);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            margin-right: 1.5rem;
            flex-shrink: 0;
            box-shadow: 0 4px 8px rgba(139, 0, 0, 0.3);
        }
        
        .step-content h4 {
            margin: 0 0 0.5rem 0;
            color: #2c3e50;
            font-size: 1.1rem;
        }
        
        .step-content p {
            margin: 0.5rem 0;
            color: #495057;
            line-height: 1.5;
        }
        
        .step-content ul {
            margin: 0.5rem 0;
            padding-left: 1.5rem;
        }
        
        .step-content li {
            margin: 0.25rem 0;
            color: #495057;
        }
        
        .download-section {
            margin: 2rem 0;
            padding: 1.5rem;
            background: #f8f9fa;
            border-radius: 12px;
            border: 2px solid #e9ecef;
            text-align: center;
        }
        
        .download-section h3 {
            margin: 0 0 0.5rem 0;
            color: #2c3e50;
            font-size: 1.2rem;
        }
        
        .download-section p {
            margin: 0.5rem 0 1rem 0;
            color: #495057;
        }
        
        .download-button {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(40, 167, 69, 0.3);
        }
        
        .download-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(40, 167, 69, 0.4);
        }
   
        .process-button {
            background: linear-gradient(135deg, #8b0000 0%, #a52a2a 100%);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(139, 0, 0, 0.4);
            margin: 1rem 0 0.75rem 0;
        }
  
        .process-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(139, 0, 0, 0.6);
        }
  
        .process-button:disabled {
            background: #e9ecef;
            color: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
  
        .sample-link {
            color: #8b0000;
            text-decoration: none;
            font-size: 0.85rem;
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
            display: inline-block;
        }
  
        .sample-link:hover {
            text-decoration: underline;
        }
  
        /* Validation page */
        .validation-page {
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f8f9fa;
            padding: 1rem;
            height: 100vh;
            overflow-y: auto;
        }
  
        .validation-card {
            background: white;
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
        }
  
        .validation-header {
            text-align: center;
            margin-bottom: 0.75rem;
        }
  
        .validation-status {
            padding: 0.75rem;
            border-radius: 8px;
            margin-bottom: 1.25rem;
            text-align: center;
            font-weight: 600;
        }
  
        .validation-status.pass {
            background: #d4edda;
            color: #155724;
        }
  
        .validation-status.fail {
            background: #f8d7da;
            color: #721c24;
        }
  
        .validation-file {
            margin-bottom: 0.75rem;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 0.75rem;
        }
  
        .validation-file h4 {
            margin: 0 0 0.75rem 0;
            color: #495057;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
  
        .validation-check {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }
  
        .check-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }
  
        .check-icon.pass {
            background: #28a745;
            color: white;
        }
  
        .check-icon.fail {
            background: #dc3545;
            color: white;
        }
  
        .validation-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 2rem;
        }
  
  
        .back-link {
            color: #42a5f5;
            text-decoration: none;
            font-size: 0.9rem;
            margin-top: 1.5rem;
            display: inline-block;
        }
  
        .back-link:hover {
            text-decoration: underline;
        }
  
        /* Dataset placeholder page */
        .dataset-page {
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f8f9fa;
            padding: 2rem;
            min-height: 100vh;
        }
  
        .dataset-card {
            background: white;
            border-radius: 16px;
            padding: 2.5rem;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            max-width: 400px;
            width: 100%;
            text-align: center;
        }
        
        /* Whole Data Exploration Page */
        .whole-data-page {
            background: #f8f9fa;
            min-height: 100vh;
        }
        
        .whole-data-page .dashboard-container {
            height: calc(100vh - 60px);
        }
        
        .whole-data-page .main-content {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
        }
        
        .plot-container {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .plot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #42a5f5;
        }
        
        .plot-header h3 {
            margin: 0;
            color: #2c3e50;
            font-size: 1.3rem;
        }
        
        .stats-panel {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid #42a5f5;
            font-size: 0.9rem;
            color: #495057;
            max-width: 100%;
            overflow: hidden;
        }
        /* Ensure long text (e.g., label lists, vectors) wraps inside the box */
        .stats-panel, .stats-panel * {
            word-break: break-word;
            overflow-wrap: anywhere;
            white-space: normal;
        }
        /* Allow grid children to shrink within the container so they don't force overflow */
        .stats-panel > div > * {
            min-width: 0;
        }
        
        /* Network stats improved layout */
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem 1rem;
        }
        .stat-item {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 0.6rem 0.75rem;
            box-shadow: 0 1px 2px rgba(0,0,0,0.03);
        }
        .stat-label {
            display: block;
            color: #6c757d;
            font-weight: 600;
            letter-spacing: .2px;
        }
        .stat-value {
            display: block;
            color: #212529;
            font-weight: 700;
            margin-top: 0.15rem;
        }
        .stat-section-title {
            grid-column: 1 / -1;
            margin-top: 0.5rem;
            font-weight: 800;
            color: #2c3e50;
            border-top: 2px solid #e9ecef;
            padding-top: 0.5rem;
        }
        
        .chart-area {
            min-height: 400px;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
        }
        
        .welcome-message {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 60vh;
        }
        
        .welcome-card {
            background: white;
            padding: 2rem;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            text-align: center;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .welcome-card h2 {
            color: #2c3e50;
            margin-bottom: 0.5rem;
            font-size: 1.8rem;
        }
        
        .welcome-card p {
            color: #6c757d;
            margin-bottom: 1rem;
            line-height: 1.5;
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .feature-item {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid #42a5f5;
        }
        
        .feature-item h4 {
            color: #2c3e50;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }
        
        .feature-item p {
            color: #6c757d;
            font-size: 0.9rem;
            margin: 0;
        }
  
        /* Breadcrumb */
        .breadcrumb {
            position: fixed;
            top: 80px;
            left: 400px;
            background: rgba(255,255,255,0.9);
            backdrop-filter: blur(10px);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.85rem;
            color: #495057;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            z-index: 1000;
            transition: all 0.3s ease;
            cursor: move;
            user-select: none;
            min-width: 300px;
            white-space: nowrap;
        }
        
        .breadcrumb.collapsed {
            width: 60px;
            overflow: hidden;
            transition: width 0.3s ease;
        }
        
        .breadcrumb.collapsed .breadcrumb-content,
        .breadcrumb.collapsed .screenshot-controls {
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .breadcrumb.collapsed .header-controls {
            opacity: 1;
            transition: opacity 0.3s ease;
        }
        
        .breadcrumb-content {
            display: inline-block;
        }
        
        .header-controls {
            display: inline-block;
            margin-left: 15px;
            vertical-align: middle;
            opacity: 1;
            transition: opacity 0.3s ease;
            position: relative;
            z-index: 1001;
        }
        
        .toggle-header-btn, .move-header-btn {
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 4px;
            padding: 2px 6px;
            margin: 0 2px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
            display: inline-block !important;
            visibility: visible !important;
        }
        
        .toggle-header-btn:hover, .move-header-btn:hover {
            background: rgba(102, 126, 234, 0.2);
            border-color: rgba(102, 126, 234, 0.5);
        }
        
        .breadcrumb.dragging {
            opacity: 0.8;
            transform: scale(1.02);
        }
  
        .breadcrumb a {
            color: #42a5f5;
            text-decoration: none;
        }
  
        .breadcrumb a:hover {
            text-decoration: underline;
        }
        
        /* Screenshot Controls in Breadcrumb */
        .screenshot-controls {
            margin-left: 20px;
        }
        
        .screenshot-controls select {
            border: 1px solid #ced4da;
            border-radius: 4px;
            padding: 0.3rem;
            font-size: 0.85rem;
            background: white;
        }
        
        .screenshot-controls .btn {
            background: #42a5f5;
            color: white;
            border: none;
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background-color 0.2s ease;
        }
        
        .screenshot-controls .btn:hover {
            background: #5a6fd8;
        }
  
        /* Data processed chip */
        .data-chip {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            text-align: center;
            margin-bottom: 1rem;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
        }
  
        /* Sidebar Navigation Tabs */
        .sidebar-nav {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #e5e7eb;
        }
  
        .nav-tab {
            flex: 1;
            min-width: fit-content;
            padding: 0.5rem 0.6rem;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            white-space: nowrap;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            color: #374151;
        }
  
        .nav-tab:hover {
            background: #f8fafc;
            border-color: #42a5f5;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(66, 165, 245, 0.2);
        }
  
        .nav-tab.active {
            background: linear-gradient(135deg, #42a5f5 0%, #1976d2 100%);
            color: white;
            border-color: #1976d2;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(66, 165, 245, 0.3);
        }
  
        .sidebar-section {
            display: none;
        }
  
        .sidebar-section.active {
            display: block;
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .sidebar {
                width: 300px;
                min-width: 260px;
            }
            
            .header h1 {
                font-size: 1.2rem;
            }
            
            .sidebar-content {
                padding: 0.75rem;
            }
            
            .section {
                padding: 0.75rem;
                margin-bottom: 1rem;
            }
            
            .nav-tab {
                font-size: 0.8rem;
                padding: 0.4rem 0.5rem;
                min-width: fit-content;
            }
        }

        @media (max-width: 768px) {
            .sidebar {
                width: 280px;
                min-width: 240px;
            }
            
            .header h1 {
                font-size: 1.1rem;
            }
            
            .sidebar-content {
                padding: 0.5rem;
            }
            
            .section {
                padding: 0.5rem;
                margin-bottom: 0.75rem;
            }
            
            .nav-tab {
                font-size: 0.75rem;
                padding: 0.35rem 0.45rem;
                min-width: fit-content;
            }
        }
  
        /* Resizable moveable details panel for selected alter */
        .resizable-details-panel {
            position: absolute;
            top: 320px;
            right: 20px;
            width: 280px;
            min-width: 250px;
            max-width: 500px;
            min-height: 200px;
            max-height: calc(100vh - 360px);
            background: rgba(255,255,255,0.98);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15);
            z-index: 1500;
            display: none;
            overflow: hidden;
            cursor: move;
        }
  
        .resizable-details-panel .panel-header {
            padding: 1rem 1.5rem 0.5rem 1.5rem;
            border-bottom: 2px solid #42a5f5;
            margin-bottom: 1rem;
            cursor: move;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
  
        .resizable-details-panel .panel-header h3 {
            margin: 0;
            color: #2c3e50;
            font-size: 1rem;
            font-weight: 700;
        }
  
        .resizable-details-panel .panel-content {
            padding: 0 1.5rem 1.5rem 1.5rem;
            overflow-y: auto;
            height: 300px;
            max-height: calc(100vh - 420px);
            font-size: 0.9rem;
            line-height: 1.4;
        }
  
        .resizable-details-panel .info-row {
            display: flex;
            flex-direction: column;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid #e9ecef;
        }
  
        .resizable-details-panel .info-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: #495057;
            margin-bottom: 0.25rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
  
        .resizable-details-panel .info-value {
            font-size: 0.95rem;
            color: #2c3e50;
            line-height: 1.3;
            word-break: break-word;
            hyphens: auto;
        }
  
        .resizable-details-panel .close-btn {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            color: #6c757d;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
  
        .resizable-details-panel .close-btn:hover {
            background: #f8f9fa;
            color: #495057;
        }
  
        /* Resize handles for all edges */
        .resizable-details-panel {
            resize: none; /* Disable default resize */
        }
  
        .resizable-details-panel .resize-handle {
            position: absolute;
            background: transparent;
            z-index: 10;
        }
  
        .resizable-details-panel .resize-handle-n {
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            cursor: n-resize;
        }
  
        .resizable-details-panel .resize-handle-s {
            bottom: 0;
            left: 0;
            right: 0;
            height: 5px;
            cursor: s-resize;
        }
  
        .resizable-details-panel .resize-handle-e {
            top: 0;
            right: 0;
            bottom: 0;
            width: 5px;
            cursor: e-resize;
        }
  
        .resizable-details-panel .resize-handle-w {
            top: 0;
            left: 0;
            bottom: 0;
            width: 5px;
            cursor: w-resize;
        }
  
        .resizable-details-panel .resize-handle-ne {
            top: 0;
            right: 0;
            width: 10px;
            height: 10px;
            cursor: ne-resize;
        }
  
        .resizable-details-panel .resize-handle-nw {
            top: 0;
            left: 0;
            width: 10px;
            height: 10px;
            cursor: nw-resize;
        }
  
        .resizable-details-panel .resize-handle-se {
            bottom: 0;
            right: 0;
            width: 10px;
            height: 10px;
            cursor: se-resize;
        }
  
        .resizable-details-panel .resize-handle-sw {
            bottom: 0;
            left: 0;
            width: 10px;
            height: 10px;
            cursor: sw-resize;
        }
  
        /* Visual indicator for the bottom-right resize handle */
        .resizable-details-panel .resize-handle-se::after {
            content: '';
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-bottom: 8px solid #ccc;
            opacity: 0.6;
        }
  
        /* Fixed details panel - COMPLETELY REWRITTEN */
        .fixed-details-panel {
            position: absolute;
            left: 20px;
            top: 80px;
            width: 320px;
            max-height: calc(100vh - 120px);
            background: rgba(255,255,255,0.98);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0 20px 60px rgba(0,0,0,0.15);
            z-index: 1500;
            overflow-y: auto;
            overflow-x: hidden;
            display: none;
            font-size: 0.9rem;
            line-height: 1.4;
        }
  
        .fixed-details-panel h3 {
            margin-bottom: 1rem;
            color: #2c3e50;
            font-size: 1rem;
            font-weight: 700;
            border-bottom: 2px solid #42a5f5;
            padding-bottom: 0.5rem;
        }
  
        .fixed-details-panel .info-row {
            display: flex;
            flex-direction: column;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid #e9ecef;
        }
  
        .fixed-details-panel .info-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: #495057;
            margin-bottom: 0.25rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
  
        .fixed-details-panel .info-value {
            font-size: 0.95rem;
            color: #2c3e50;https://github.com/bethanyou/Child-Social-Network-Questionnaire/blob/135c61cc0d8aceadfe725e3a689be35eae3b49d9/logo3-removebg-preview.png
            line-height: 1.3;
            word-break: break-word;
            hyphens: auto;
        }
    </style>
  </head>
  <body>
    <!-- Welcome Page -->
    <div id="welcomePage" class="page welcome-page hidden">
        <div class="welcome-card">
            <!-- University of Chicago Header (remote) -->
            <div class="logos-container" style="text-align:center; padding:12px 0;">
                <img alt="University of Chicago Header" loading="lazy" src="https://raw.githubusercontent.com/bethanyou/CSNQ/fc3586f7d9bc3a9ee4fa0f6f42bd378ed5b89d3d/image.png" style="max-width:100%; height:auto; display:inline-block;" class="logo-image">
            </div>
            
            <h1 class="welcome-title">SNQ Network Plotting Dashboard</h1>
            <p class="welcome-subtitle">This is a local tool for exploring social networks. Upload your processed CSV files below to start plotting.</p>

            <div class="upload-zones" id="uploadZones" style="display:grid;">
                <div class="upload-zone" onclick="document.getElementById('nodeLevelLongFile').click()">
                    <h4>Node Data</h4>
                    <p>node_level_long.csv</p>
                    <input type="file" id="nodeLevelLongFile" accept=".csv" style="display: none;">
                    <div id="nodeLevelLongStatus" class="upload-status">Click to upload</div>
                    <button class="process-button" style="margin-top:8px" onclick="document.getElementById('nodeLevelLongFile').click(); event.stopPropagation();">Upload Node CSV</button>
                </div>

                <div class="upload-zone" onclick="document.getElementById('egoLevelNetworkSummaryFile').click()">
                    <h4>Child Summary Data</h4>
                    <p>ego_level_network_summary.csv</p>
                    <input type="file" id="egoLevelNetworkSummaryFile" accept=".csv" style="display: none;">
                    <div id="egoLevelNetworkSummaryStatus" class="upload-status">Click to upload</div>
                    <button class="process-button" style="margin-top:8px" onclick="document.getElementById('egoLevelNetworkSummaryFile').click(); event.stopPropagation();">Upload Child CSV</button>
                </div>
                
                
            </div>
  
            
            
            <a href="#" class="sample-link" onclick="showSampleFormats()">View sample file formats</a>
        </div>
                    </div>
  
    <!-- Validation Page -->
    <div id="validatePage" class="page validation-page hidden">
        <div class="validation-card">
            <div class="validation-header">
                <h2>Data Validation</h2>
                    </div>
  
            <div id="validationStatus" class="validation-status pass">✅ All checks passed<br><span style="color: #155724;">Your data look good.</span></div>
            
            <div id="validationResults">
                    <div class="validation-file">
                        <h4>
                            <div class="check-icon pass">✓</div>
                            node_level_long.csv
                        </h4>
                        
                    <div class="validation-check">
                        <div class="check-icon pass">
                            ✓
                        </div>
                        <span>Required columns present</span>
                    </div>
                
                    <div class="validation-check">
                        <div class="check-icon pass">
                            ✓
                        </div>
                        <span>Data integrity</span>
                    </div>
                
                        
                    </div>
                
                    <div class="validation-file">
                        <h4>
                            <div class="check-icon pass">✓</div>
                            ego_level_network_summary.csv
                        </h4>
                        
                    <div class="validation-check">
                        <div class="check-icon pass">
                            ✓
                        </div>
                        <span>Required columns present</span>
                    </div>
                
                    <div class="validation-check">
                        <div class="check-icon pass">
                            ✓
                        </div>
                        <span>Data integrity</span>
                    </div>
                
                        
                    </div>
                
                    
                </div>
            
            <div class="validation-buttons">
                <button class="process-button" onclick="goToWelcome()">Re-upload Files</button>
                <button class="process-button" id="continueBtn" onclick="goToMode()">Continue</button>
            </div>
        </div>
    </div>
  
  
    <!-- Whole Data Exploration Page -->
    <div id="wholeDataPage" class="page whole-data-page hidden">
        <div class="breadcrumb" id="wholeDataBreadcrumb">
            <div class="breadcrumb-content">
                <a href="#" onclick="goToValidate()">Home</a> / Explore Whole Data
            </div>
            <div class="screenshot-controls" style="float: right; display: flex; align-items: center; gap: 10px;">
                <select id="wholeDataScreenshotFormat" style="padding: 0.3rem; border: 1px solid #ced4da; border-radius: 4px; font-size: 0.9rem;">
                    <option value="png">PNG</option>
                    <option value="jpg">JPG</option>
                    <option value="svg">SVG</option>
                </select>
                <button class="btn" onclick="takeWholeDataScreenshot()" style="background: #42a5f5; color: white; border: none; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; font-size: 0.9rem;">
                    📸 Screenshot
                </button>
            </div>
            <div class="header-controls">
                <button class="toggle-header-btn" onclick="toggleWholeDataHeader()" title="Toggle header visibility">
                    <span id="wholeDataToggleIcon">▼</span>
                </button>
                <button class="move-header-btn" onmousedown="startWholeDataHeaderDrag(event)" title="Drag to move header">
                    🖐️
                </button>
            </div>
        </div>
        
        <div class="dashboard-container">
            <div class="sidebar" id="wholeDataSidebar" style="">
                <div class="header">
                    <div class="header-title-row">
                        <img class="header-logo" alt="CSNQ Logo" src="https://raw.githubusercontent.com/bethanyou/Child-Social-Network-Questionnaire/135c61cc0d8aceadfe725e3a689be35eae3b49d9/logo3-removebg-preview.png" />
                        <h1>SNQ Network Plotting Dashboard</h1>
                    </div>
                    <div class="subtitle">Whole Data Exploration</div>
                </div>
                
                <!-- Resize Handle -->
                <div class="sidebar-resize-handle" id="wholeDataSidebarResizeHandle"></div>
                
                <!-- Toggle Button -->
                <button class="sidebar-toggle-btn" id="wholeDataSidebarToggleBtn" onclick="toggleWholeDataSidebar()" title="Toggle Sidebar">
                    ◀
                </button>
                
                <div class="sidebar-content">
                    <div class="data-chip">
                        Data processed ✓
                    </div>
                    
                    <div class="section" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                        <h4>💡 Testing Mode</h4>
                        <p style="font-size: 0.9rem; margin: 0;">You can test the exploration features with sample data while uploading your own files. Upload your CSV files on the main page to analyze your real data.</p>
                    </div>
                    
                    <!-- Exploration Mode Selection -->
                    <div class="section">
                        <h3>📊 Exploration Mode</h3>
                        <div class="control-group">
                            <label>Mode:</label>
                            <select id="wholeDataExplorationMode" onchange="updateWholeDataExplorationView()">
                                <option value="distribution">Distribution Explorer</option>
                                <option value="interaction">Interaction Explorer</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Distribution Controls -->
                    <div id="wholeDataDistributionControls" class="section">
                        <h3>📈 Distribution Explorer</h3>
                        <div class="control-group">
                            <label>Variable:</label>
                            <select id="wholeDataDistributionVariable" onchange="updateWholeDataDistributionPlot()">
                                <option value="">Select a variable...</option>
                                <optgroup label="Demographics">
                                    <option value="age_in_months">Age (months)</option>
                                    <option value="child_gender">Gender</option>
                                    <option value="child_race">Race/Ethnicity</option>
                                    <option value="child_lang">Languages</option>
                                </optgroup>
                                <optgroup label="Care Context">
                                    <option value="childcare_yn">Childcare (Y/N)</option>
                                    <option value="childcare_type">Childcare Type</option>
                                    <option value="childcare_start_age">Childcare Start Age</option>
                                    <option value="childcare_size">Group Size</option>
                                </optgroup>
                                <optgroup label="Network Structure">
                                    <option value="network_size">Network Size</option>
                                    <option value="prop_adult_relationship">% Adult Nodes</option>
                                    <option value="prop_kin_relationship">% Kin Nodes</option>
                                    <option value="network_density">Network Density</option>
                                    <option value="edges_number">Number of Ties</option>
                                    <option value="component_count">Component Count</option>
                                    <option value="component_ratio">Component Ratio</option>
                                </optgroup>
                                <optgroup label="Diversity Indices">
                                    <option value="racial_ei_index">Racial EI Index</option>
                                    <option value="race_entropy">Race Entropy</option>
                                    <option value="linguistic_ei_index">Linguistic EI Index</option>
                                    <option value="language_entropy">Language Entropy</option>
                                </optgroup>
                                <optgroup label="Derived Metrics">
                                    <option value="sibling_size">Sibling Size</option>
                                    <option value="kin_size">Kin Size</option>
                                    <option value="extended_family_presence">Extended Family Presence</option>
                                    <option value="caregiver_presence">Caregiver Presence</option>
                                    <option value="live_at_home_size">Live-at-Home Size</option>
                                    <option value="parent_vs_nonparent_caregiver">Parent vs Non-Parent Caregiver</option>
                                    <option value="pct_male_alters">% Male Nodes</option>
                                    <option value="pct_female_alters">% Female Nodes</option>
                                    <option value="avg_closeness_score">Average Closeness Score</option>
                                    <option value="max_closeness_score">Max Closeness Score</option>
                                    <option value="min_closeness_score">Min Closeness Score</option>
                                    <option value="avg_weekly_exposure">Average Weekly Exposure</option>
                                    <option value="exposure_by_context">Exposure by Context</option>
                                    <option value="mode_of_contact_proportions">Mode of Contact Proportions</option>
                                    <option value="activity_count">Activity Count</option>
                                    <option value="activity_diversity">Activity Diversity</option>
                                    <option value="pct_activities_with_peers">% Activities with Peers</option>
                                    <option value="activity_language_distribution">Activity Language Distribution</option>
                                </optgroup>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Interaction Controls -->
                    <div id="wholeDataInteractionControls" class="section" style="display: none;">
                        <h3>🔗 Interaction Explorer</h3>
                        <div class="control-group">
                            <label>X Variable:</label>
                            <select id="wholeDataXVariable" onchange="updateWholeDataInteractionPlot()">
                                <option value="">Select X variable...</option>
                            </select>
                            
                            <label>Y Variable:</label>
                            <select id="wholeDataYVariable" onchange="updateWholeDataInteractionPlot()">
                                <option value="">Select Y variable...</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Export Controls -->
                    <div class="section">
                        <h3>📥 Export</h3>
                        <div class="control-group">
                            <label>Format:</label>
                            <select id="wholeDataExportFormat">
                                <option value="png">PNG</option>
                                <option value="svg">SVG</option>
                                <option value="csv">CSV Data</option>
                            </select>
                            <button class="btn" onclick="exportWholeDataPlot()" style="width: 100%; background: #28a745; color: white; border: none; padding: 0.5rem; border-radius: 6px; cursor: pointer;">
                                📥 Export
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="main-content">
                <div id="wholeDataPlotsArea" style="display: none;">
                    <!-- Distribution Plot -->
                    <div id="wholeDataDistributionPlot" class="plot-container">
                        <div class="plot-header">
                            <h3>Distribution Plot</h3>
                            <div id="wholeDataDistributionStats" class="stats-panel"></div>
                        </div>
                        <div id="wholeDataDistributionChart" class="chart-area"></div>
                    </div>
                    
                    <!-- Interaction Plot -->
                    <div id="wholeDataInteractionPlot" class="plot-container" style="display: none;">
                        <div class="plot-header">
                            <h3>Interaction Plot</h3>
                            <div id="wholeDataInteractionStats" class="stats-panel"></div>
                        </div>
                        <div id="wholeDataInteractionChart" class="chart-area"></div>
                    </div>
                </div>
                
                <div id="wholeDataWelcome" class="welcome-message">
                    <div class="welcome-card">
                        <h2>📊 Explore Whole Data</h2>
                        <p>Select an exploration mode and variable to begin analyzing your network data.</p>
                        <div class="feature-grid">
                            <div class="feature-item">
                                <h4>📈 Distribution Explorer</h4>
                                <p>Visualize distributions of individual variables with summary statistics</p>
                            </div>
                            <div class="feature-item">
                                <h4>🔗 Interaction Explorer</h4>
                                <p>Explore relationships between pairs of variables</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
  
    <!-- Child Dashboard Page -->
    <div id="childPage" class="page dashboard-container">
        
            <div class="sidebar" id="sidebar" style="width: 521px;">
            <div class="header">
                <div class="header-title-row">
                    <h1>SNQ Network Plotting Dashboard</h1>
                    <img class="header-logo" alt="CSNQ Logo" src="https://raw.githubusercontent.com/bethanyou/Child-Social-Network-Questionnaire/135c61cc0d8aceadfe725e3a689be35eae3b49d9/logo3-removebg-preview.png" />
                </div>
                <div class="subtitle" onclick="showHelp()" style="cursor: pointer; text-decoration: underline;">Help &amp; Tips</div>
            </div>
            
            <!-- Resize Handle -->
            <div class="sidebar-resize-handle" id="sidebarResizeHandle"></div>
            
            <!-- Toggle Button -->
            <button class="sidebar-toggle-btn" id="sidebarToggleBtn" onclick="toggleSidebar()" title="Toggle Sidebar">
                ◀
            </button>
  
            <div class="sidebar-content">
                <div class="data-chip">
                    Data processed ✓
                </div>
  
                <!-- Workflow Steps -->
                <div class="workflow-step completed" data-step="1" id="step-upload">
                    <div class="step-title">Upload &amp; Process Data</div>
                    <div class="step-content">
                        <p style="color: #666; font-size: 0.9rem; margin: 0;">CSV files loaded and validated</p>
                    </div>
                </div>

                <div class="workflow-step completed" data-step="2" id="step-select">
                    <div class="step-title">Select Child</div>
                    <div class="step-content">
                        <div class="child-selection-card">
                            <div class="child-selection-header" style="margin-bottom: 0.5rem;">
                                <select id="childSelect" onchange="updateChildSelection()" style="width: 100%; padding: 0.875rem; border: 2px solid #e9ecef; border-radius: 8px; font-size: 0.95rem; background: white; transition: border-color 0.2s ease;">
                                    <option value="">Choose a child...</option>
                                    <option value="Testing">Testing</option>
                                    <option value="test">test</option>
                                </select>
                            </div>
                            <div style="margin-top: 1.25rem; padding: 0.75rem; background: #f8f9fa; border-radius: 8px; border: 1px solid #e9ecef;">
                                <label style="display: flex; align-items: center; gap: 8px; margin: 0; cursor: pointer;">
                                    <input type="checkbox" id="confidentialMode" onchange="toggleConfidentialMode()" style="margin: 0;">
                                    <span style="font-weight: 600; color: #2c3e50;">Anonymize Mode</span>
                                </label>
                            </div>
                            <div class="child-preview-stats" id="childPreviewStats" style="display: none;">
                                <div class="stat-item">
                                    <div class="stat-value" id="previewNodes">-</div>
                                    <div class="stat-label">Nodes</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-value" id="previewEdges">-</div>
                                    <div class="stat-label">Connections</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-value" id="previewContexts">-</div>
                                    <div class="stat-label">Contexts</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-value" id="previewActivities">-</div>
                                    <div class="stat-label">Activities</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="workflow-step current" data-step="3" id="step-controls">
                    <div class="step-title">Visualization Controls</div>
                    <div class="step-content">
                        <!-- Display Controls Accordion -->
                        <div class="accordion">
                            <div class="accordion-header" data-accordion="display-accordion">
                                <span>Display Options</span>
                                <span class="accordion-icon">▼</span>
                            </div>
                            <div class="accordion-content" id="display-accordion">
                                <div class="control-group">
                                    <label>Color by:</label>
                                    <select id="colorBySelect" onchange="updateColorBy()">
                                        <option value="context">Context</option>
                                        <option value="language">Language</option>
                                        <option value="race">Race</option>
                                        <option value="gender">Gender</option>
                                        <option value="kin">Kin</option>
                                        <option value="age_categorized">Age Category</option>
                                        <option value="accent">Accent</option>
                                    </select>
                                </div>
                                <div class="control-group">
                                    <label>Size by:</label>
                                    <select id="sizeBySelect" onchange="updateSizeBy()">
                                        <option value="default">No sizing</option>
                                        <option value="closeness">Closeness Score</option>
                                        <option value="closeness_scale">Closeness Scale</option>
                                        <option value="weekly_hours_percent">Weekly Hours (%)</option>
                                        <option value="context_count">Context Count</option>
                                    </select>
                                </div>
                                <div class="control-group">
                                    <label>Layout Style:</label>
                                    <select id="layoutStyleDisplayOptions" onchange="syncLayoutStyle()">
                                        <option value="grouped">Grouped Context Boxes</option>
                                        <option value="component">Component Membership</option>
                                        <option value="traditional">Traditional Network</option>
                                    </select>
                                </div>
                                <div class="control-group">
                                    <label>Context Visibility:</label>
                                    <div id="contextTogglesDisplayOptions" style="display: block;"><div class="checkbox-group">
                    <input type="checkbox" id="context_display_home" checked="" onchange="toggleContext('home', this.checked)">
                    <label for="context_display_home" style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="width: 12px; height: 12px; background: #E74C3C; border-radius: 3px; border: 1px solid #ccc;"></span>
                        Home
                    </label></div><div class="checkbox-group">
                    
                    <input type="checkbox" id="context_display_caregiver" checked="" onchange="toggleContext('caregiver', this.checked)">
                    <label for="context_display_caregiver" style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="width: 12px; height: 12px; background: #27AE60; border-radius: 3px; border: 1px solid #ccc;"></span>
                        Caregiver
                    </label></div><div class="checkbox-group">
                    <input type="checkbox" id="context_display_daycare" checked="" onchange="toggleContext('daycare', this.checked)">
                    <label for="context_display_daycare" style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="width: 12px; height: 12px; background: #16A085; border-radius: 3px; border: 1px solid #ccc;"></span>
                        Daycare
                    </label></div><div class="checkbox-group">
                    <input type="checkbox" id="context_display_extended_family" checked="" onchange="toggleContext('extended_family', this.checked)">
                    <label for="context_display_extended_family" style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="width: 12px; height: 12px; background: #9B59B6; border-radius: 3px; border: 1px solid #ccc;"></span>
                        Extended Family
                    </label></div><div class="checkbox-group">
                    <input type="checkbox" id="context_display_activity" checked="" onchange="toggleContext('activity', this.checked)">
                    <label for="context_display_activity" style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="width: 12px; height: 12px; background: #E74C3C; border-radius: 3px; border: 1px solid #ccc;"></span>
                        Activities
                    </label></div><div class="checkbox-group">
                    <input type="checkbox" id="context_display_anyoneelse" checked="" onchange="toggleContext('anyoneelse', this.checked)">
                    <label for="context_display_anyoneelse" style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="width: 12px; height: 12px; background: #7F8C8D; border-radius: 3px; border: 1px solid #ccc;"></span>
                        Anyone Else
                    </label></div></div>
                                </div>
                                <div class="control-group">
                                    <button class="btn" onclick="resetDisplayOptions()" style="width: 100%; padding: 0.5rem 0.75rem;">Reset Display Options</button>
                                </div>
                            </div>
                        </div>

                        <!-- Filters Accordion -->
                        <div class="accordion">
                            <div class="accordion-header" data-accordion="filters-accordion">
                                <span>Filters</span>
                                <span class="accordion-icon">▼</span>
                            </div>
                            <div class="accordion-content" id="filters-accordion">
                                <div class="filter-category">
                                    <div class="filter-category-header" onclick="toggleFilterCategory('gender')">
                                        <span>Gender</span>
                                        <span class="filter-category-toggle" id="genderToggle">▶</span>
                                    </div>
                                    <div class="filter-category-content" id="genderContent">
                                        <div id="genderFilters" class="checkbox-group-container"><div class="checkbox-group"><input type="checkbox" id="gender_Male" checked="" onchange="toggleDemographicFilter('gender', 'Male')"><label for="gender_Male" style="margin:0; font-size:0.85rem;">Male</label></div><div class="checkbox-group"><input type="checkbox" id="gender_Female" checked="" onchange="toggleDemographicFilter('gender', 'Female')"><label for="gender_Female" style="margin:0; font-size:0.85rem;">Female</label></div></div>
                                    </div>
                                </div>
                                <div class="filter-category">
                                    <div class="filter-category-header" onclick="toggleFilterCategory('race')">
                                        <span>Race</span>
                                        <span class="filter-category-toggle" id="raceToggle">▶</span>
                                    </div>
                                    <div class="filter-category-content" id="raceContent">
                                        <div id="raceFilters" class="checkbox-group-container"><div class="checkbox-group"><input type="checkbox" id="race_Asian" checked="" onchange="toggleDemographicFilter('race', 'Asian')"><label for="race_Asian" style="margin:0; font-size:0.85rem;">Asian</label></div><div class="checkbox-group"><input type="checkbox" id="race_Black" checked="" onchange="toggleDemographicFilter('race', 'Black')"><label for="race_Black" style="margin:0; font-size:0.85rem;">Black</label></div><div class="checkbox-group"><input type="checkbox" id="race_Native/Alaska" checked="" onchange="toggleDemographicFilter('race', 'Native/Alaska')"><label for="race_Native/Alaska" style="margin:0; font-size:0.85rem;">Native/Alaska</label></div></div>
                                    </div>
                                </div>
                                <div class="filter-category">
                                    <div class="filter-category-header" onclick="toggleFilterCategory('language')">
                                        <span>Language</span>
                                        <span class="filter-category-toggle" id="languageToggle">▶</span>
                                    </div>
                                    <div class="filter-category-content" id="languageContent">
                                        <div id="languageFilters" class="checkbox-group-container"><div class="checkbox-group"><input type="checkbox" id="language_English" checked="" onchange="toggleDemographicFilter('language', 'English')"><label for="language_English" style="margin:0; font-size:0.85rem;">English</label></div><div class="checkbox-group"><input type="checkbox" id="language_Pre-verbal/Non-verbal" checked="" onchange="toggleDemographicFilter('language', 'Pre-verbal/Non-verbal')"><label for="language_Pre-verbal/Non-verbal" style="margin:0; font-size:0.85rem;">Pre-verbal/Non-verbal</label></div><div class="checkbox-group"><input type="checkbox" id="language_chinese (mandarin)" checked="" onchange="toggleDemographicFilter('language', 'chinese (mandarin)')"><label for="language_chinese (mandarin)" style="margin:0; font-size:0.85rem;">chinese (mandarin)</label></div></div>
                                    </div>
                                </div>
                                <div class="filter-category">
                                    <div class="filter-category-header" onclick="toggleFilterCategory('kin')">
                                        <span>Kin</span>
                                        <span class="filter-category-toggle" id="kinToggle">▶</span>
                                    </div>
                                    <div class="filter-category-content" id="kinContent">
                                        <div id="kinFilters" class="checkbox-group-container"><div class="checkbox-group"><input type="checkbox" id="kin_No" checked="" onchange="toggleDemographicFilter('kin', 'No')"><label for="kin_No" style="margin:0; font-size:0.85rem;">No</label></div><div class="checkbox-group"><input type="checkbox" id="kin_Yes" checked="" onchange="toggleDemographicFilter('kin', 'Yes')"><label for="kin_Yes" style="margin:0; font-size:0.85rem;">Yes</label></div></div>
                                    </div>
                                </div>
                                <div class="filter-category">
                                    <div class="filter-category-header" onclick="toggleFilterCategory('accent')">
                                        <span>Accent</span>
                                        <span class="filter-category-toggle" id="accentToggle">▶</span>
                                    </div>
                                    <div class="filter-category-content" id="accentContent">
                                        <div id="accentFilters" class="checkbox-group-container"></div>
                                    </div>
                                </div>
                                <div class="filter-category">
                                    <div class="filter-category-header" onclick="toggleFilterCategory('contactMode')">
                                        <span>Mode of Contact</span>
                                        <span class="filter-category-toggle" id="contactModeToggle">▶</span>
                                    </div>
                                    <div class="filter-category-content" id="contactModeContent">
                                        <div id="contactModeFilters" class="checkbox-group-container"><div class="checkbox-group"><input type="checkbox" id="contactMode_In-person only" checked="" onchange="toggleDemographicFilter('contactMode', 'In-person only')"><label for="contactMode_In-person only" style="margin:0; font-size:0.85rem;">In-person only</label></div></div>
                                    </div>
                                </div>
                                <div class="filter-category">
                                    <div class="filter-category-header" onclick="toggleFilterCategory('ageCategory')">
                                        <span>Age Category</span>
                                        <span class="filter-category-toggle" id="ageCategoryToggle">▶</span>
                                    </div>
                                    <div class="filter-category-content" id="ageCategoryContent">
                                        <div id="ageCategoryFilters" class="checkbox-group-container"><div class="checkbox-group"><input type="checkbox" id="ageCategory_6-12 years old" checked="" onchange="toggleDemographicFilter('ageCategory', '6-12 years old')"><label for="ageCategory_6-12 years old" style="margin:0; font-size:0.85rem;">6-12 years old</label></div><div class="checkbox-group"><input type="checkbox" id="ageCategory_18 years old or older" checked="" onchange="toggleDemographicFilter('ageCategory', '18 years old or older')"><label for="ageCategory_18 years old or older" style="margin:0; font-size:0.85rem;">18 years old or older</label></div></div>
                                    </div>
                                </div>
                                <div class="filter-category">
                                    <div class="filter-category-header" onclick="toggleFilterCategory('weeklyHoursBucket')">
                                        <span>Weekly Hours (%)</span>
                                        <span class="filter-category-toggle" id="weeklyHoursBucketToggle">▶</span>
                                    </div>
                                    <div class="filter-category-content" id="weeklyHoursBucketContent">
                                        <div id="weeklyHoursBucketFilters" class="checkbox-group-container"></div>
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label>Weekly Hours (%) Range: <small style="color: #666; font-weight: normal;">(Format: 0.00-1.00)</small></label>
                                    <div style="display: flex; align-items: center; gap: 8px; margin-top: 4px;">
                                        <input type="number" id="weeklyHoursMin" min="0" max="1" step="0.01" value="0" style="flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;" onchange="updateWeeklyHoursRange()" placeholder="0.00">
                                        <span>to</span>
                                        <input type="number" id="weeklyHoursMax" min="0" max="1" step="0.01" value="1" style="flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;" onchange="updateWeeklyHoursRange()" placeholder="1.00">
                                    </div>
                                </div>
                                <div class="control-group">
                                    <label>Closeness Score</label>
                                    <div id="closenessScoreFilters" class="checkbox-group-container"></div>
                                </div>
                                <div class="control-group">
                                    <label>Closeness Scale</label>
                                    <div id="closenessScaleFilters" class="checkbox-group-container"></div>
                                </div>
                                <div class="control-group">
                                    <button class="btn" onclick="resetFilters()" style="width: 100%; padding: 0.5rem 0.75rem;">Reset Filters</button>
                                </div>
                            </div>
                        </div>

                        <!-- Stats Accordion -->
                        <div class="accordion">
                            <div class="accordion-header" data-accordion="stats-accordion">
                                <span>Network Statistics</span>
                                <span class="accordion-icon">▼</span>
                            </div>
                            <div class="accordion-content" id="stats-accordion">
                                <div id="networkStatsContent">
                    <div style="font-size: 0.9rem; line-height: 1.5; display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                        <div title="Person who completed the survey"><strong>Survey Respondent:</strong> Liveathome1_Mom</div>
                        <div title="Total number of nodes in network"><strong>Size:</strong> 7</div>
                        <div title="Network density: edges / possible edges"><strong>Density:</strong> 0.952</div>
                        <div title="Number of connections between nodes"><strong>Edges:</strong> 20</div>
                        <div title="Number of disconnected network components"><strong>Components:</strong> 3</div>
                        <div title="Network fragmentation measure"><strong>Component Ratio:</strong> 0.333</div>
                        <div title="Percentage of adult relationships"><strong>% Adult:</strong> 71.0%</div>
                        <div title="Percentage of kin relationships"><strong>% Kin:</strong> 57.0%</div>
                        <div title="Shannon entropy of racial diversity"><strong>Race Entropy:</strong> 1.84</div>
                        <div title="Racial homophily index"><strong>Racial EI:</strong> -0.14</div>
                        <div title="Shannon entropy of language diversity"><strong>Language Entropy:</strong> 0.72</div>
                        <div title="Language homophily index"><strong>Linguistic EI:</strong> -0.60</div>
                    </div>
                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="workflow-step pending" data-step="4" id="step-export">
                    <div class="step-title">Export / Screenshot</div>
                    <div class="step-content">
                        <div class="export-dropdown">
                            <select id="exportFormat">
                                <option value="png">PNG Image</option>
                                <option value="csv">CSV Data</option>
                            </select>
                        </div>
                        <div class="export-buttons">
                            <button class="btn" onclick="exportNetwork()" style="padding: 0.75rem 1rem; margin-bottom: 0.5rem; width: 100%;">
                                Export Graph
                            </button>
                            <button class="btn" onclick="exportAllChildren()" style="padding: 0.75rem 1rem; background: transparent; color: #007bff; border: 1px solid #007bff; width: 100%;">
                                Export All
                            </button>
                        </div>
                    </div>
                </div>

                <div class="workflow-step overview" data-step="5" id="step-overview">
                    <div class="step-title">Overview Data</div>
                    <div class="step-content">
                        <div class="export-dropdown" style="margin-bottom: 0.5rem;">
                            <select id="overviewMetric">
                                <option value="network_size">Network Size</option>
                                <option value="network_density">Network Density</option>
                                <option value="network_component_count">Component Count</option>
                                <option value="network_component_ratio">Component Ratio</option>
                                <option value="network_prop_adult_relationship">% Adult Nodes</option>
                                <option value="network_prop_kin_relationship">% Kin Nodes</option>
                                <option value="network_edges_number">Edges</option>
                                <option value="network_racial_entropy">Race Entropy</option>
                                <option value="network_racial_ei_index">Racial EI</option>
                                <option value="network_language_entropy">Language Entropy</option>
                                <option value="network_linguistic_ei_index">Linguistic EI</option>
                            </select>
                        </div>
                        <button class="btn" onclick="showAllChildrenOverview()" style="padding: 0.75rem 1rem; width: 100%;">
                            Show Overview Plot
                        </button>
                    </div>
                </div>

  
  
                <div class="section sidebar-section" id="display-controls" style="display: none;">
                    <h3>Display Controls</h3>
                    
                    <div class="control-group">
                        <label>Layout Style:</label>
                        <select id="layoutStyle" onchange="changeLayoutStyle()">
                            <option value="grouped">Grouped Context Boxes</option>
                            <option value="component">Component Membership</option>
                            <option value="traditional">Traditional Network</option>
                        </select>
                    </div>
  
                    <div class="control-group">
                        <label>Edge Visibility:</label>
                        <select id="edgeVisibility" onchange="updateEdgeVisibility()">
                            <option value="all">All ties (default)</option>
                            <option value="ego-only">Only ego→node</option>
                            <option value="selected-only">Only selected node ties</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <button class="btn" onclick="toggleSelectionView()" style="width: 100%; background: #42a5f5; color: white; border: none; padding: 0.5rem; border-radius: 6px; cursor: pointer; margin-bottom: 0.5rem;">
                            🔍 Toggle Selection View
                        </button>
                        <small style="color: #6c757d; font-size: 0.8rem;">Quick toggle between all edges and selected node edges</small>
                    </div>
  
                    <div class="control-group">
                        <label>Search Nodes:</label>
                        <input type="text" id="nodeSearch" placeholder="Search by name..." oninput="searchNodes()" style="width: 100%; padding: 0.5rem; border: 1px solid #ced4da; border-radius: 6px;">
                    </div>
                    
  
  
                    <div class="control-group">
                        <label>Context Visibility:</label>
                        <div id="contextToggles" style="display: block;"><div class="checkbox-group">
                    <input type="checkbox" id="context_home" checked="" onchange="toggleContext('home', this.checked)">
                    <label for="context_home" style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="width: 12px; height: 12px; background: #E74C3C; border-radius: 3px; border: 1px solid #ccc;"></span>
                        Home
                    </label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="context_caregiver" checked="" onchange="toggleContext('caregiver', this.checked)">
                    <label for="context_caregiver" style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="width: 12px; height: 12px; background: #27AE60; border-radius: 3px; border: 1px solid #ccc;"></span>
                        Caregiver
                    </label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="context_daycare" checked="" onchange="toggleContext('daycare', this.checked)">
                    <label for="context_daycare" style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="width: 12px; height: 12px; background: #16A085; border-radius: 3px; border: 1px solid #ccc;"></span>
                        Daycare
                    </label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="context_extended_family" checked="" onchange="toggleContext('extended_family', this.checked)">
                    <label for="context_extended_family" style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="width: 12px; height: 12px; background: #9B59B6; border-radius: 3px; border: 1px solid #ccc;"></span>
                        Extended Family
                    </label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="context_activity" checked="" onchange="toggleContext('activity', this.checked)">
                    <label for="context_activity" style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="width: 12px; height: 12px; background: #E74C3C; border-radius: 3px; border: 1px solid #ccc;"></span>
                        Activities
                    </label>
                </div><div class="checkbox-group">
                    <input type="checkbox" id="context_anyoneelse" checked="" onchange="toggleContext('anyoneelse', this.checked)">
                    <label for="context_anyoneelse" style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="width: 12px; height: 12px; background: #7F8C8D; border-radius: 3px; border: 1px solid #ccc;"></span>
                        Anyone Else
                    </label>
                </div></div>
                    </div>
  
                    <div class="control-group">
                        <label>Color by:</label>
                        <select id="colorBy" onchange="updateColorByMain()">
                            <option value="context">Context</option>
                            <option value="gender">Gender</option>
                            <option value="race">Race</option>
                            <option value="language">Language</option>
                            <option value="kin">Kin</option>
                            <option value="accent">Accent</option>
                        </select>
                    </div>
  
                    <div class="control-group">
                        <label>Node Size:</label>
                        <select id="nodeSizeBy" onchange="updateSizeByMain()">
                            <option value="default">Default</option>
                            <option value="weekly_hours">Weekly Hours</option>
                            <option value="closeness">Closeness Score</option>
                            <option value="closeness_scale">Closeness Scale</option>
                            <option value="closeness_intensity_z">Closeness Intensity Z-Score</option>
                        </select>
                    </div>
                </div>
  
                <div class="section sidebar-section" id="network-stats" style="display: none;">
                    <h3>Network Statistics</h3>
                    <div id="networkStatsContent">
                    <div style="font-size: 0.9rem; line-height: 1.5; display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                        <div title="Total number of nodes in network"><strong>Size:</strong> 14</div>
                        <div title="Network density: edges / possible edges"><strong>Density:</strong> 0.290</div>
                        <div title="Number of connections between nodes"><strong>Edges:</strong> 61</div>
                        <div title="Number of disconnected network components"><strong>Components:</strong> 3</div>
                        <div title="Network fragmentation measure"><strong>Component Ratio:</strong> 0.154</div>
                        <div title="Percentage of adult relationships"><strong>% Adult:</strong> 57.0%</div>
                        <div title="Percentage of kin relationships"><strong>% Kin:</strong> 50.0%</div>
                        <div title="Shannon entropy of racial diversity"><strong>Race Entropy:</strong> 2.47</div>
                        <div title="Racial homophily index"><strong>Racial EI:</strong> 0.14</div>
                        <div title="Shannon entropy of language diversity"><strong>Language Entropy:</strong> 1.66</div>
                        <div title="Language homophily index"><strong>Linguistic EI:</strong> -0.33</div>
                    </div>
                </div>
                </div>
                
                <div class="section sidebar-section" id="filters" style="display: none;">
                    <h3>Filters</h3>
                    <div class="filter-category">
                        <div class="filter-category-header" onclick="toggleFilterCategory('gender')">
                            <span>Gender</span>
                            <span class="filter-category-toggle" id="genderToggle">▶</span>
                    </div>
                        <div class="filter-category-content" id="genderContent">
                            <div id="genderFilters" class="checkbox-group-container"></div>
                    </div>
                    </div>
                    <div class="filter-category">
                        <div class="filter-category-header" onclick="toggleFilterCategory('race')">
                            <span>Race</span>
                            <span class="filter-category-toggle" id="raceToggle">▶</span>
                    </div>
                        <div class="filter-category-content" id="raceContent">
                            <div id="raceFilters" class="checkbox-group-container"></div>
                    </div>
                    </div>
                    <div class="filter-category">
                        <div class="filter-category-header" onclick="toggleFilterCategory('language')">
                            <span>Language</span>
                            <span class="filter-category-toggle" id="languageToggle">▶</span>
                    </div>
                        <div class="filter-category-content" id="languageContent">
                            <div id="languageFilters" class="checkbox-group-container"></div>
                        </div>
                    </div>
                    <div class="filter-category">
                        <div class="filter-category-header" onclick="toggleFilterCategory('kin')">
                            <span>Kin</span>
                            <span class="filter-category-toggle" id="kinToggle">▶</span>
                        </div>
                        <div class="filter-category-content" id="kinContent">
                            <div id="kinFilters" class="checkbox-group-container"></div>
                        </div>
                    </div>
                    <div class="filter-category">
                        <div class="filter-category-header" onclick="toggleFilterCategory('accent')">
                            <span>Accent</span>
                            <span class="filter-category-toggle" id="accentToggle">▶</span>
                        </div>
                        <div class="filter-category-content" id="accentContent">
                            <div id="accentFilters" class="checkbox-group-container"></div>
                        </div>
                    </div>
                    <div class="filter-category">
                        <div class="filter-category-header" onclick="toggleFilterCategory('contactMode')">
                            <span>Mode of Contact</span>
                            <span class="filter-category-toggle" id="contactModeToggle">▶</span>
                        </div>
                        <div class="filter-category-content" id="contactModeContent">
                            <div id="contactModeFilters" class="checkbox-group-container"></div>
                        </div>
                    </div>
                    <div class="filter-category">
                        <div class="filter-category-header" onclick="toggleFilterCategory('ageCategory')">
                            <span>Age Category</span>
                            <span class="filter-category-toggle" id="ageCategoryToggle">▶</span>
                        </div>
                        <div class="filter-category-content" id="ageCategoryContent">
                            <div id="ageCategoryFilters" class="checkbox-group-container"></div>
                        </div>
                    </div>
  
                    <div class="control-group">
                        <label>Weekly Hours (%) Range: <small style="color: #666; font-weight: normal;">(Format: 0.00-1.00)</small></label>
                        <div style="display: flex; align-items: center; gap: 8px; margin-top: 4px;">
                            <input type="number" id="weeklyHoursMinDisplay" min="0" max="1" step="0.01" value="0" style="flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;" onchange="updateWeeklyHoursRangeDisplay()" placeholder="0.00">
                            <span>to</span>
                            <input type="number" id="weeklyHoursMaxDisplay" min="0" max="1" step="0.01" value="1" style="flex: 1; padding: 0.5rem; border: 1px solid #ddd; border-radius: 4px;" onchange="updateWeeklyHoursRangeDisplay()" placeholder="1.00">
                        </div>
                    </div>
                    <div class="filter-category">
                        <div class="filter-category-header" onclick="toggleFilterCategory('weeklyHoursBucket')">
                            <span>Weekly Hours (%)</span>
                            <span class="filter-category-toggle" id="weeklyHoursBucketToggleDisplay">▶</span>
                        </div>
                        <div class="filter-category-content" id="weeklyHoursBucketContentDisplay">
                            <div id="weeklyHoursBucketFiltersDisplay" class="checkbox-group-container"></div>
                        </div>
                    </div>
  
                    <div class="control-group">
                        <label>Closeness Score</label>
                        <div id="closenessScoreFiltersDisplay" class="checkbox-group-container"></div>
                    </div>
                    <div class="control-group">
                        <label>Closeness Scale</label>
                        <div id="closenessScaleFiltersDisplay" class="checkbox-group-container"></div>
                    </div>
                </div>
  
                <div class="section sidebar-section" id="network-stats" style="display: none;">
                    <h3>Network Statistics</h3>
                    <div id="networkStatsContent">
                        <div style="color: #6c757d; font-style: italic; text-align: center; padding: 2rem;">
                            Select a child to view network statistics
                        </div>
                    </div>
                </div>
  
  
  

  
                <div class="section" id="nodeDetailsSection" style="display: none;">
                    <h3>Node Details</h3>
                    <div id="nodeDetailsContent"></div>
                </div>
            </div>
        </div>
  
        <div class="main-content">
            <!-- Fixed details panel for alter/context details -->
            <div id="fixedDetailsPanel" class="fixed-details-panel" style="display: none;">
                <button class="close-panel" onclick="closeFixedDetails()">×</button>
                <h3 id="fixedDetailsTitle">Selected Alter</h3>
                <div id="fixedDetailsContent">
                <div class="info-row">
                    <span class="info-label">Name:</span>
                    <span class="info-value">Amy</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Role/Relationship:</span>
                    <span class="info-value">Teacher</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Gender:</span>
                    <span class="info-value">Female</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Age:</span>
                    <span class="info-value">18 years old or older</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Race:</span>
                    <span class="info-value">Asian,Black or African-American</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Language:</span>
                    <span class="info-value">English; Thai</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Kin:</span>
                    <span class="info-value">No</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Mode of Contact:</span>
                    <span class="info-value">In-person only</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Contact Context:</span>
                    <span class="info-value">Daycare/School</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Weekly Hours:</span>
                    <span class="info-value">36</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Hours % of week:</span>
                    <span class="info-value">21.4%</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Closeness Score:</span>
                    <span class="info-value">3</span>
                </div>
                
                    <div style="margin-top: 1rem; border-top: 1px solid #e9ecef; padding-top: 1rem;">
                        <div style="font-weight: 600; margin-bottom: 0.5rem; color: #495057;">Connected To (3):</div>
                        <div style="font-size: 0.85rem; line-height: 1.4;">
                            Molly, Willy, Tom
                        </div>
                    </div>
                
            </div>
            </div>
  
            <!-- Welcome Message -->
            <div id="welcomeMessage" style="display: none; text-align: center; padding: 3rem; color: rgb(108, 117, 125);">
                <h2 style="margin-bottom: 1rem; color: #495057;">Welcome to Network Visualization</h2>
                <p style="font-size: 1.1rem; margin-bottom: 2rem;">
                    Select a child from the dropdown and click "Visualize Network" to see their social network.
                </p>
                <div style="background: #f8f9fa; padding: 2rem; border-radius: 12px; max-width: 600px; margin: 0 auto;">
                    <h3 style="color: #42a5f5; margin-bottom: 1rem;">📊 What You'll See:</h3>
                    <ul style="text-align: left; line-height: 1.6;">
                        <li><strong>Social Network Map:</strong> Visual representation of the child's connections</li>
                        <li><strong>Context Groups:</strong> People organized by where they interact (home, daycare, activities)</li>
                        <li><strong>Interactive Elements:</strong> Click on people and boxes to explore details</li>
                        <li><strong>Customizable View:</strong> Change colors, sizes, and filters to explore different aspects</li>
                    </ul>
                </div>
            </div>
            
            <svg class="network-svg" id="networkSvg" style="display: block;" width="2040" height="1000"><g class="main-container"><g class="background-layer"><g class="context-box clickable" data-context-key="activity_1_Playground" style="cursor: move;"><rect x="933.75" y="10" width="172.5" height="180" rx="12" ry="12" style="fill: rgb(26, 188, 156); stroke: rgb(73, 80, 87); stroke-width: 2; stroke-dasharray: 5, 5; opacity: 0.8;"></rect><text x="1020" y="30" style="text-anchor: middle; font-size: 14px; font-weight: bold; fill: rgb(44, 62, 80);">Activity 1: Playground</text><g class="alter-node" style="cursor: pointer;"><circle cx="1020" cy="126.25" r="35" style="fill: white; stroke: rgb(26, 188, 156); stroke-width: 3;"></circle><text x="1020" y="126.25" style="text-anchor: middle; dominant-baseline: middle; font-size: 13px; font-weight: 600; fill: rgb(44, 62, 80); pointer-events: auto; cursor: pointer; text-shadow: rgba(255, 255, 255, 0.8) 0px 0px 3px;">Pete</text></g></g><g class="context-box" data-context-key="caregiver" style="cursor: move;"><rect x="1314.1726065180615" y="286.39320225002103" width="172.5" height="180" rx="12" ry="12" style="fill: rgb(39, 174, 96); stroke: none; stroke-width: 0; stroke-dasharray: none; opacity: 0.8;"></rect><text x="1400.4226065180615" y="306.39320225002103" style="text-anchor: middle; font-size: 14px; font-weight: bold; fill: rgb(44, 62, 80);">Caregiver</text><g class="alter-node" style="cursor: pointer;"><circle cx="1400.4226065180615" cy="402.64320225002103" r="35" style="fill: white; stroke: rgb(39, 174, 96); stroke-width: 3;"></circle><text x="1400.4226065180615" y="402.64320225002103" style="text-anchor: middle; dominant-baseline: middle; font-size: 13px; font-weight: 600; fill: rgb(44, 62, 80); pointer-events: auto; cursor: pointer; text-shadow: rgba(255, 255, 255, 0.8) 0px 0px 3px;">She</text></g></g><g class="context-box" data-context-key="home" style="cursor: move;"><rect x="1130.1141009169892" y="733.606797749979" width="250" height="180" rx="12" ry="12" style="fill: rgb(231, 76, 60); stroke: none; stroke-width: 0; stroke-dasharray: none; opacity: 0.8;"></rect><text x="1255.1141009169892" y="753.606797749979" style="text-anchor: middle; font-size: 14px; font-weight: bold; fill: rgb(44, 62, 80);">Home</text><g class="alter-node" style="cursor: pointer;"><circle cx="1216.3641009169892" cy="849.856797749979" r="35" style="fill: white; stroke: rgb(231, 76, 60); stroke-width: 3;"></circle><text x="1216.3641009169892" y="849.856797749979" style="text-anchor: middle; dominant-baseline: middle; font-size: 13px; font-weight: 600; fill: rgb(44, 62, 80); pointer-events: auto; cursor: pointer; text-shadow: rgba(255, 255, 255, 0.8) 0px 0px 3px;">Mom</text></g><g class="alter-node" style="cursor: pointer;"><circle cx="1328.8641009169892" cy="849.856797749979" r="35" style="fill: white; stroke: rgb(231, 76, 60); stroke-width: 3;"></circle><text x="1328.8641009169892" y="849.856797749979" style="text-anchor: middle; dominant-baseline: middle; font-size: 13px; font-weight: 600; fill: rgb(44, 62, 80); pointer-events: auto; cursor: pointer; text-shadow: rgba(255, 255, 255, 0.8) 0px 0px 3px;">Dad</text></g></g><g class="context-box clickable" data-context-key="daycare" style="cursor: move;"><rect x="659.8858990830108" y="733.606797749979" width="250" height="180" rx="12" ry="12" style="fill: rgb(22, 160, 133); stroke: rgb(73, 80, 87); stroke-width: 2; stroke-dasharray: 5, 5; opacity: 0.8;"></rect><text x="784.8858990830108" y="753.606797749979" style="text-anchor: middle; font-size: 14px; font-weight: bold; fill: rgb(44, 62, 80);">Daycare</text><g class="alter-node" style="cursor: pointer;"><circle cx="746.1358990830108" cy="849.856797749979" r="35" style="fill: white; stroke: rgb(22, 160, 133); stroke-width: 3;"></circle><text x="746.1358990830108" y="849.856797749979" style="text-anchor: middle; dominant-baseline: middle; font-size: 13px; font-weight: 600; fill: rgb(44, 62, 80); pointer-events: auto; cursor: pointer; text-shadow: rgba(255, 255, 255, 0.8) 0px 0px 3px;">T</text></g><g class="alter-node" style="cursor: pointer;"><circle cx="858.6358990830108" cy="849.856797749979" r="35" style="fill: white; stroke: rgb(22, 160, 133); stroke-width: 3;"></circle><text x="858.6358990830108" y="849.856797749979" style="text-anchor: middle; dominant-baseline: middle; font-size: 13px; font-weight: 600; fill: rgb(44, 62, 80); pointer-events: auto; cursor: pointer; text-shadow: rgba(255, 255, 255, 0.8) 0px 0px 3px;">He</text></g></g><g class="context-box" data-context-key="sibling" style="cursor: move;"><rect x="553.3273934819385" y="286.3932022500211" width="172.5" height="180" rx="12" ry="12" style="fill: rgb(243, 156, 18); stroke: none; stroke-width: 0; stroke-dasharray: none; opacity: 0.8;"></rect><text x="639.5773934819385" y="306.3932022500211" style="text-anchor: middle; font-size: 14px; font-weight: bold; fill: rgb(44, 62, 80);">Siblings</text><g class="alter-node" style="cursor: pointer;"><circle cx="639.5773934819385" cy="402.6432022500211" r="35" style="fill: white; stroke: rgb(243, 156, 18); stroke-width: 3;"></circle><text x="639.5773934819385" y="402.6432022500211" style="text-anchor: middle; dominant-baseline: middle; font-size: 13px; font-weight: 600; fill: rgb(44, 62, 80); pointer-events: auto; cursor: pointer; text-shadow: rgba(255, 255, 255, 0.8) 0px 0px 3px;">Niu</text></g></g></g><g class="edges-layer"><line class="alter-edge" x1="990.066371208127" y1="147.99805433482152" x2="669.5110222738116" y2="380.8951479151996" data-source="act1adult1_pete" data-target="sibling1_niu" style="stroke: rgb(74, 85, 104); stroke-width: 1.5px; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1029.6901759257214" y1="161.95854926384672" x2="1206.6739249912678" y2="814.1482484861323" data-source="act1adult1_pete" data-target="liveathome1_mom" style="stroke: rgb(74, 85, 104); stroke-width: 1.5px; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1034.5252123165078" y1="160.27966657433439" x2="1314.3388886004814" y2="815.8271311756446" data-source="act1adult1_pete" data-target="liveathome2_dad" style="stroke: rgb(74, 85, 104); stroke-width: 1.5px; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1011.9468194067141" y1="162.36296557099573" x2="866.6890796762967" y2="813.7438321789833" data-source="act1adult1_pete" data-target="teacher1_he" style="stroke: rgb(74, 85, 104); stroke-width: 1.5px; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1006.9031923772376" y1="160.85453192997056" x2="759.2327067057732" y2="815.2522658200085" data-source="act1adult1_pete" data-target="schoolkid1_t" style="stroke: rgb(74, 85, 104); stroke-width: 1.5px; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1049.9336287918732" y1="147.99805433482152" x2="1370.4889777261883" y2="380.8951479151995" data-source="act1adult1_pete" data-target="caregiver1_she" style="stroke: rgb(74, 85, 104); stroke-width: 1.5px; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1363.4226065180615" y1="402.64320225002103" x2="676.5773934819385" y2="402.6432022500211" data-source="caregiver1_she" data-target="sibling1_niu" style="stroke: rgb(74, 85, 104); stroke-width: 1.5px; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1386.3406381918305" y1="436.8586690458873" x2="1230.44606924322" y2="815.6413309541127" data-source="caregiver1_she" data-target="liveathome1_mom" style="stroke: rgb(74, 85, 104); stroke-width: 1.5px; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1394.5766130408763" y1="439.178450439471" x2="1334.7100943941743" y2="813.3215495605291" data-source="caregiver1_she" data-target="liveathome2_dad" style="stroke: rgb(74, 85, 104); stroke-width: 1.5px; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1371.8879898188536" y1="426.1968781803145" x2="887.1705157822187" y2="826.3031218196855" data-source="caregiver1_she" data-target="teacher1_he" style="stroke: rgb(74, 85, 104); stroke-width: 1.5px; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1369.8763142308153" y1="423.5219959772008" x2="776.6821913702571" y2="828.9780040227993" data-source="caregiver1_she" data-target="schoolkid1_t" style="stroke: rgb(74, 85, 104); stroke-width: 1.5px; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1187.123749546365" y1="827.185188814519" x2="668.8177448525629" y2="425.31481118548106" data-source="liveathome1_mom" data-target="sibling1_niu" style="stroke: rgb(74, 85, 104); stroke-width: 1.5px; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><path class="alter-edge" d="M 1253.3641009169892 849.856797749979 Q 1272.6141009169892 857.5567977499791 1291.8641009169892 849.856797749979" data-source="liveathome1_mom" data-target="liveathome2_dad" style="stroke: rgb(74, 85, 104); stroke-width: 1.5px; stroke-linecap: round; opacity: 0.35; fill: none; pointer-events: auto;"></path><line class="alter-edge" x1="1179.3641009169892" y1="849.856797749979" x2="895.6358990830108" y2="849.856797749979" data-source="liveathome1_mom" data-target="teacher1_he" style="stroke: rgb(74, 85, 104); stroke-width: 1.5px; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1179.3641009169892" y1="849.856797749979" x2="783.1358990830108" y2="849.856797749979" data-source="liveathome1_mom" data-target="schoolkid1_t" style="stroke: rgb(74, 85, 104); stroke-width: 1.5px; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1297.8247683574157" y1="829.7182815619328" x2="670.616726041512" y2="422.78171843806723" data-source="liveathome2_dad" data-target="sibling1_niu" style="stroke: rgb(74, 85, 104); stroke-width: 1.5px; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1291.8641009169892" y1="849.856797749979" x2="895.6358990830108" y2="849.856797749979" data-source="liveathome2_dad" data-target="teacher1_he" style="stroke: rgb(74, 85, 104); stroke-width: 1.5px; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><line class="alter-edge" x1="1291.8641009169892" y1="849.856797749979" x2="783.1358990830108" y2="849.856797749979" data-source="liveathome2_dad" data-target="schoolkid1_t" style="stroke: rgb(74, 85, 104); stroke-width: 1.5px; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line><path class="alter-edge" d="M 783.1358990830108 849.856797749979 Q 802.3858990830108 857.5567977499791 821.6358990830108 849.856797749979" data-source="schoolkid1_t" data-target="teacher1_he" style="stroke: rgb(74, 85, 104); stroke-width: 1.5px; stroke-linecap: round; opacity: 0.35; fill: none; pointer-events: auto;"></path><line class="alter-edge" x1="655.8533946468258" y1="435.8710788911877" x2="842.3598979181236" y2="816.6289211088124" data-source="sibling1_niu" data-target="teacher1_he" style="stroke: rgb(74, 85, 104); stroke-width: 1.5px; stroke-linecap: round; opacity: 0.35; pointer-events: auto;"></line></g><g class="nodes-layer"><g class="ego-node" style="cursor: pointer;"><rect x="990" y="470" width="60" height="60" rx="9" ry="9" style="fill: rgb(44, 123, 229); stroke: white; stroke-width: 3;"></rect><text x="1020" y="500" style="text-anchor: middle; dominant-baseline: middle; font-size: 12px; font-weight: bold; fill: white; pointer-events: none;">test</text></g></g></g></svg>
  
            <div class="legend" id="legend" style="display: block;">
                <div class="legend-section" id="colorLegendSection">
                    <h4 id="colorLegendTitle">Color by: Context</h4>
                    <div id="colorLegendItems"><div class="legend-item">
                        <div class="legend-color" style="background: #E74C3C;"></div>
                        <span>Home</span>
                    </div><div class="legend-item">
                        <div class="legend-color" style="background: #F39C12;"></div>
                        
                    </div><div class="legend-item">
                        <div class="legend-color" style="background: #27AE60;"></div>
                        <span>Caregiver</span>
                    </div><div class="legend-item">
                        <div class="legend-color" style="background: #16A085;"></div>
                        <span>Daycare</span>
                    </div><div class="legend-item">
                        <div class="legend-color" style="background: #1ABC9C;"></div>
                        <span>Activity 1: Playground</span>
                    </div></div>
                </div>
                <div class="legend-section" id="sizeLegendSection" style="display: none;">
                    <h4 id="sizeLegendTitle">Node Size: Weekly Hours</h4>
                    <div id="sizeLegendItems">
                        <div class="size-legend-item">
                            <div class="size-circle" style="width: 25px; height: 25px;"></div>
                            <span>≤4h</span>
                        </div>
                    
                        <div class="size-legend-item">
                            <div class="size-circle" style="width: 30px; height: 30px;"></div>
                            <span>4.1-5h</span>
                        </div>
                    
                        <div class="size-legend-item">
                            <div class="size-circle" style="width: 35px; height: 35px;"></div>
                            <span>5.1-30h</span>
                        </div>
                    
                        <div class="size-legend-item">
                            <div class="size-circle" style="width: 40px; height: 40px;"></div>
                            <span>30.1-60h</span>
                        </div>
                    
                        <div class="size-legend-item">
                            <div class="size-circle" style="width: 45px; height: 45px;"></div>
                            <span>&gt;60h</span>
                        </div>
                    </div>
                </div>
                <div class="legend-section" id="edgeLegendSection" style="display: none;">
                    <h4>Edge Key</h4>
                    <div class="legend-item">
                        <div style="width: 20px; height: 2px; background: #9CA3AF; border-radius: 1px;"></div>
                        <span style="font-size: 0.8rem;">Default</span>
                    </div>
                    <div class="legend-item">
                        <div style="width: 20px; height: 2px; background: #F97316; border-radius: 1px;"></div>
                        <span style="font-size: 0.8rem;">Selected</span>
                    </div>
                </div>
            </div>
  
            <!-- Information Panels -->
            <div id="contextPanel" class="info-panel" style="display: none;">
                <button class="close-panel" onclick="closePanel('contextPanel')">×</button>
                <h3 id="contextTitle">Context Information</h3>
                <div id="contextContent"></div>
            </div>
  
            <div id="nodePanel" class="info-panel" style="display: none;">
                <button class="close-panel" onclick="closePanel('nodePanel')">×</button>
                <h3>Node Information</h3>
                <div id="nodeContent"></div>
            </div>
  
            <!-- Ego panel removed - child information now in sidebar -->
  
            <!-- Unified details panel for both nodes and contexts -->
            <div id="unifiedDetailsCard" class="floating-card" style="display: none;">
                <button class="close-panel" onclick="closeUnifiedDetails()">×</button>
                <h3 id="unifiedDetailsTitle">Details</h3>
                <div id="unifiedDetailsContent"></div>
            </div>

            <!-- Export Preview Modal -->
            <div id="exportPreviewModal" class="modal" style="display: none;">
                <div class="modal-content" style="max-width: 90vw; max-height: 90vh; width: auto; height: auto;">
                    <div class="modal-header">
                        <h3>Export Preview</h3>
                        <button class="close-panel" onclick="closeExportPreview()">×</button>
                    </div>
                    <div class="modal-body" style="text-align: center; padding: 1rem;">
                        <div id="previewImageContainer" style="max-width: 100%; max-height: 70vh; overflow: auto; border: 1px solid #ddd; border-radius: 8px; background: white;">
                            <img id="previewImage" style="max-width: 100%; height: auto;" />
                        </div>
                        <div style="margin-top: 1rem;">
                            <button class="btn" onclick="downloadPreview()" style="background: #28a745; color: white; margin-right: 1rem;">
                                Download PNG
                            </button>
                            <button class="btn" onclick="closeExportPreview()" style="background: #6c757d; color: white;">
                                Cancel
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- All Children Scatter Modal -->
            <div id="allChildrenScatterModal" class="modal" style="display: none;">
                <div class="modal-content" style="max-width: 90vw; max-height: 90vh; width: auto; height: auto;">
                    <div class="modal-header">
                        <h3 id="allChildrenScatterTitle">All Children: Network Size</h3>
                        <button class="close-panel" onclick="closeAllChildrenScatter()">×</button>
                    </div>
                    <div class="modal-body">
                        <div id="allChildrenScatterContainer" style="width: 80vw; height: 60vh;"></div>
                    </div>
                </div>
            </div>
  
            <!-- Fixed bottom details bar (right of sidebar) -->
            <div id="bottomDetails" class="bottom-details-fixed" style="display: block;">
                <div class="details-header" id="bottomDetailsHeader">
                    <div id="bottomDetailsTitle">Selected Node</div>
                    <button id="bottomDetailsCloseBtn" title="Close" style="border:none;background:#f3f4f6;color:#374151;border-radius:6px;padding:4px 8px;cursor:pointer;">✕</button>
                </div>
                <div class="details-body" id="bottomDetailsContent">
                <div class="details-grid-four">
                <div class="info-row">
                    <span class="info-label">Name:</span>
                    <span class="info-value">Eugene</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Role/Relationship:</span>
                    <span class="info-value">Grandpa</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Gender:</span>
                    <span class="info-value">Male</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Age:</span>
                    <span class="info-value">18 years old or older</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Race:</span>
                    <span class="info-value">Black or African-American</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Language:</span>
                    <span class="info-value">English; Portuguese</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Kin:</span>
                    <span class="info-value">Yes</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Mode of Contact:</span>
                    <span class="info-value">Both virtually and in-person</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Contact Context:</span>
                    <span class="info-value">At home, Extended Family</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Weekly Hours:</span>
                    <span class="info-value">10</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Hours % of week:</span>
                    <span class="info-value">6.0%</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Closeness Score:</span>
                    <span class="info-value">3</span>
                </div>
                        </div>
            </div>
            </div>
        </div>
    </div>
  
    <!-- Sample Formats Modal -->
    <div id="sampleModal" class="help-overlay" style="display: none;" onclick="closeSampleModal()">
        <div class="help-panel" onclick="event.stopPropagation()">
            <button class="close-panel" onclick="closeSampleModal()">×</button>
            <h3>File Format Requirements</h3>
            <div style="line-height: 1.6;">
                <p style="margin-bottom: 1.5rem; color: #666; font-size: 0.95rem;">
                    Your CSV files need specific column names to work properly. Here's what each file should contain:
                </p>

                <h4 style="margin: 1rem 0 0.5rem 0; color: #42a5f5;">📋 node_level_long.csv - People in the Network</h4>
                <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                    <strong>Required columns:</strong>
                    <ul style="margin: 0.5rem 0 0 0 1.5rem;">
                        <li><code>ChildID</code> - Unique identifier for each child</li>
                        <li><code>node_type</code> - Type of person (e.g., "sibling", "caregiver", "friend")</li>
                        <li><code>node_name</code> - Name of the person</li>
                        <li><code>node_mapping_code</code> - Unique code for each person</li>
                    </ul>
                    <strong>Optional columns:</strong>
                    <ul style="margin: 0.5rem 0 0 0 1.5rem;">
                        <li><code>node_gender</code>, <code>node_race</code>, <code>node_language</code></li>
                        <li><code>node_kin</code> - Family relationship</li>
                        <li><code>node_weekly_hour_summarized</code> - Hours spent together</li>
                        <li><code>node_closeness_score</code> - How close the relationship is</li>
                    </ul>
                </div>

                <h4 style="margin: 1rem 0 0.5rem 0; color: #42a5f5;">📊 ego_level_network_summary.csv - Network Summary</h4>
                <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                    <strong>Required columns:</strong>
                    <ul style="margin: 0.5rem 0 0 0 1.5rem;">
                        <li><code>ChildID</code> - Unique identifier for each child</li>
                        <li><code>child_name</code> - Name of the child</li>
                        <li><code>network_size</code> - Total number of people in the network</li>
                        <li><code>network_density</code> - How connected the network is</li>
                        <li><code>network_edges_number</code> - Total number of connections</li>
                        <li><code>network_component_count</code> - Number of disconnected components</li>
                        <li><code>network_component_ratio</code> - Network fragmentation measure</li>
                        <li><code>network_prop_adult_relationship</code> - Percentage of adult relationships</li>
                        <li><code>network_prop_kin_relationship</code> - Percentage of kin relationships</li>
                        <li><code>network_racial_entropy</code> - Shannon entropy of racial diversity</li>
                        <li><code>network_racial_ei_index</code> - Racial homophily index</li>
                        <li><code>network_language_entropy</code> - Shannon entropy of language diversity</li>
                        <li><code>network_linguistic_ei_index</code> - Language homophily index</li>
                    </ul>
                </div>

                <h4 style="margin: 1rem 0 0.5rem 0; color: #42a5f5;">🎯 activity_level_long.csv - Activities &amp; Participation</h4>
                <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
                    <strong>Required columns:</strong>
                    <ul style="margin: 0.5rem 0 0 0 1.5rem;">
                        <li><code>ChildID</code> - Unique identifier for each child</li>
                        <li><code>activity_id</code> - Unique identifier for each activity</li>
                        <li><code>activity_name</code> - Name of the activity (e.g., "Soccer", "Daycare")</li>
                    </ul>
                </div>

                <div style="background: #fce4ec; padding: 1rem; border-radius: 8px; margin-top: 1.5rem; border-left: 4px solid #8b0000;">
                    <strong>💡 Tip:</strong> Make sure your column names match exactly (including capitalization). 
                    The dashboard will automatically detect and use any optional columns you include.
                </div>
            </div>
        </div>
    </div>
  
    <div class="help-overlay" id="helpOverlay" onclick="hideHelp()">
        <div class="help-panel" onclick="event.stopPropagation()">
            <button class="close-panel" onclick="hideHelp()">×</button>
            <h3>What This Dashboard Does</h3>
            <div style="line-height: 1.6;">
                <p style="margin-bottom: 1.5rem; color: #666; font-size: 0.95rem;">
                    <strong>SNQ Network Plotting Dashboard</strong> creates visual maps of children's social networks. 
                    It shows who children interact with, how often, and in what contexts (home, daycare, activities, etc.).
                </p>

                <h4 style="margin: 1rem 0 0.5rem 0; color: #42a5f5;">🎯 What You'll See</h4>
                <ul style="margin-left: 1.5rem;">
                    <li><strong>Social Network Map:</strong> Visual representation of a child's social connections</li>
                    <li><strong>Context Groups:</strong> People organized by where they interact (home, daycare, activities)</li>
                    <li><strong>Connection Lines:</strong> Shows relationships between the child and others</li>
                    <li><strong>Demographic Info:</strong> Age, gender, race, language of people in the network</li>
                </ul>

                <h4 style="margin: 1rem 0 0.5rem 0; color: #42a5f5;">📁 What Files You Need</h4>
                <ul style="margin-left: 1.5rem;">
                    <li><strong>node_level_long.csv:</strong> List of people in the network with their details</li>
                    <li><strong>ego_level_network_summary.csv:</strong> Overall network statistics for each child</li>
                    
                </ul>

                <h4 style="margin: 1rem 0 0.5rem 0; color: #42a5f5;">🚀 Quick Start</h4>
                <ol style="margin-left: 1.5rem;">
                    <li>Upload your 3 CSV files above</li>
                    <li>Click "Process &amp; Validate" to check your data</li>
                    <li>Select a child from the dropdown menu</li>
                    <li>Click "Visualize Network" to see their social network</li>
                </ol>

                <h4 style="margin: 1rem 0 0.5rem 0; color: #42a5f5;">💡 Pro Tips</h4>
                <ul style="margin-left: 1.5rem;">
                    <li><strong>Click on people:</strong> Highlights them and shows their connections</li>
                    <li><strong>Click on boxes:</strong> See details about different groups (home, daycare, etc.)</li>
                    <li><strong>Use filters:</strong> Hide people by age, gender, or other characteristics</li>
                    <li><strong>Change colors:</strong> Color people by different characteristics (gender, race, etc.)</li>
                </ul>
            </div>
        </div>
    </div>
  
    <!-- Tooltip disabled - no black box popups -->
    <div class="tooltip" id="tooltip" style="display: none; opacity: 0; visibility: hidden !important; left: 1113px; top: 485px;">Willy</div>
  
    <script>
        // Global state
        const state = {
            data: {
                nodeLevelLong: null,
                egoLevelNetworkSummary: null,
                activityLevelLong: null,
                activityIndex: {}
            },
            current: {
                child: null,
                childData: null,
                nodeData: null,
                nodeEdges: []
            },
            ui: {
                page: 'welcome', // 'welcome', 'validate', 'mode', 'child', 'dataset'
                layoutStyle: 'grouped',
                nodeSizeBy: 'default',
                isNewDataUpload: false,
                colorBy: 'context',
                contextFilter: 'all',
                tieStrengthFilter: '0',
                visibleContexts: new Set(),
                showAlterEdges: true,
                edgeVisibility: 'all', // 'all', 'ego-only', 'selected-only'
                selectedNode: null,
                selectedContext: null,
                detailsType: null, // 'node' or 'context'
                filters: {
                    gender: new Set(),
                    race: new Set(),
                    language: new Set(),
                    kin: new Set(),
                    accent: new Set(),
                    contactMode: new Set(),
                    ageCategory: new Set(),
                    closenessScore: new Set(),
                    closenessScale: new Set(),
                    weeklyHoursBucket: new Set(),
                    weeklyHoursMinPct: 0,
                    weeklyHoursMaxPct: 1,
                    closenessMin: 0,
                    closenessMax: 4
                },
                searchTerm: '',
                confidentialMode: false,
                zoomTransform: null, // Store current zoom transform
                sessionId: null // Track current session
            },
            validation: {
                passed: false,
                results: {
                    nodeLevelLong: { passed: false, errors: [] },
                    egoLevelNetworkSummary: { passed: false, errors: [] },
                    activityLevelLong: { passed: false, errors: [] }
                }
            }
        };
  
        // Context configuration - User-specified color palette
        const CONTEXTS = {
            'home': { 
                color: '#E74C3C', // Coral red
                label: 'Home',
                keywords: ['liveathome', 'home']
            },
            
            'caregiver': { 
                color: '#27AE60', // Fresh green
                label: 'Caregiver',
                keywords: ['caregiver', 'nanny', 'babysitter']
            },
            'daycare': { 
                color: '#16A085', // Teal
                label: 'Daycare',
                keywords: ['daycare', 'teacher', 'schoolkid']
            },
            'extended_family': { 
                color: '#9B59B6', // Violet
                label: 'Extended Family',
                keywords: ['extended_family', 'extendedfamily']
            },
            'activity': { 
                color: '#E74C3C', // Coral red (same as home for activities)
                label: 'Activities',
                keywords: ['activity', 'act']
            },
            'anyoneelse': { 
                color: '#7F8C8D', // Neutral gray
                label: 'Anyone Else',
                keywords: ['other', 'anyoneelse']
            }
        };
  
        // Distinct activity colors for Activity 1-7 - User-specified cohesive gradient set
        const ACTIVITY_COLORS = [
            '#1ABC9C',  // Activity 1 - aqua green
            '#3498DB',  // Activity 2 - sky blue
            '#9B59B6',  // Activity 3 - violet (slightly lighter than extended family)
            '#E67E22',  // Activity 4 - bright orange (distinct from siblings' amber)
            '#D35400',  // Activity 5 - burnt orange (energetic)
            '#8E44AD',  // Activity 6 - deep purple (bold)
            '#2ECC71'   // Activity 7 - bright green (distinct from caregiver/daycare)
        ];
  
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, checking functions...');
            console.log('startChildExploration defined:', typeof startChildExploration);
            console.log('startWholeDataExploration defined:', typeof startWholeDataExploration);
            
            // Reset all state on page load to prevent carryover from previous sessions
            resetStateOnPageLoad();
            
            initializeApp();
            
            // Force normalization on any existing data
            setTimeout(() => {
                if (state.data.activityLevelLong || state.data.nodeLevelLong || state.data.egoLevelNetworkSummary) {
                    console.log('Force normalizing existing data after page load...');
                    normalizeExistingData();
                    console.log('Activity data after normalization:', state.data.activityLevelLong);
                }
                // Initialize range inputs after DOM is ready
                setTimeout(() => {
                    initRangeInputs();
                }, 500);
            }, 1000);
        });
  
        function initializeApp() {
            setupFileHandlers();
            initializeContextToggles();
            initializePageRouting();
            initializeSidebarResize();
            initializeWorkflowSteps();
            initializeAccordions();
            
            // Restore saved sidebar width
            const savedWidth = localStorage.getItem('sidebarWidth');
            if (savedWidth) {
                const sidebar = document.getElementById('sidebar');
                if (sidebar) {
                    sidebar.style.width = savedWidth + 'px';
                }
            }
            
            // Normalize any existing data on page load
            if (state.data.nodeLevelLong || state.data.egoLevelNetworkSummary || state.data.activityLevelLong) {
                console.log('Normalizing existing data on page load...');
                normalizeExistingData();
            }
        }

        function initializeWorkflowSteps() {
            // Set initial step states
            updateWorkflowStep('step-upload', 'completed');
            updateWorkflowStep('step-select', 'current');
            updateWorkflowStep('step-controls', 'pending');
            updateWorkflowStep('step-export', 'pending');
        }

        function updateWorkflowStep(stepId, status) {
            const step = document.getElementById(stepId);
            if (step) {
                step.className = `workflow-step ${status}`;
            }
        }

        function initializeAccordions() {
            // Set up accordion functionality
            const accordions = document.querySelectorAll('.accordion-header');
            accordions.forEach(header => {
                header.addEventListener('click', function() {
                    // Get the accordion ID from the data attribute
                    const accordionId = this.getAttribute('data-accordion');
                    if (accordionId) {
                        toggleAccordion(accordionId);
                    }
                });
            });
        }

        function toggleAccordion(accordionId) {
            const accordion = document.getElementById(accordionId);
            if (!accordion) return;
            
            const header = accordion.previousElementSibling;
            const content = accordion;
            
            if (content.classList.contains('active')) {
                content.classList.remove('active');
                header.classList.remove('active');
            } else {
                content.classList.add('active');
                header.classList.add('active');
            }
        }

        function updateChildSelection() {
            const childId = document.getElementById('childSelect').value;
            const previewStats = document.getElementById('childPreviewStats');
            
            if (childId) {
                // Show preview stats
                previewStats.style.display = 'grid';
                
                // Get child data for preview
                const childData = state.data.egoLevelNetworkSummary ? state.data.egoLevelNetworkSummary.find(d => d.ChildID === childId) : null;
                const nodeData = state.data.nodeLevelLong ? state.data.nodeLevelLong.filter(d => d.ChildID === childId) : [];
                
                if (childData && nodeData.length > 0) {
                    // Calculate preview stats
                    const contexts = new Set(nodeData.map(d => getNodeContext(d.node_type)).filter(Boolean));
                    const activities = new Set(nodeData.filter(d => d.node_type && d.node_type.includes('Act')).map(d => d.node_activity_specific).filter(Boolean));
                    
                    document.getElementById('previewNodes').textContent = nodeData.length + 1; // +1 for ego
                    document.getElementById('previewEdges').textContent = nodeData.length; // Simplified edge count
                    document.getElementById('previewContexts').textContent = contexts.size;
                    document.getElementById('previewActivities').textContent = activities.size;
                }
                
                // Enable visualize button
                document.getElementById('visualizeBtn').disabled = false;
            } else {
                previewStats.style.display = 'none';
                document.getElementById('visualizeBtn').disabled = true;
            }
        }
  
        // Page routing functions
        function initializePageRouting() {
            // Check for existing data on page load
            if (state.data.nodeLevelLong && state.data.egoLevelNetworkSummary && state.data.activityLevelLong) {
                if (state.validation.passed) {
                    startChildExploration();
                } else {
                    showPage('validate');
                }
            } else {
                showPage('welcome');
            }
        }
  
        function showPage(pageName) {
            // Hide all pages
            document.querySelectorAll('.page').forEach(page => {
                page.classList.add('hidden');
            });
            
            // Show target page
            const targetPage = document.getElementById(pageName + 'Page');
            if (targetPage) {
                targetPage.classList.remove('hidden');
                state.ui.page = pageName;
            }
            
            // Scroll to top to ensure full interface is visible
            window.scrollTo(0, 0);
            
            // Update page-specific initialization
            if (pageName === 'welcome') {
                updateUploadButtons();
            } else if (pageName === 'child') {
                // Simple approach: just try to render whatever is currently selected
                setTimeout(() => {
                    const select = document.getElementById('childSelect');
                    if (select && select.value) {
                        // If there's already a child selected, render it
                        console.log('Page load - rendering existing selection:', select.value);
                        visualizeNetwork();
                    } else if (select && select.options.length > 1) {
                        // Auto-select first child and render
                        console.log('Page load - auto-selecting first child');
                        select.selectedIndex = 1;
                        visualizeNetwork();
                    }
                }, 100);
            } else if (pageName === 'wholeData') {
                // Initialize whole data exploration
                setTimeout(() => {
                    initializeWholeDataExploration();
                    updateWholeDataExplorationView();
                }, 100);
            }
        }
  
        function goToWelcome() {
            // Reset validation state but preserve uploaded files
            state.validation.passed = false;
            showPage('welcome');
        }
  
        function goToValidate() {
            showPage('validate');
        }
  
        function goToMode() {
            startChildExploration();
        }

        function goToWholeData() {
            showPage('wholeData');
        }
  
        function startChildExploration() {
            console.log('startChildExploration called');
            showPage('child');
            
            // Reset UI elements to reflect the reset filters
            resetUIElements();
            
            // Set default tab to Child Selection
            setTimeout(() => {
                // showSidebarSection('child-selection'); // Removed - no longer needed with new workflow
                const select = document.getElementById('childSelect');
                if (select && select.value) {
                    // If there's already a child selected, render it
                    visualizeNetwork();
                } else if (select && select.options.length > 1) {
                    // If no child selected, select the first one and render
                    select.selectedIndex = 1;
                    updateChildSelection();
                }
            }, 200);
        }

        // Sidebar resize functionality
        function initializeSidebarResize() {
            const sidebar = document.getElementById('sidebar');
            const resizeHandle = document.getElementById('sidebarResizeHandle');
            let isResizing = false;
            let startX, startWidth;

            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startWidth = parseInt(getComputedStyle(sidebar).width, 10);
                document.body.style.cursor = 'col-resize';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                const deltaX = e.clientX - startX;
                const newWidth = Math.max(280, Math.min(600, startWidth + deltaX));
                
                sidebar.style.width = newWidth + 'px';
                
                // Update visualization width if it exists
                updateVisualizationWidth(newWidth);
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    
                    // Save the width to localStorage
                    const currentWidth = parseInt(getComputedStyle(sidebar).width, 10);
                    localStorage.setItem('sidebarWidth', currentWidth);
                }
            });
        }

        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const toggleBtn = document.getElementById('sidebarToggleBtn');
            
            if (sidebar.classList.contains('collapsed')) {
                // Expand sidebar
                sidebar.classList.remove('collapsed');
                toggleBtn.innerHTML = '◀';
                toggleBtn.title = 'Collapse Sidebar';
                
                // Restore saved width or use default
                const savedWidth = localStorage.getItem('sidebarWidth') || 340;
                sidebar.style.width = savedWidth + 'px';
            } else {
                // Collapse sidebar
                sidebar.classList.add('collapsed');
                toggleBtn.innerHTML = '▶';
                toggleBtn.title = 'Expand Sidebar';
                
                // Save current width before collapsing
                const currentWidth = parseInt(getComputedStyle(sidebar).width, 10);
                localStorage.setItem('sidebarWidth', currentWidth);
            }
            
            // Update visualization width
            updateVisualizationWidth();
        }

        function updateVisualizationWidth(sidebarWidth) {
            // Update the width calculation in createGroupedVisualization
            if (state.current.nodeData && state.current.nodeData.length > 0) {
                // Trigger a redraw with new width
                setTimeout(() => {
                    if (state.ui.page === 'child') {
                        createGroupedVisualization();
                    }
                }, 100);
            }
        }

        function toggleWholeDataSidebar() {
            const sidebar = document.getElementById('wholeDataSidebar');
            const toggleBtn = document.getElementById('wholeDataSidebarToggleBtn');
            
            if (sidebar.classList.contains('collapsed')) {
                // Expand sidebar
                sidebar.classList.remove('collapsed');
                toggleBtn.innerHTML = '◀';
                toggleBtn.title = 'Collapse Sidebar';
                
                // Restore saved width or use default
                const savedWidth = localStorage.getItem('wholeDataSidebarWidth') || 340;
                sidebar.style.width = savedWidth + 'px';
            } else {
                // Collapse sidebar
                sidebar.classList.add('collapsed');
                toggleBtn.innerHTML = '▶';
                toggleBtn.title = 'Expand Sidebar';
                
                // Save current width before collapsing
                const currentWidth = parseInt(getComputedStyle(sidebar).width, 10);
                localStorage.setItem('wholeDataSidebarWidth', currentWidth);
            }
        }
        
        function startWholeDataExploration() {
            showPage('wholeData');
            // Initialize the whole data exploration
            setTimeout(() => {
                initializeWholeDataExploration();
            }, 200);
        }
  
        function goToDataset() {
            showPage('dataset');
        }
  
        function showSampleFormats() {
            document.getElementById('sampleModal').style.display = 'block';
        }
  
        function closeSampleModal() {
            document.getElementById('sampleModal').style.display = 'none';
        }
  
        function setupFileHandlers() {
            document.getElementById('nodeLevelLongFile').addEventListener('change', (e) => handleFileUpload(e, 'nodeLevelLong'));
            document.getElementById('egoLevelNetworkSummaryFile').addEventListener('change', (e) => handleFileUpload(e, 'egoLevelNetworkSummary'));
        }
  
        function updateUploadButtons() {
            const processBtn = document.getElementById('processBtn');
            const filesReady = state.data.nodeLevelLong && state.data.egoLevelNetworkSummary;
            
            if (processBtn) {
                processBtn.disabled = !filesReady;
            }
            
            // Update upload zone statuses
            updateUploadZoneStatus('nodeLevelLong', state.data.nodeLevelLong);
            updateUploadZoneStatus('egoLevelNetworkSummary', state.data.egoLevelNetworkSummary);

            // If both files are ready, auto-normalize, validate, and go to validation page
            if (filesReady) {
                resetAllFilters();
                state.ui.isNewDataUpload = true;
                normalizeExistingData();
                buildActivityIndex();
                runValidation();
                showPage('validate');
            }
        }
  
        function updateUploadZoneStatus(fileType, data) {
            const zone = document.querySelector(`[onclick*="${fileType}File"]`);
            const status = document.getElementById(fileType + 'Status');
            
            if (!zone || !status) return;
            
            zone.classList.remove('loaded', 'error');
            
            if (data) {
                zone.classList.add('loaded');
                status.innerHTML = `✓ Loaded ${data.length} rows`;
                status.className = 'upload-status success';
            } else {
                status.innerHTML = '';
                status.className = 'upload-status';
            }
        }
  
        function initializeContextToggles() {
            const container = document.getElementById('contextToggles');
            if (!container) return;
            container.innerHTML = '';
            state.ui.visibleContexts = new Set();
            
            Object.entries(CONTEXTS).forEach(([key, config]) => {
                state.ui.visibleContexts.add(key);
                
                const div = document.createElement('div');
                div.className = 'checkbox-group';
                div.innerHTML = `
                    <input type="checkbox" id="context_${key}" checked onchange="toggleContext('${key}', this.checked)">
                    <label for="context_${key}" style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="width: 12px; height: 12px; background: ${config.color}; border-radius: 3px; border: 1px solid #ccc;"></span>
                        ${config.label}
                    </label>
                `;
                container.appendChild(div);
            });
        }
  
        function toggleContext(contextKey, checkedOverride) {
            // Determine desired checked state based on the source checkbox if provided
            let checked = typeof checkedOverride === 'boolean' ? checkedOverride : undefined;
            const mainCb = document.getElementById(`context_${contextKey}`);
            const displayCb = document.getElementById(`context_display_${contextKey}`);
            if (checked === undefined) {
                checked = mainCb ? !!mainCb.checked : true;
            }

            // Update state
            if (checked) {
                state.ui.visibleContexts.add(contextKey);
            } else {
                state.ui.visibleContexts.delete(contextKey);
            }

            // Mirror both checkboxes to keep UI in sync
            if (mainCb) mainCb.checked = checked;
            if (displayCb) displayCb.checked = checked;

            updateVisualization();
        }
  
        function updateEdgeVisibility() {
            const select = document.getElementById('edgeVisibility');
            state.ui.edgeVisibility = select.value;
            
            // Force redraw of edges with new visibility setting
            if (state.current.nodeEdges && state.current.nodeEdges.length > 0) {
                redrawAlterEdges();
            }
            
            updateVisualization();
        }
        
        function toggleSelectionView() {
            // Toggle between "all" and "selected-only" views
            if (state.ui.edgeVisibility === 'all') {
                state.ui.edgeVisibility = 'selected-only';
                document.getElementById('edgeVisibility').value = 'selected-only';
            } else {
                state.ui.edgeVisibility = 'all';
                document.getElementById('edgeVisibility').value = 'all';
            }
            updateVisualization();
        }
  
        function searchNodes() {
            const searchTerm = document.getElementById('nodeSearch').value.toLowerCase().trim();
            state.ui.searchTerm = searchTerm;
            
            // Remove previous search highlighting
            d3.selectAll('.node').classed('search-match', false);
            
            if (searchTerm) {
                // Find matching nodes
                const matches = [];
                d3.selectAll('.node').each(function(d) {
                    if (d && d.name.toLowerCase().includes(searchTerm)) {
                        d3.select(this).classed('search-match', true);
                        matches.push(d);
                    }
                });
                
                // Center on first match if found
                if (matches.length > 0) {
                    centerOnAlter(matches[0]);
                }
            }
        }
  
        function centerOnAlter(alter) {
            // Scroll/pan to bring alter into view (basic implementation)
            if (alter.x && alter.y) {
                const container = document.querySelector('.main-content');
                // Simple centering - could be enhanced with smooth animation
                container.scrollTo({
                    left: alter.x - container.clientWidth / 2 + 380, // Account for sidebar
                    top: alter.y - container.clientHeight / 2,
                    behavior: 'smooth'
                });
            }
        }
  
        function updateWeeklyHoursFilter() {
            const slider = document.getElementById('minWeeklyHours');
            const value = parseFloat(slider.value);
            document.getElementById('weeklyHoursValue').textContent = value;
            state.ui.filters.minWeeklyHours = value;
            updateVisualization();
        }
  
        function updateClosenessFilter() {
            const slider = document.getElementById('minCloseness');
            const value = parseFloat(slider.value);
            document.getElementById('closenessValue').textContent = value.toFixed(0);
            state.ui.filters.minCloseness = value;
            updateVisualization();
        }
  
        function toggleDemographicFilter(type, value) {
            const filterSet = state.ui.filters[type];
            if (!filterSet) return;
            if (filterSet.has(value)) {
                filterSet.delete(value);
            } else {
                filterSet.add(value);
            }
            updateVisualization();
        }
  
        function toggleContactModeFilter(value) {
            toggleDemographicFilter('contactMode', value);
        }
  
        function toggleContactContextFilter(value) {
            toggleDemographicFilter('contactContext', value);
        }
  
        function toggleAgeCategoryFilter(value) {
            toggleDemographicFilter('ageCategory', value);
        }
  
        function toggleConfidentialMode() {
            state.ui.confidentialMode = document.getElementById('confidentialMode').checked;
            updateVisualization();
        }
  
        // Helper function to get anonymized text for nodes
        function getAnonymizedText(nodeData, isEgo = false) {
            if (!state.ui.confidentialMode) {
                return isEgo ? nodeData.name : nodeData.name;
            }
  
            if (isEgo) {
                return 'Child';
            }
  
            // Check for siblings - use node_type + node_index
            const nodeType = nodeData.data?.node_type || nodeData.node_type || '';
            const nodeIndex = nodeData.data?.node_index || nodeData.node_index || '';
            
            if (nodeType.toLowerCase() === 'sibling') {
                return `Sibling${nodeIndex || '1'}`;
            }
            
            // Check for activity kids - ONLY those with node_type like "Act1Kid", "Act2Kid"
            const name = nodeData.name || '';
            const context = nodeData.context || '';
            
            // Only label as activity kid if node_type specifically contains "Kid" (e.g., "Act1Kid", "Act2Kid")
            const isActivityKid = nodeType.toLowerCase().includes('kid') && 
                                 (nodeType.toLowerCase().includes('act') || nodeType.toLowerCase().includes('activity'));
            
            if (isActivityKid) {
                // Extract activity number from node_type (e.g., "Act1Kid" -> "1")
                let actNum = '1'; // default
                
                // Try to extract from node_type first (most reliable for kids)
                const typeMatch = nodeType.match(/act(\d+)kid/i);
                if (typeMatch) {
                    actNum = typeMatch[1];
                } else {
                    // Fallback: try to extract from context
                    const contextMatch = context.match(/activity_(\d+)/i);
                    if (contextMatch) {
                        actNum = contextMatch[1];
                    }
                }
                
                return `Act${actNum}Kid${nodeIndex || '1'}`;
            }
            
            if (nodeType.toLowerCase().includes('school') || nodeData.name?.toLowerCase().includes('schoolkid')) {
                return `SchoolKid${nodeIndex || '1'}`;
            }
  
            // For named alters, use relationship from the correct data path
            const hasName = nodeData.name && !nodeData.name.toLowerCase().includes('kid');
            
            if (hasName) {
                // Use relationship for named alters - check both possible data paths
                const relationship = nodeData.data?.node_relationship || nodeData.node_relationship;
                return relationship || 'Unknown Relationship';
            } else {
                // Generate anonymized label for other unnamed alters
                return generateAnonymizedLabel(nodeData);
            }
        }
  
        // Helper function to generate anonymized labels for unnamed alters
        function generateAnonymizedLabel(nodeData) {
            const name = nodeData.name || '';
            const alterType = nodeData.node_type || '';
            
            // Create a unique identifier based on node properties
            const uniqueId = nodeData.node_id || nodeData.name || Math.random().toString(36).substr(2, 5);
            
            if (name.toLowerCase().includes('schoolkid') || alterType.toLowerCase().includes('school')) {
                return `SchoolKid${uniqueId.slice(-1)}`;
            } else if (name.toLowerCase().includes('activitykid') || name.toLowerCase().includes('activity')) {
                // Try to extract activity number from name
                const actMatch = name.match(/activity(\d+)/i);
                const actNum = actMatch ? actMatch[1] : '1';
                const kidNum = uniqueId.slice(-1);
                return `Act${actNum}Kid${kidNum}`;
            } else if (alterType.toLowerCase().includes('activity')) {
                return `ActKid${uniqueId.slice(-1)}`;
            }
            
            // Default fallback
            return `Alter${uniqueId.slice(-1)}`;
        }
  
        function handleFileUpload(event, fileType) {
            const file = event.target.files[0];
            if (!file) return;
  
            const zone = document.querySelector(`[onclick*="${fileType}File"]`);
            const statusElement = document.getElementById(fileType + 'Status');
            
            // Reset zone state
            zone.classList.remove('loaded', 'error');
            statusElement.innerHTML = 'Processing...';
            statusElement.className = 'upload-status';
  
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                complete: function(results) {
                    if (results.errors.length > 0) {
                        zone.classList.add('error');
                        statusElement.innerHTML = `✕ Error: ${results.errors[0].message}`;
                        statusElement.className = 'upload-status error';
                        state.data[fileType] = null;
                        updateUploadButtons();
                        return;
                    }
  
                    if (!results.data || results.data.length === 0) {
                        zone.classList.add('error');
                        statusElement.innerHTML = '✕ No data found in file';
                        statusElement.className = 'upload-status error';
                        state.data[fileType] = null;
                        updateUploadButtons();
                        return;
                    }
  
                    // Clean and normalize data
                    const cleanedData = results.data.filter(row => row && Object.keys(row).some(key => row[key]));
                    
                    // Normalize ChildID variants - comprehensive handling
                    let normalizedCount = 0;
                    let missingChildIdCount = 0;
                    
                    cleanedData.forEach((row, index) => {
                    // Handle various ChildID column name variations
                    const childIdVariants = ['ChildID', 'childID', 'child_id', 'Child_Id', 'child_Id', 'CHILDID', 'SubjectID', 'subjectID', 'subject_id', 'Subject_Id', 'subject_Id', 'SUBJECTID'];
                        let foundChildId = null;
                        let foundVariant = null;
                        
                        for (const variant of childIdVariants) {
                            if (row[variant] && row[variant].toString().trim()) {
                                foundChildId = row[variant].toString().trim();
                                foundVariant = variant;
                                break;
                            }
                        }
                        
                        if (foundChildId) {
                            row.ChildID = foundChildId;
                            normalizedCount++;
                            
                            // Clean up other variants to avoid confusion
                            childIdVariants.forEach(variant => {
                                if (variant !== 'ChildID' && row[variant]) {
                                    delete row[variant];
                                }
                            });
                        } else {
                            missingChildIdCount++;
                            console.warn(`Row ${index + 1} in ${fileType} is missing ChildID or equivalent column`);
                        }
                    });
                    
                    // Log normalization results
                    console.log(`${fileType} normalization complete:`, {
                        totalRows: cleanedData.length,
                        normalized: normalizedCount,
                        missingChildId: missingChildIdCount
                    });
                    
                    // Convert childcare values to integers for proper display
                    if (fileType === 'egoLevelNetworkSummary') {
                        cleanedData.forEach(row => {
                            if (row.childcare_start_age) {
                                row.childcare_start_age = Math.round(parseFloat(row.childcare_start_age));
                            }
                            if (row.childcare_size) {
                                row.childcare_size = Math.round(parseFloat(row.childcare_size));
                            }
                        });
                    }
  
                    state.data[fileType] = cleanedData;
                    zone.classList.add('loaded');
                    statusElement.innerHTML = `✓ Loaded ${cleanedData.length} rows`;
                    statusElement.className = 'upload-status success';
                    
                    updateUploadButtons();
                },
                error: function(error) {
                    zone.classList.add('error');
                    statusElement.innerHTML = `✕ Error: ${error.message}`;
                    statusElement.className = 'upload-status error';
                    state.data[fileType] = null;
                    updateUploadButtons();
                }
            });
        }

        function loadLocalData() {
            // Try to load CSV files from the same directory as the HTML file
            const files = [
                { name: 'node_level_long.csv', type: 'nodeLevelLong' },
                { name: 'ego_level_network_summary.csv', type: 'egoLevelNetworkSummary' }
            ];
            
            let loadedCount = 0;
            const totalFiles = files.length;
            
            // Show loading message
            const processBtn = document.getElementById('processBtn');
            if (processBtn) {
                processBtn.disabled = true;
                processBtn.textContent = 'Loading files...';
            }
            
            files.forEach(file => {
                fetch(file.name)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`File ${file.name} not found`);
                        }
                        return response.text();
                    })
                    .then(csvText => {
                        Papa.parse(csvText, {
                            header: true,
                            skipEmptyLines: true,
                            complete: function(results) {
                                if (results.errors.length > 0) {
                                    console.error(`Error parsing ${file.name}:`, results.errors[0].message);
                                    alert(`Error loading ${file.name}: ${results.errors[0].message}`);
                                    return;
                                }
                                
                                if (!results.data || results.data.length === 0) {
                                    console.error(`No data found in ${file.name}`);
                                    alert(`No data found in ${file.name}`);
                                    return;
                                }
                                
                                // Store the data
                                state.data[file.type] = results.data;
                                loadedCount++;
                                
                                console.log(`Loaded ${file.name}: ${results.data.length} rows`);
                                
                                // Check if all files are loaded
                                if (loadedCount === totalFiles) {
                                    // All files loaded successfully
                                    processData();
                                }
                            }
                        });
                    })
                    .catch(error => {
                        console.error(`Error loading ${file.name}:`, error);
                        alert(`Error loading ${file.name}. Please make sure the file is in the same folder as dashboard.html`);
                        
                        // Re-enable button
                        if (processBtn) {
                            processBtn.disabled = false;
                            processBtn.textContent = 'Load Data Files';
                        }
                    });
            });
        }

        // Admin gate removed in user version: uploads are enabled by default

        async function downloadLatestDashboard() {
            // Always pull from GitHub main so updates are reflected immediately
            const base = 'https://raw.githubusercontent.com/bethanyou/Child-Social-Network-Questionnaire/main/dashboard.html';
            const url = `${base}?_=${Date.now()}`; // cache bust
            try {
                const res = await fetch(url, { cache: 'no-store' });
                if (!res.ok) throw new Error('Network response was not ok');
                const blob = await res.blob();
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'SNQ_Dashboard.html';
                document.body.appendChild(a);
                a.click();
                URL.revokeObjectURL(a.href);
                document.body.removeChild(a);
            } catch (e) {
                // Fallback to opening in new tab if direct download fails
                window.open(url, '_blank');
            }
        }

        function downloadDashboard() {
            // Serialize the current document into a single self-contained HTML file
            try {
                const doctype = '<!DOCTYPE html>\n';
                const html = document.documentElement.outerHTML;
                const htmlContent = doctype + html;
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `SNQ_Dashboard_${new Date().toISOString().split('T')[0]}.html`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Error downloading HTML file:', error);
                alert('Error downloading dashboard. Please try again.');
            }
        }
  
        function processData() {
            // Generate a new session ID for this new data upload
            state.ui.sessionId = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            console.log('New data upload - new session ID:', state.ui.sessionId);
            
            // Reset all filters when new data is uploaded
            resetAllFilters();
            
            // Set flag to indicate this is a new data upload
            state.ui.isNewDataUpload = true;
            
            // Normalize existing data to ensure ChildID consistency
            normalizeExistingData();
            
            // Build activity index for fast lookup (no-op if activity data not provided)
            buildActivityIndex();
            
            // Run comprehensive validation
            runValidation();
            
            // Transition to validation page
            showPage('validate');
        }
  
        function runValidation() {
            // Reset validation state
            state.validation.results = {
                nodeLevelLong: { passed: false, errors: [] },
                egoLevelNetworkSummary: { passed: false, errors: [] }
            };
  
            // Validate each file
            validateNodeLevelLong();
            validateEgoLevelNetworkSummary();
  
            // Check ChildID intersection
            validateChildIdIntersection();
  
            // Update overall validation status
            const allPassed = Object.values(state.validation.results).every(result => result.passed);
            state.validation.passed = allPassed;
  
            // Populate child selector if validation passed
            if (allPassed) {
            populateChildSelector();
            }
  
            // Render validation results
            renderValidationResults();
        }
  
        function validateNodeLevelLong() {
            const data = state.data.nodeLevelLong;
            const result = state.validation.results.nodeLevelLong;
            
            if (!data || data.length === 0) {
                result.errors.push('No data loaded');
                return;
            }
  
            const requiredColumns = ['ChildID', 'node_type', 'node_name', 'node_mapping_code'];
            const availableColumns = Object.keys(data[0] || {});
            
            // Check for ChildID variations before checking for missing columns
            const hasChildId = availableColumns.some(col => 
                ['ChildID', 'childID', 'child_id', 'Child_Id', 'child_Id', 'CHILDID', 'SubjectID', 'subjectID', 'subject_id', 'Subject_Id', 'subject_Id', 'SUBJECTID'].includes(col)
            );
            
            const missingColumns = requiredColumns.filter(col => {
                if (col === 'ChildID') {
                    return !hasChildId;
                }
                return !availableColumns.includes(col);
            });
  
            if (missingColumns.length > 0) {
                result.errors.push(`Missing required columns: ${missingColumns.join(', ')}`);
            }
  
            // Check for duplicates
            const duplicates = new Map();
            data.forEach(row => {
                const key = `${row.ChildID}_${row.node_mapping_code}`;
                duplicates.set(key, (duplicates.get(key) || 0) + 1);
            });
            
            const duplicateKeys = Array.from(duplicates.entries()).filter(([key, count]) => count > 1);
            if (duplicateKeys.length > 0) {
                result.errors.push(`Duplicate node_mapping_code entries found for same ChildID: ${duplicateKeys.length} cases`);
            }
  
            result.passed = result.errors.length === 0;
        }
  
        function validateEgoLevelNetworkSummary() {
            const data = state.data.egoLevelNetworkSummary;
            const result = state.validation.results.egoLevelNetworkSummary;
            
            if (!data || data.length === 0) {
                result.errors.push('No data loaded');
                return;
            }
  
            const requiredColumns = [
                'ChildID', 'child_name', 'network_size', 'network_density', 'network_edges_number',
                'network_component_count', 'network_component_ratio', 'network_prop_adult_relationship', 'network_prop_kin_relationship',
                'network_racial_entropy', 'network_racial_ei_index', 'network_language_entropy', 'network_linguistic_ei_index'
            ];
            
            const availableColumns = Object.keys(data[0] || {});
            
            // Check for ChildID variations before checking for missing columns
            const hasChildId = availableColumns.some(col => 
                ['ChildID', 'childID', 'child_id', 'Child_Id', 'child_Id', 'CHILDID', 'SubjectID', 'subjectID', 'subject_id', 'Subject_Id', 'subject_Id', 'SUBJECTID'].includes(col)
            );
            
            const missingColumns = requiredColumns.filter(col => {
                if (col === 'ChildID') {
                    return !hasChildId;
                }
                return !availableColumns.includes(col);
            });
  
            if (missingColumns.length > 0) {
                result.errors.push(`Missing required columns: ${missingColumns.join(', ')}`);
            }
  
            result.passed = result.errors.length === 0;
        }
  
        function validateActivityLevelLong() {
            const data = state.data.activityLevelLong;
            const result = state.validation.results.activityLevelLong;
            
            if (!data || data.length === 0) {
                result.errors.push('No data loaded');
                return;
            }
  
            const requiredColumns = ['ChildID', 'activity_id', 'activity_name'];
            const availableColumns = Object.keys(data[0] || {});
            
            // Check for ChildID variations before checking for missing columns
            const hasChildId = availableColumns.some(col => 
                ['ChildID', 'childID', 'child_id', 'Child_Id', 'child_Id', 'CHILDID', 'SubjectID', 'subjectID', 'subject_id', 'Subject_Id', 'subject_Id', 'SUBJECTID'].includes(col)
            );
            
            const missingColumns = requiredColumns.filter(col => {
                if (col === 'ChildID') {
                    return !hasChildId;
                }
                return !availableColumns.includes(col);
            });
            
            // If ChildID is missing, provide helpful error message
            if (!hasChildId) {
                result.errors.push('Missing ChildID column. The activity_level_long.csv file must have a column named "ChildID" to link activities to children.');
            }
  
            if (missingColumns.length > 0) {
                result.errors.push(`Missing required columns: ${missingColumns.join(', ')}`);
            }
  
            result.passed = result.errors.length === 0;
        }
  
        function validateChildIdIntersection() {
            // Helper function to extract ChildID from any row, handling variations
            const getChildId = (row) => {
                const childIdVariants = ['ChildID', 'childID', 'child_id', 'Child_Id', 'child_Id', 'CHILDID', 'SubjectID', 'subjectID', 'subject_id', 'Subject_Id', 'subject_Id', 'SUBJECTID'];
                for (const variant of childIdVariants) {
                    if (row[variant] && row[variant].toString().trim()) {
                        return row[variant].toString().trim();
                    }
                }
                return null;
            };
            
            const nodeLevelLongChildIds = new Set((state.data.nodeLevelLong || []).map(row => getChildId(row)).filter(Boolean));
            const egoLevelNetworkSummaryChildIds = new Set((state.data.egoLevelNetworkSummary || []).map(row => getChildId(row)).filter(Boolean));
            
            // Log ChildID counts for debugging
            console.log('ChildID intersection validation:', {
                nodeLevelLongCount: nodeLevelLongChildIds.size,
                egoLevelNetworkSummaryCount: egoLevelNetworkSummaryChildIds.size,
                nodeLevelLongIds: Array.from(nodeLevelLongChildIds),
                egoLevelNetworkSummaryIds: Array.from(egoLevelNetworkSummaryChildIds)
            });

            const intersection = new Set([...nodeLevelLongChildIds].filter(id => 
                egoLevelNetworkSummaryChildIds.has(id)
            ));

            if (intersection.size === 0) {
                state.validation.results.nodeLevelLong.errors.push('No common ChildIDs found across the two files');
                state.validation.results.egoLevelNetworkSummary.errors.push('No common ChildIDs found across the two files');
            }
        }
  
        function renderValidationResults() {
            const statusDiv = document.getElementById('validationStatus');
            const resultsDiv = document.getElementById('validationResults');
            const continueBtn = document.getElementById('continueBtn');
  
            // Update overall status
            if (state.validation.passed) {
                statusDiv.innerHTML = '✅ All checks passed<br><span style="color: #155724;">Your data look good.</span>';
                statusDiv.className = 'validation-status pass';
                continueBtn.disabled = false;
            } else {
                statusDiv.innerHTML = '❌ Issues found<br><span style="color: #721c24;">Please review the errors below.</span>';
                statusDiv.className = 'validation-status fail';
                continueBtn.disabled = true;
            }
  
            // Render file-specific results
            const files = [
                { key: 'nodeLevelLong', name: 'node_level_long.csv' },
                { key: 'egoLevelNetworkSummary', name: 'ego_level_network_summary.csv' }
            ];
  
            resultsDiv.innerHTML = files.map(file => {
                const result = state.validation.results[file.key];
                const statusIcon = result.passed ? '✓' : '✗';
                const statusClass = result.passed ? 'pass' : 'fail';
                
                const checks = [
                    { label: 'Required columns present', passed: result.errors.length === 0 || !result.errors.some(e => e.includes('Missing required columns')) },
                    { label: 'Data integrity', passed: result.errors.length === 0 || !result.errors.some(e => e.includes('Duplicate') || e.includes('common ChildIDs')) }
                ];
  
                const checksHtml = checks.map(check => `
                    <div class="validation-check">
                        <div class="check-icon ${check.passed ? 'pass' : 'fail'}">
                            ${check.passed ? '✓' : '✗'}
                        </div>
                        <span>${check.label}</span>
                    </div>
                `).join('');
  
                const errorsHtml = result.errors.length > 0 ? 
                    `<div style="margin-top: 0.5rem; color: #721c24; font-size: 0.85rem;">
                        ${result.errors.map(error => `• ${error}`).join('<br>')}
                    </div>` : '';
  
                return `
                    <div class="validation-file">
                        <h4>
                            <div class="check-icon ${statusClass}">${statusIcon}</div>
                            ${file.name}
                        </h4>
                        ${checksHtml}
                        ${errorsHtml}
                    </div>
                `;
            }).join('');
        }
  
        function validateEgoLevelNetworkSummarySchema() {
            if (!state.data.egoLevelNetworkSummary || state.data.egoLevelNetworkSummary.length === 0) {
                console.warn('No ego_level_network_summary data loaded for schema validation');
                return;
            }
            
            const sampleRow = state.data.egoLevelNetworkSummary[0];
            const requiredFields = ['component_count', 'component_ratio'];
            const availableFields = Object.keys(sampleRow);
            
            console.log('Network_wide schema check:');
            console.log('Available fields:', availableFields);
            console.log('Looking for:', requiredFields);
            
            // Case-insensitive and trimmed field matching
            const normalizedAvailable = availableFields.map(f => f.trim().toLowerCase());
            const missingFields = requiredFields.filter(field => {
                const normalizedField = field.trim().toLowerCase();
                const found = normalizedAvailable.includes(normalizedField);
                console.log(`Looking for '${field}' (normalized: '${normalizedField}'):`, found ? 'FOUND' : 'MISSING');
                return !found;
            });
            
            // Remove any existing error badge first
            const statsSection = document.getElementById('networkStats');
            const header = statsSection?.querySelector('h3');
            const existingBadge = header?.querySelector('.schema-error');
            if (existingBadge) {
                existingBadge.remove();
            }
            
            if (missingFields.length > 0) {
                console.error('Missing columns in ego_level_network_summary:', missingFields);
                console.error('Available columns:', availableFields);
                
                // Add red badge to Network Summary
                if (header) {
                    const badge = document.createElement('span');
                    badge.className = 'schema-error';
                    badge.style.cssText = `
                        background: #dc3545;
                        color: white;
                        font-size: 0.7rem;
                        padding: 2px 6px;
                        border-radius: 3px;
                        margin-left: 8px;
                        font-weight: 500;
                    `;
                    badge.textContent = 'component fields not found';
                    badge.title = `Missing: ${missingFields.join(', ')}\nAvailable: ${availableFields.slice(0, 10).join(', ')}...`;
                    header.appendChild(badge);
                }
            } else {
                console.log('✓ All required component fields found');
            }
        }
  
        function normalizeExistingData() {
            // Normalize all existing data to ensure ChildID consistency
            const normalizeData = (data, dataType) => {
                if (!data || data.length === 0) return;
                
                let normalizedCount = 0;
                let missingChildIdCount = 0;
                
                data.forEach((row, index) => {
                    const childIdVariants = ['ChildID', 'childID', 'child_id', 'Child_Id', 'child_Id', 'CHILDID', 'SubjectID', 'subjectID', 'subject_id', 'Subject_Id', 'subject_Id', 'SUBJECTID'];
                    let foundChildId = null;
                    
                    for (const variant of childIdVariants) {
                        if (row[variant] && row[variant].toString().trim()) {
                            foundChildId = row[variant].toString().trim();
                            break;
                        }
                    }
                    
                    if (foundChildId) {
                        row.ChildID = foundChildId;
                        normalizedCount++;
                        
                        // Clean up other variants
                        childIdVariants.forEach(variant => {
                            if (variant !== 'ChildID' && row[variant]) {
                                delete row[variant];
                            }
                        });
                    } else {
                        missingChildIdCount++;
                        console.warn(`Row ${index + 1} in ${dataType} is missing ChildID or equivalent column`);
                    }
                });
                
                console.log(`${dataType} normalization complete:`, {
                    totalRows: data.length,
                    normalized: normalizedCount,
                    missingChildId: missingChildIdCount
                });
            };
            
            // Normalize all datasets
            normalizeData(state.data.nodeLevelLong, 'nodeLevelLong');
            normalizeData(state.data.egoLevelNetworkSummary, 'egoLevelNetworkSummary');
            normalizeData(state.data.activityLevelLong, 'activityLevelLong');
        }

        function buildActivityIndex() {
            state.data.activityIndex = {};
            
            if (state.data.activityLevelLong) {
                state.data.activityLevelLong.forEach(activity => {
                    // Handle ChildID variations consistently
                    const childIdVariants = ['ChildID', 'childID', 'child_id', 'Child_Id', 'child_Id', 'CHILDID', 'SubjectID', 'subjectID', 'subject_id', 'Subject_Id', 'subject_Id', 'SUBJECTID'];
                    let childId = null;
                    for (const variant of childIdVariants) {
                        if (activity[variant] && activity[variant].toString().trim()) {
                            childId = activity[variant].toString().trim();
                            break;
                        }
                    }
                    
                    if (childId) {
                        if (!state.data.activityIndex[childId]) {
                            state.data.activityIndex[childId] = {};
                        }
                        const activityId = String(activity.activity_id || '').trim();
                        if (activityId) {
                            state.data.activityIndex[childId][activityId] = activity;
                        }
                    } else {
                        console.warn('Activity row missing ChildID, skipping:', activity);
                    }
                });
            }
        }
  
        function populateChildSelector() {
            if (!state.data.egoLevelNetworkSummary) return;
            
            const childIds = [...new Set(state.data.egoLevelNetworkSummary.map(d => d.ChildID))].filter(id => id).sort();
            
            const select = document.getElementById('childSelect');
            select.innerHTML = '<option value="">Choose a child...</option>';
            
            childIds.forEach(id => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = id;
                select.appendChild(option);
            });
        }
  
        function updateChildSelection() {
            const select = document.getElementById('childSelect');
            
            // Auto-update: when a new child is chosen, re-render immediately
            if (select.value && state.ui.page === 'child') {
                console.log('Auto-rendering for child:', select.value);
                visualizeNetwork();
            }
        }
  
        function clearVisualization() {
            // Clear the SVG
            const svg = d3.select('#networkSvg');
            if (!svg.empty()) {
                svg.selectAll('*').remove();
            }
            
            // Clear any existing selections
            if (window.clearVisualSelection) {
                clearVisualSelection();
            }
            
            // Reset any state
            state.current.selectedNodes = [];
            state.current.selectedEdges = [];
        }

        function visualizeNetwork() {
            const childId = document.getElementById('childSelect').value;
            console.log('visualizeNetwork called with child:', childId);
            if (!childId) {
                console.log('No child selected');
                return;
            }
            
            // Clear any existing visualization first
            clearVisualization();
            
            // Set current data
            state.current.child = childId;
            state.current.childData = state.data.egoLevelNetworkSummary ? state.data.egoLevelNetworkSummary.find(d => d.ChildID === childId) : null;
            state.current.nodeData = state.data.nodeLevelLong ? state.data.nodeLevelLong.filter(d => d.ChildID === childId) : [];
            state.current.nodeEdges = parseAlterEdges(state.current.nodeData);
            
            // Update workflow steps
            updateWorkflowStep('step-select', 'completed');
            updateWorkflowStep('step-controls', 'current');
            updateWorkflowStep('step-export', 'pending');
            
            // Update sidebar child info whenever child data changes
            // updateSidebarChildInfo(); // Removed - no longer needed with new workflow
            
            console.log('Data loaded:', {
                childId,
                childData: !!state.current.childData,
                alterCount: state.current.nodeData.length,
                edgeCount: state.current.nodeEdges.length
            });
            
            // Reset quantiles for new dataset
            state.current.hourQuantiles = null;
            state.current.closenessQuantiles = null;
            
            // Check if this is a new data upload or child switching within same session
            if (state.ui.isNewDataUpload) {
                // For new data upload, reset all filters
                resetAllFilters();
                resetUIElements();
                // Clear the flag after first child is processed in this new dataset
                state.ui.isNewDataUpload = false;
                console.log('New data upload detected. Filters and UI reset. isNewDataUpload set to false.');
            } else {
                // For child switching within same session, preserve settings
                preserveSettingsAndInitializeFilters();
                console.log('Child switching detected. Settings preserved. isNewDataUpload is false.');
            }
            
            // Initialize filters
            try {
                initializeDemographicFilters();
            } catch (error) {
                console.warn('Error initializing demographic filters:', error);
            }
            
            // Show network stats
            try {
            updateNetworkStats();
            } catch (error) {
                console.warn('Error updating network stats:', error);
            }
            
            // Ensure we create the visualization immediately
            if (state.current.nodeData.length > 0) {
                console.log('Creating visualization...');
                try {
                    createGroupedVisualization();
                    // Ensure legend is visible after visualization is created
                    const legend = document.getElementById('legend');
                    if (legend) {
                        legend.style.display = 'block';
                    }
                } catch (error) {
                    console.error('Error creating visualization:', error);
                }
            } else {
                console.log('No alter data found for child:', childId);
                // Clear the visualization area if no data
                const svg = d3.select('#networkSvg');
                if (!svg.empty()) {
                    svg.selectAll('*').remove();
                }
            }
            
            // Scroll to top to ensure full interface is visible
            window.scrollTo(0, 0);
        }
  
        // Language set for validation
        const LANGUAGE_SET = new Set([
            "english", "german", "spanish", "portuguese", "italian", "thai", 
            "pre-verbal/non-verbal", "preverbal/nonverbal", "preverbal", "nonverbal", 
            "pre-verbal", "non-verbal"
        ]);
  
        function normLangList(s) {
            const raw = String(s || '').toLowerCase();
            const tokens = raw.split(/[;,/|]+/).map(x => x.trim()).filter(Boolean);
            if (tokens.length === 0) return ['unknown'];
            return tokens.map(t => {
                if (t.startsWith('pre')) return 'pre-verbal/non-verbal';
                if (!LANGUAGE_SET.has(t)) return t; // keep but won't be in whitelist; still match via intersection if whitelist empty
                return t;
            });
        }
  
        function normalizeLanguage(rawLanguage) {
            if (!rawLanguage) return ['Unknown']; // Don't return empty array
            
            // Remove "Multilingual:" prefix if present
            let cleanLanguage = rawLanguage;
            if (typeof cleanLanguage === 'string') {
                cleanLanguage = cleanLanguage.replace(/^multilingual:\s*/i, '');
            }
            
            const languageMap = {
                'english': 'English',
                'german': 'German', 
                'spanish': 'Spanish',
                'portuguese': 'Portuguese',
                'italian': 'Italian',
                'thai': 'Thai',
                'chinese': 'Chinese',
                'cantonese': 'Chinese (Cantonese)',
                'mandarin': 'Chinese (Mandarin)',
                'french': 'French',
                'japanese': 'Japanese',
                'korean': 'Korean',
                'arabic': 'Arabic',
                'hindi': 'Hindi',
                'russian': 'Russian',
                'dutch': 'Dutch',
                'swedish': 'Swedish',
                'norwegian': 'Norwegian',
                'danish': 'Danish',
                'finnish': 'Finnish',
                'polish': 'Polish',
                'czech': 'Czech',
                'hungarian': 'Hungarian',
                'greek': 'Greek',
                'turkish': 'Turkish',
                'hebrew': 'Hebrew',
                'persian': 'Persian',
                'vietnamese': 'Vietnamese',
                'filipino': 'Filipino',
                'indonesian': 'Indonesian',
                'malay': 'Malay',
                'preverbal': 'Pre-verbal/Non-verbal',
                'pre-verbal': 'Pre-verbal/Non-verbal',
                'nonverbal': 'Pre-verbal/Non-verbal',
                'non-verbal': 'Pre-verbal/Non-verbal',
                'non verbal': 'Pre-verbal/Non-verbal',
                'unknown': 'Unknown'
            };
            
            const normalized = cleanLanguage.split(/[,;/|]+/)
                .map(lang => lang.trim().toLowerCase())
                .map(lang => languageMap[lang] || lang)
                .filter(lang => lang && lang !== '');
            
            // Return up to first 5 languages for pie charts, but ensure at least 'Unknown' if empty
            const result = normalized.slice(0, 5);
            return result.length > 0 ? result : ['Unknown'];
        }
  
        function canonContext(raw) {
            const t = String(raw || '').toLowerCase().trim();
  
            // Activities: "act1", "act1kid", "act2", "act2kid", ...
            const m = t.match(/^act\s*([0-9]+)/) || t.match(/^act([0-9]+)kid$/);
            if (m) return `activity_${m[1]}`;
  
            if (t === 'liveathome' || t === 'home') return 'home';
            if (t === 'sibling' || t === 'siblings') return 'home';
  
            // *** Caregiver must be its own context (not daycare) ***
            if (t === 'caregiver' || t === 'nanny' || t === 'babysitter') return 'caregiver';
  
            // Daycare should include only teachers/schoolkids
            if (t === 'teacher' || t === 'schoolkid' || t === 'daycare') return 'daycare';
  
            // Extended family appears with a space in CSV
            if (t.includes('extended') && t.includes('family')) return 'extended_family';
  
            if (t === 'anyoneelse' || t === 'other' || t === 'others') return 'anyoneelse';
  
            // Fallback
            return 'anyoneelse';
        }
  
        // Generate 25 distinct colors for language categories
        function generateLanguageColors() {
            return [
                '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
                '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf',
                '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5',
                '#c49c94', '#f7b6d3', '#c7c7c7', '#dbdb8d', '#9edae5',
                '#ad494a', '#8c6d31', '#5254a3', '#bd9e39', '#6b6ecf'
            ];
        }

        function getLanguageColor(language, index = 0) {
            // Create a consistent mapping for language colors
            const languageColorMap = {
                'English': '#1f77b4',
                'Spanish': '#ff7f0e', 
                'French': '#2ca02c',
                'German': '#d62728',
                'Italian': '#9467bd',
                'Portuguese': '#8c564b',
                'Chinese': '#e377c2',
                'Chinese (Mandarin)': '#e377c2',
                'Chinese (Cantonese)': '#7f7f7f',
                'Japanese': '#bcbd22',
                'Korean': '#17becf',
                'Arabic': '#aec7e8',
                'Hindi': '#ffbb78',
                'Russian': '#98df8a',
                'Dutch': '#ff9896',
                'Swedish': '#c5b0d5',
                'Norwegian': '#c49c94',
                'Danish': '#f7b6d3',
                'Finnish': '#c7c7c7',
                'Polish': '#dbdb8d',
                'Czech': '#9edae5',
                'Hungarian': '#ff9896',
                'Greek': '#c5b0d5',
                'Turkish': '#cd853f',
                'Hebrew': '#ff69b4',
                'Persian': '#ff4500',
                'Vietnamese': '#32cd32',
                'Filipino': '#9932cc',
                'Indonesian': '#20b2aa',
                'Malay': '#ff6347',
                'Thai': '#ffd700',
                'Icelandic': '#ff1493',
                'Tagalog': '#00ced1',
                'Farsi': '#ff8c00',
                'Amharic': '#32cd32',
                'Somali': '#8a2be2',
                'Swahili': '#ff6347',
                'Oromo': '#20b2aa',
                'Tigrinya': '#ff69b4',
                'Kurdish': '#cd853f',
                'Nepali': '#9932cc',
                'Burmese': '#ff4500',
                'Karen': '#32cd32',
                'Hmong': '#ffd700',
                'Pre-verbal/Non-verbal': '#8b4513',
                'Unknown': '#a0a0a0',
                'na': '#cccccc'
            };
            
            // Special handling for different cases
            if (language === 'na' || language === null || language === undefined || language === '') {
                return '#cccccc'; // Light gray for missing/not applicable data
            }
            
            if (languageColorMap[language]) {
                return languageColorMap[language];
            }
            
            // For unlisted languages, generate a consistent color based on the language name
            // This ensures the same unlisted language always gets the same color
            const colors = generateLanguageColors();
            let hash = 0;
            for (let i = 0; i < language.length; i++) {
                const char = language.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return colors[Math.abs(hash) % colors.length];
        }

        // Accent color mapping – dynamic like language
        const ACCENT_COLOR_POOL = [
            '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
            '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf',
            '#ad494a', '#8c6d31', '#5254a3', '#bd9e39', '#6b6ecf'
        ];
        const accentColorMap = {};
        function getAccentColor(accent, index = 0) {
            if (!accent || accent === 'Unknown') return '#bdc3c7';
            if (accentColorMap[accent]) return accentColorMap[accent];
            // stable hash
            let hash = 0;
            for (let i = 0; i < accent.length; i++) {
                hash = ((hash << 5) - hash) + accent.charCodeAt(i);
                hash |= 0;
            }
            const color = ACCENT_COLOR_POOL[Math.abs(hash) % ACCENT_COLOR_POOL.length];
            accentColorMap[accent] = color;
            return color;
        }

        function createLanguagePieWedges(languages, nodeId, radius) {
            if (!languages || languages.length === 0) return '';
            
            const languagePalette = {};
            languages.forEach((lang, index) => {
                languagePalette[lang] = getLanguageColor(lang, index);
            });
            
            const anglePerLang = (2 * Math.PI) / languages.length;
            let paths = '';
            
            languages.forEach((lang, i) => {
                const startAngle = i * anglePerLang;
                const endAngle = (i + 1) * anglePerLang;
                
                const x1 = radius * Math.cos(startAngle);
                const y1 = radius * Math.sin(startAngle);
                const x2 = radius * Math.cos(endAngle);
                const y2 = radius * Math.sin(endAngle);
                
                const largeArcFlag = anglePerLang > Math.PI ? 1 : 0;
                
                const pathData = `M 0 0 L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2} Z`;
                const color = languagePalette[lang] || '#cccccc';
                
                paths += `<path d="${pathData}" fill="${color}" stroke="none"/>`;
            });
            
            return paths;
        }
  
        function initializeDemographicFilters() {
            if (!state.current.nodeData) return;
            
            // Extract unique values for each demographic (with canonicalization and Unknown handling)
            const genders = [...new Set(state.current.nodeData.map(d => d.node_gender || 'Unknown'))];
            
            // Debug race values
            console.log('Raw race values:', state.current.nodeData.map(d => d.node_race));
            const races = [...new Set(state.current.nodeData.map(d => canonRace(d.node_race)))];
            console.log('Canonicalized races:', races);
            
            const kinValues = [...new Set(state.current.nodeData.map(d => canonKin(d.node_kin)))];
            
            // Mode of contact filter
            const contactModes = [...new Set(state.current.nodeData.map(d => d.node_mode_of_contact || 'Unknown'))];
            
            // Contact context filter - parse and clean the complex text
            // const contactContexts = [...new Set(state.current.nodeData.map(d => parseContactContext(d.node_context)))];
            
            // Age category filter
            const ageCategories = [...new Set(state.current.nodeData.map(d => d.node_age_categorized || 'Unknown'))];

            // Weekly hours percentage buckets from data (0–1 as percent-of-week)
            const pctOfWeek = (d) => {
                const hours = parseFloat(d.node_weekly_hour_summarized || d.node_weekly_hour || 0);
                return isNaN(hours) ? 0 : Math.min(1, Math.max(0, hours / 168));
            };
            const bucketFor = (p) => {
                if (p < 0.05) return '0–5%';
                if (p < 0.10) return '5–10%';
                if (p < 0.20) return '10–20%';
                if (p < 0.40) return '20–40%';
                return '40–100%';
            };
            const weeklyBuckets = [...new Set(state.current.nodeData.map(d => bucketFor(pctOfWeek(d))))];
            
            // Extract actual languages from current child's data
            const languagesInData = [...new Set(state.current.nodeData.map(d => {
                const langString = d.node_language || 'Unknown';
                return normalizeLanguage(langString);
            }).flat())];
            const languages = languagesInData.sort();

            // Build accent options from node_accent_specific (split by ';')
            const accentTokensInData = [...new Set(state.current.nodeData.map(d => {
                const spec = String(d.node_accent_specific || '').split(';').map(s => s.trim()).filter(Boolean);
                return spec.length ? spec : ['Unknown'];
            }).flat())];
            const accents = accentTokensInData.sort();
            
            // Save options to state for dynamic rendering
            state.current.filterOptions = {
                gender: genders,
                race: races,
                language: languages,
                accent: accents,
                kin: kinValues,
                contactMode: contactModes,
                ageCategory: ageCategories,
                weeklyHoursBucket: weeklyBuckets,
                closenessScore: [0,1,2,3,4],
                closenessScale: [1,2,3,4,5,6,7]
            };
            // Render initial filter options
            renderAllFilterOptions();
            // Populate context toggles inside Display Options accordion as well
            renderContextTogglesDisplayOptions();
        }

        function renderContextTogglesDisplayOptions() {
            const container = document.getElementById('contextTogglesDisplayOptions');
            if (!container) return;
            container.innerHTML = '';
            Object.entries(CONTEXTS).forEach(([key, config]) => {
                const div = document.createElement('div');
                div.className = 'checkbox-group';
                const checked = state.ui.visibleContexts.has(key) ? 'checked' : '';
                div.innerHTML = `
                    <input type="checkbox" id="context_display_${key}" ${checked} onchange="toggleContext('${key}', this.checked)">
                    <label for="context_display_${key}" style="margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                        <span style="width: 12px; height: 12px; background: ${config.color}; border-radius: 3px; border: 1px solid #ccc;"></span>
                        ${config.label}
                    </label>`;
                container.appendChild(div);
            });
        }
  
        function renderAllFilterOptions() {
            if (!state.current.filterOptions) return;
            
            const filterTypes = ['gender', 'race', 'language', 'kin', 'accent', 'contactMode', 'ageCategory', 'weeklyHoursBucket', 'closenessScore', 'closenessScale'];
            
            filterTypes.forEach(type => {
                const container = document.getElementById(`${type}Filters`);
                const containerDisplay = document.getElementById(`${type}FiltersDisplay`);
                if (!container && !containerDisplay) return;
                
                let values = state.current.filterOptions[type] || [];
                
                // Sort age categories in logical order
                if (type === 'ageCategory') {
                    const ageOrder = [
                        'Younger than 2 years old',
                        '2-5 years old', 
                        '6-12 years old',
                        '13-17 years old',
                        '18 years old or older'
                    ];
                    values.sort((a, b) => {
                        const indexA = ageOrder.indexOf(a);
                        const indexB = ageOrder.indexOf(b);
                        // Put unknown values at the end
                        if (indexA === -1 && indexB === -1) return a.localeCompare(b);
                        if (indexA === -1) return 1;
                        if (indexB === -1) return -1;
                        return indexA - indexB;
                    });
                }
                
                const html = values.map(v => {
                    const id = `${type}_${v}`;
                    // Check if this value is currently selected in the filters
                    const isSelected = state.ui.filters[type]?.has(v);
                    const checked = isSelected ? 'checked' : '';
                    // For numeric filters, pass the number; for others escape quotes
                    const onchangeValue = (type === 'closenessScore' || type === 'closenessScale') 
                        ? `toggleDemographicFilter('${type}', ${v})` 
                        : `toggleDemographicFilter('${type}', '${String(v).replace(/'/g, "&#39;")}')`;
                    return `<div class="checkbox-group"><input type="checkbox" id="${id}" ${checked} onchange="${onchangeValue}"><label for="${id}" style="margin:0; font-size:0.85rem;">${v}</label></div>`;
                }).join('');
                if (container) container.innerHTML = html;
                if (containerDisplay) containerDisplay.innerHTML = html;
                
                // Initialize sets with all options selected by default only if no filters exist yet
                if (!state.ui.filters[type] || state.ui.filters[type].size === 0) {
                    state.ui.filters[type] = new Set(values);
                    const checkedHtml = values.map(v => {
                        const id = `${type}_${v}`;
                        const onchangeValue = (type === 'closenessScore' || type === 'closenessScale') 
                            ? `toggleDemographicFilter('${type}', ${v})` 
                            : `toggleDemographicFilter('${type}', '${String(v).replace(/'/g, "&#39;")}')`;
                        return `<div class="checkbox-group"><input type="checkbox" id="${id}" checked onchange="${onchangeValue}"><label for="${id}" style="margin:0; font-size:0.85rem;">${v}</label></div>`;
                    }).join('');
                    if (container) container.innerHTML = checkedHtml;
                    if (containerDisplay) containerDisplay.innerHTML = checkedHtml;
                }
            });
        }

        function toggleFilterCategory(category) {
            const content = document.getElementById(`${category}Content`);
            const toggle = document.getElementById(`${category}Toggle`);
            
            if (content && toggle) {
                const isExpanded = content.classList.contains('expanded');
                
                if (isExpanded) {
                    content.classList.remove('expanded');
                    toggle.classList.remove('expanded');
                    toggle.textContent = '▶';
                } else {
                    content.classList.add('expanded');
                    toggle.classList.add('expanded');
                    toggle.textContent = '▼';
                }
            }
        }

        function resetFilters() {
            // Reset categorical filters to include all current options
            if (state.current.filterOptions) {
                Object.entries(state.current.filterOptions).forEach(([key, vals]) => {
                    state.ui.filters[key] = new Set(vals || []);
                });
                // Ensure numeric checkbox filters are fully selected even if options missing
                state.ui.filters.closenessScore = new Set([0,1,2,3,4]);
                state.ui.filters.closenessScale = new Set([1,2,3,4,5,6,7]);
            }
            
            // Reset weekly hours range
            state.ui.filters.weeklyHoursMinPct = 0;
            state.ui.filters.weeklyHoursMaxPct = 1;
            if (weeklyHoursSlider) weeklyHoursSlider.setValues(0, 1);
            const whLabel = document.getElementById('weeklyHoursRangeValue');
            if (whLabel) whLabel.textContent = '0 - 1';

            // Reset closeness score range
            state.ui.filters.closenessMin = 0;
            state.ui.filters.closenessMax = 4;
            if (closenessSlider) closenessSlider.setValues(0, 4);
            const cLabel = document.getElementById('closenessRangeValue');
            if (cLabel) cLabel.textContent = '0 - 4';

            // Update all number input fields in both panels
            const hoursMinMain = document.getElementById('weeklyHoursMin');
            const hoursMaxMain = document.getElementById('weeklyHoursMax');
            const hoursMinDisp = document.getElementById('weeklyHoursMinDisplay');
            const hoursMaxDisp = document.getElementById('weeklyHoursMaxDisplay');
            if (hoursMinMain) hoursMinMain.value = 0;
            if (hoursMaxMain) hoursMaxMain.value = 1;
            if (hoursMinDisp) hoursMinDisp.value = 0;
            if (hoursMaxDisp) hoursMaxDisp.value = 1;

            const closeMinMain = document.getElementById('closenessMin');
            const closeMaxMain = document.getElementById('closenessMax');
            const closeMinDisp = document.getElementById('closenessMinDisplay');
            const closeMaxDisp = document.getElementById('closenessMaxDisplay');
            if (closeMinMain) closeMinMain.value = 0;
            if (closeMaxMain) closeMaxMain.value = 4;
            if (closeMinDisp) closeMinDisp.value = 0;
            if (closeMaxDisp) closeMaxDisp.value = 4;

            // Re-render all filter checkboxes to show all checked
            renderAllFilterOptions();

            // Explicitly check all boxes for closeness filters in both panels
            ['closenessScore', 'closenessScale'].forEach(type => {
                const container = document.getElementById(`${type}Filters`);
                const containerDisplay = document.getElementById(`${type}FiltersDisplay`);
                [container, containerDisplay].forEach(c => {
                    if (!c) return;
                    c.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = true; });
                });
            });

            // Save to storage and update
            saveRangeFiltersToStorage();
            notifyFilterChange();
            updateGraphWithFilters();
            updateVisualization();
        }


        // Modern RangeSlider Component
        class RangeSlider {
            constructor(container, options = {}) {
                this.container = container;
                this.options = {
                    min: 0,
                    max: 1,
                    step: 0.01,
                    initialMinValue: options.min || 0,
                    initialMaxValue: options.max || 1,
                    minGap: 0.01,
                    snapToStep: true,
                    formatLabel: (v) => v.toFixed(2),
                    onChange: () => {},
                    onChangeEnd: () => {},
                    debounceMs: 200,
                    ...options
                };
                
                this.minValue = this.options.initialMinValue;
                this.maxValue = this.options.initialMaxValue;
                this.isDragging = false;
                this.dragTarget = null;
                this.debounceTimer = null;
                
                this.init();
            }
            
            init() {
                this.container.innerHTML = '';
                this.container.className = 'range-slider';
                
                // Create track
                this.track = document.createElement('div');
                this.track.className = 'track';
                this.container.appendChild(this.track);
                
                // Create range fill
                this.range = document.createElement('div');
                this.range.className = 'range';
                this.container.appendChild(this.range);
                
                // Create thumbs
                this.minThumb = this.createThumb('min', 'Min value');
                this.maxThumb = this.createThumb('max', 'Max value');
                
                this.container.appendChild(this.minThumb);
                this.container.appendChild(this.maxThumb);
                
                this.bindEvents();
                this.updatePositions();
            }
            
            createThumb(type, ariaLabel) {
                const thumb = document.createElement('div');
                thumb.className = 'thumb';
                thumb.setAttribute('role', 'slider');
                thumb.setAttribute('aria-valuemin', this.options.min);
                thumb.setAttribute('aria-valuemax', this.options.max);
                thumb.setAttribute('aria-valuenow', type === 'min' ? this.minValue : this.maxValue);
                thumb.setAttribute('aria-label', ariaLabel);
                thumb.setAttribute('tabindex', '0');
                thumb.dataset.type = type;
                return thumb;
            }
            
            bindEvents() {
                // Mouse events
                this.minThumb.addEventListener('mousedown', (e) => this.startDrag(e, this.minThumb));
                this.maxThumb.addEventListener('mousedown', (e) => this.startDrag(e, this.maxThumb));
                document.addEventListener('mousemove', (e) => this.handleDrag(e));
                document.addEventListener('mouseup', () => this.endDrag());
                
                // Touch events
                this.minThumb.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.startDrag(e.touches[0], this.minThumb);
                });
                this.maxThumb.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.startDrag(e.touches[0], this.maxThumb);
                });
                document.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.handleDrag(e.touches[0]);
                });
                document.addEventListener('touchend', () => this.endDrag());
                
                // Keyboard events
                this.minThumb.addEventListener('keydown', (e) => this.handleKeyDown(e, this.minThumb));
                this.maxThumb.addEventListener('keydown', (e) => this.handleKeyDown(e, this.maxThumb));
                
                // Track click
                this.container.addEventListener('click', (e) => this.handleTrackClick(e));
            }
            
            startDrag(e, target) {
                this.isDragging = true;
                this.dragTarget = target;
                target.style.cursor = 'grabbing';
                e.preventDefault();
            }
            
            handleDrag(e) {
                if (!this.isDragging || !this.dragTarget) return;
                
                const rect = this.container.getBoundingClientRect();
                const percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
                const newValue = this.options.min + percent * (this.options.max - this.options.min);
                const snappedValue = this.snap(newValue);
                
                this.updateValue(snappedValue, this.dragTarget.dataset.type);
            }
            
            endDrag() {
                if (!this.isDragging) return;
                this.isDragging = false;
                if (this.dragTarget) {
                    this.dragTarget.style.cursor = 'grab';
                    this.dragTarget = null;
                }
                this.debouncedOnChangeEnd();
            }
            
            handleKeyDown(e, target) {
                const isMin = target.dataset.type === 'min';
                const currentValue = isMin ? this.minValue : this.maxValue;
                const otherValue = isMin ? this.maxValue : this.minValue;
                let newValue = currentValue;
                
                const stepSize = e.shiftKey ? this.options.step * 10 : this.options.step;
                
                switch (e.key) {
                    case 'ArrowLeft':
                    case 'ArrowDown':
                        newValue = currentValue - stepSize;
                        break;
                    case 'ArrowRight':
                    case 'ArrowUp':
                        newValue = currentValue + stepSize;
                        break;
                    case 'Home':
                        newValue = this.options.min;
                        break;
                    case 'End':
                        newValue = this.options.max;
                        break;
                    default:
                        return;
                }
                
                e.preventDefault();
                newValue = this.snap(this.clamp(newValue));
                this.updateValue(newValue, target.dataset.type);
                this.debouncedOnChangeEnd();
            }
            
            handleTrackClick(e) {
                if (this.isDragging) return;
                
                const rect = this.container.getBoundingClientRect();
                const percent = (e.clientX - rect.left) / rect.width;
                const clickValue = this.options.min + percent * (this.options.max - this.options.min);
                const snappedValue = this.snap(clickValue);
                
                // Determine which thumb to move based on which is closer
                const minDistance = Math.abs(snappedValue - this.minValue);
                const maxDistance = Math.abs(snappedValue - this.maxValue);
                
                if (minDistance < maxDistance) {
                    this.updateValue(snappedValue, 'min');
                } else {
                    this.updateValue(snappedValue, 'max');
                }
                
                this.debouncedOnChangeEnd();
            }
            
            updateValue(newValue, type) {
                const clampedValue = this.clamp(newValue);
                
                if (type === 'min') {
                    this.minValue = Math.min(clampedValue, this.maxValue - this.options.minGap);
                } else {
                    this.maxValue = Math.max(clampedValue, this.minValue + this.options.minGap);
                }
                
                this.updatePositions();
                this.debouncedOnChange();
            }
            
            updatePositions() {
                const minPercent = this.getPositionFromValue(this.minValue);
                const maxPercent = this.getPositionFromValue(this.maxValue);
                
                this.minThumb.style.left = `${minPercent}%`;
                this.maxThumb.style.left = `${maxPercent}%`;
                this.range.style.left = `${minPercent}%`;
                this.range.style.width = `${maxPercent - minPercent}%`;
                
                this.minThumb.setAttribute('aria-valuenow', this.minValue);
                this.maxThumb.setAttribute('aria-valuenow', this.maxValue);
            }
            
            getPositionFromValue(value) {
                return ((value - this.options.min) / (this.options.max - this.options.min)) * 100;
            }
            
            snap(value) {
                return this.options.snapToStep ? 
                    Math.round(value / this.options.step) * this.options.step : 
                    value;
            }
            
            clamp(value) {
                return Math.max(this.options.min, Math.min(this.options.max, value));
            }
            
            debouncedOnChange() {
                if (this.debounceTimer) clearTimeout(this.debounceTimer);
                this.debounceTimer = setTimeout(() => {
                    this.options.onChange({ 
                        minValue: this.minValue, 
                        maxValue: this.maxValue 
                    });
                }, this.options.debounceMs);
            }
            
            debouncedOnChangeEnd() {
                if (this.debounceTimer) clearTimeout(this.debounceTimer);
                this.options.onChangeEnd({ 
                    minValue: this.minValue, 
                    maxValue: this.maxValue 
                });
            }
            
            // Public API
            setValues(minValue, maxValue) {
                this.minValue = this.clamp(minValue);
                this.maxValue = this.clamp(maxValue);
                
                // Ensure min gap
                if (this.maxValue - this.minValue < this.options.minGap) {
                    const center = (this.minValue + this.maxValue) / 2;
                    this.minValue = center - this.options.minGap / 2;
                    this.maxValue = center + this.options.minGap / 2;
                }
                
                this.updatePositions();
            }
            
            getValues() {
                return { minValue: this.minValue, maxValue: this.maxValue };
            }
            
            destroy() {
                document.removeEventListener('mousemove', this.handleDrag);
                document.removeEventListener('mouseup', this.endDrag);
                document.removeEventListener('touchmove', this.handleDrag);
                document.removeEventListener('touchend', this.endDrag);
                if (this.debounceTimer) clearTimeout(this.debounceTimer);
            }
        }

        // Initialize range inputs
        function initRangeInputs() {
            console.log('Initializing range inputs...');
            
            // Load saved filter values from localStorage
            loadRangeFiltersFromStorage();
            
            // Set initial values for main inputs
            const weeklyHoursMinEl = document.getElementById('weeklyHoursMin');
            const weeklyHoursMaxEl = document.getElementById('weeklyHoursMax');
            const closenessMinEl = document.getElementById('closenessMin');
            const closenessMaxEl = document.getElementById('closenessMax');
            
            if (weeklyHoursMinEl && weeklyHoursMaxEl) {
                weeklyHoursMinEl.value = state.ui.filters.weeklyHoursMinPct ?? 0;
                weeklyHoursMaxEl.value = state.ui.filters.weeklyHoursMaxPct ?? 1;
            }
            
            if (closenessMinEl && closenessMaxEl) {
                closenessMinEl.value = state.ui.filters.closenessMin ?? 0;
                closenessMaxEl.value = state.ui.filters.closenessMax ?? 4;
            }
            
            // Set initial values for display inputs
            const weeklyHoursMinDisplayEl = document.getElementById('weeklyHoursMinDisplay');
            const weeklyHoursMaxDisplayEl = document.getElementById('weeklyHoursMaxDisplay');
            const closenessMinDisplayEl = document.getElementById('closenessMinDisplay');
            const closenessMaxDisplayEl = document.getElementById('closenessMaxDisplay');
            
            if (weeklyHoursMinDisplayEl && weeklyHoursMaxDisplayEl) {
                weeklyHoursMinDisplayEl.value = state.ui.filters.weeklyHoursMinPct ?? 0;
                weeklyHoursMaxDisplayEl.value = state.ui.filters.weeklyHoursMaxPct ?? 1;
            }
            
            if (closenessMinDisplayEl && closenessMaxDisplayEl) {
                closenessMinDisplayEl.value = state.ui.filters.closenessMin ?? 0;
                closenessMaxDisplayEl.value = state.ui.filters.closenessMax ?? 4;
            }
            
            console.log('Range inputs initialized successfully');
        }
        
        // Simple Range Input Functions
        function updateWeeklyHoursRange() {
            const minEl = document.getElementById('weeklyHoursMin');
            const maxEl = document.getElementById('weeklyHoursMax');
            if (!minEl || !maxEl) return;
            
            let min = parseFloat(minEl.value);
            let max = parseFloat(maxEl.value);
            // Accept inputs typed as 0-100 and normalize to 0-1
            if (!isNaN(min) && min > 1) min = min / 100;
            if (!isNaN(max) && max > 1) max = max / 100;
            
            // Ensure min doesn't exceed max
            if (min > max) {
                [min, max] = [max, min];
                minEl.value = min.toFixed(2);
                maxEl.value = max.toFixed(2);
            }
            
            state.ui.filters.weeklyHoursMinPct = min;
            state.ui.filters.weeklyHoursMaxPct = max;
            
            // Sync with display inputs
            const minDisplayEl = document.getElementById('weeklyHoursMinDisplay');
            const maxDisplayEl = document.getElementById('weeklyHoursMaxDisplay');
            if (minDisplayEl) minDisplayEl.value = min.toFixed(2);
            if (maxDisplayEl) maxDisplayEl.value = max.toFixed(2);
            
            // Save to localStorage and notify callbacks
            saveRangeFiltersToStorage();
            notifyFilterChange();
            
            updateGraphWithFilters();
        }
        
        function updateClosenessRange() {
            const minEl = document.getElementById('closenessMin');
            const maxEl = document.getElementById('closenessMax');
            if (!minEl || !maxEl) return;
            
            let min = parseInt(minEl.value, 10);
            let max = parseInt(maxEl.value, 10);
            
            // Ensure min doesn't exceed max
            if (min > max) {
                [min, max] = [max, min];
                minEl.value = min;
                maxEl.value = max;
            }
            
            state.ui.filters.closenessMin = min;
            state.ui.filters.closenessMax = max;
            
            // Sync with display inputs
            const minDisplayEl = document.getElementById('closenessMinDisplay');
            const maxDisplayEl = document.getElementById('closenessMaxDisplay');
            if (minDisplayEl) minDisplayEl.value = min;
            if (maxDisplayEl) maxDisplayEl.value = max;
            
            // Save to localStorage and notify callbacks
            saveRangeFiltersToStorage();
            notifyFilterChange();
            
            updateGraphWithFilters();
        }
        
        function updateWeeklyHoursRangeDisplay() {
            const minEl = document.getElementById('weeklyHoursMinDisplay');
            const maxEl = document.getElementById('weeklyHoursMaxDisplay');
            if (!minEl || !maxEl) return;
            
            let min = parseFloat(minEl.value);
            let max = parseFloat(maxEl.value);
            // Accept inputs typed as 0-100 and normalize to 0-1
            if (!isNaN(min) && min > 1) min = min / 100;
            if (!isNaN(max) && max > 1) max = max / 100;
            
            // Ensure min doesn't exceed max
            if (min > max) {
                [min, max] = [max, min];
                minEl.value = min.toFixed(2);
                maxEl.value = max.toFixed(2);
            }
            
            state.ui.filters.weeklyHoursMinPct = min;
            state.ui.filters.weeklyHoursMaxPct = max;
            
            // Sync with main inputs
            const minMainEl = document.getElementById('weeklyHoursMin');
            const maxMainEl = document.getElementById('weeklyHoursMax');
            if (minMainEl) minMainEl.value = min.toFixed(2);
            if (maxMainEl) maxMainEl.value = max.toFixed(2);
            
            // Save to localStorage and notify callbacks
            saveRangeFiltersToStorage();
            notifyFilterChange();
            
            updateGraphWithFilters();
        }
        
        function updateClosenessRangeDisplay() {
            const minEl = document.getElementById('closenessMinDisplay');
            const maxEl = document.getElementById('closenessMaxDisplay');
            if (!minEl || !maxEl) return;
            
            let min = parseInt(minEl.value, 10);
            let max = parseInt(maxEl.value, 10);
            
            // Ensure min doesn't exceed max
            if (min > max) {
                [min, max] = [max, min];
                minEl.value = min;
                maxEl.value = max;
            }
            
            state.ui.filters.closenessMin = min;
            state.ui.filters.closenessMax = max;
            
            // Sync with main inputs
            const minMainEl = document.getElementById('closenessMin');
            const maxMainEl = document.getElementById('closenessMax');
            if (minMainEl) minMainEl.value = min;
            if (maxMainEl) maxMainEl.value = max;
            
            // Save to localStorage and notify callbacks
            saveRangeFiltersToStorage();
            notifyFilterChange();
            
            updateGraphWithFilters();
        }
        
        // Range Filter Integration Functions
        function updateGraphWithFilters() {
            if (!state.current.nodeData || !state.current.nodeEdges) return;
            
            const hoursMin = state.ui.filters.weeklyHoursMinPct;
            const hoursMax = state.ui.filters.weeklyHoursMaxPct;
            const closenessMin = state.ui.filters.closenessMin;
            const closenessMax = state.ui.filters.closenessMax;
            const scaleMin = state.ui.filters.closenessScaleMin ?? 1;
            const scaleMax = state.ui.filters.closenessScaleMax ?? 7;
            
            // Update node opacity based on filters
            d3.selectAll('.node')
                .style('opacity', function(d) {
                    const hoursPercent = d.hours_percent || 0;
                    const closenessScore = d.node_closeness_score ?? d.closeness_score ?? 0;
                    const closenessScale = d.node_closeness_scale ?? 0;
                    
                    const inHoursRange = hoursPercent >= hoursMin && hoursPercent <= hoursMax;
                    const inClosenessRange = closenessScore >= closenessMin && closenessScore <= closenessMax;
                    const inScaleRange = closenessScale >= scaleMin && closenessScale <= scaleMax;
                    
                    return (inHoursRange && inClosenessRange && inScaleRange) ? 1 : 0.2;
                });
            
            // Update edge opacity based on connected nodes
            d3.selectAll('.edge')
                .style('opacity', function(d) {
                    const sourceNode = d.source;
                    const targetNode = d.target;
                    
                    const sourceHoursPercent = sourceNode.hours_percent || 0;
                    const sourceClosenessScore = sourceNode.node_closeness_score ?? sourceNode.closeness_score ?? 0;
                    const targetHoursPercent = targetNode.hours_percent || 0;
                    const targetClosenessScore = targetNode.node_closeness_score ?? targetNode.closeness_score ?? 0;
                    const sourceScale = sourceNode.node_closeness_scale ?? 0;
                    const targetScale = targetNode.node_closeness_scale ?? 0;
                    
                    const sourceInRange = (sourceHoursPercent >= hoursMin && sourceHoursPercent <= hoursMax) &&
                                        (sourceClosenessScore >= closenessMin && sourceClosenessScore <= closenessMax) &&
                                        (sourceScale >= scaleMin && sourceScale <= scaleMax);
                    const targetInRange = (targetHoursPercent >= hoursMin && targetHoursPercent <= hoursMax) &&
                                        (targetClosenessScore >= closenessMin && targetClosenessScore <= closenessMax) &&
                                        (targetScale >= scaleMin && targetScale <= scaleMax);
                    
                    return (sourceInRange && targetInRange) ? 1 : 0.2;
                });
        }
        
        // Programmatic API for Range Filters
        const RangeFilterAPI = {
            setFilters: (filters) => {
                if (filters.hours) {
                    state.ui.filters.weeklyHoursMinPct = filters.hours[0];
                    state.ui.filters.weeklyHoursMaxPct = filters.hours[1];
                    
                    if (weeklyHoursSlider) {
                        weeklyHoursSlider.setValues(filters.hours[0], filters.hours[1]);
                    }
                    if (weeklyHoursSliderDisplay) {
                        weeklyHoursSliderDisplay.setValues(filters.hours[0], filters.hours[1]);
                    }
                    
                    const el = document.getElementById('weeklyHoursRangeValue');
                    if (el) el.textContent = `Range: ${filters.hours[0].toFixed(2)} – ${filters.hours[1].toFixed(2)}`;
                    const elDisplay = document.getElementById('weeklyHoursRangeValueDisplay');
                    if (elDisplay) elDisplay.textContent = `Range: ${filters.hours[0].toFixed(2)} – ${filters.hours[1].toFixed(2)}`;
                }
                
                if (filters.closeness) {
                    state.ui.filters.closenessMin = filters.closeness[0];
                    state.ui.filters.closenessMax = filters.closeness[1];
                    
                    if (closenessSlider) {
                        closenessSlider.setValues(filters.closeness[0], filters.closeness[1]);
                    }
                    if (closenessSliderDisplay) {
                        closenessSliderDisplay.setValues(filters.closeness[0], filters.closeness[1]);
                    }
                    
                    const el = document.getElementById('closenessRangeValue');
                    if (el) el.textContent = `Range: ${filters.closeness[0]} – ${filters.closeness[1]}`;
                    const elDisplay = document.getElementById('closenessRangeValueDisplay');
                    if (elDisplay) elDisplay.textContent = `Range: ${filters.closeness[0]} – ${filters.closeness[1]}`;
                }
                if (filters.closenessScale) {
                    state.ui.filters.closenessScaleMin = filters.closenessScale[0];
                    state.ui.filters.closenessScaleMax = filters.closenessScale[1];
                    const minEl = document.getElementById('closenessScaleMin');
                    const maxEl = document.getElementById('closenessScaleMax');
                    const minElD = document.getElementById('closenessScaleMinDisplay');
                    const maxElD = document.getElementById('closenessScaleMaxDisplay');
                    if (minEl) minEl.value = filters.closenessScale[0];
                    if (maxEl) maxEl.value = filters.closenessScale[1];
                    if (minElD) minElD.value = filters.closenessScale[0];
                    if (maxElD) maxElD.value = filters.closenessScale[1];
                }
                
                updateGraphWithFilters();
            },
            
            getFilters: () => {
                return {
                    hours: [state.ui.filters.weeklyHoursMinPct, state.ui.filters.weeklyHoursMaxPct],
                    closeness: [state.ui.filters.closenessMin, state.ui.filters.closenessMax],
                    closenessScale: [state.ui.filters.closenessScaleMin ?? 1, state.ui.filters.closenessScaleMax ?? 7]
                };
            },
            
            onFiltersChanged: (callback) => {
                // Store the callback to be called when filters change
                if (!window.rangeFilterCallbacks) {
                    window.rangeFilterCallbacks = [];
                }
                window.rangeFilterCallbacks.push(callback);
            }
        };
        
        // Make API globally available
        window.setFilters = RangeFilterAPI.setFilters;
        window.getFilters = RangeFilterAPI.getFilters;
        window.onFiltersChanged = RangeFilterAPI.onFiltersChanged;
        
        // Call stored callbacks when filters change
        function notifyFilterChange() {
            if (window.rangeFilterCallbacks) {
                const filters = RangeFilterAPI.getFilters();
                window.rangeFilterCallbacks.forEach(callback => callback(filters));
            }
        }
        
        // localStorage persistence for range filters
        function saveRangeFiltersToStorage() {
            const filters = RangeFilterAPI.getFilters();
            localStorage.setItem('snq.filter.hours', JSON.stringify(filters.hours));
            localStorage.setItem('snq.filter.closeness', JSON.stringify(filters.closeness));
            localStorage.setItem('snq.filter.closenessScale', JSON.stringify(filters.closenessScale));
        }
        
        function loadRangeFiltersFromStorage() {
            // Don't load from localStorage if this is a new data upload
            if (state.ui.isNewDataUpload) {
                console.log('Skipping localStorage load for new data upload');
                return;
            }
            
            try {
                const hoursStr = localStorage.getItem('snq.filter.hours');
                const closenessStr = localStorage.getItem('snq.filter.closeness');
                
                if (hoursStr) {
                    const hours = JSON.parse(hoursStr);
                    if (Array.isArray(hours) && hours.length === 2) {
                        // clamp to [0,1]
                        state.ui.filters.weeklyHoursMinPct = Math.max(0, Math.min(1, hours[0]));
                        state.ui.filters.weeklyHoursMaxPct = Math.max(0, Math.min(1, hours[1]));
                    }
                }
                
                if (closenessStr) {
                    const closeness = JSON.parse(closenessStr);
                    if (Array.isArray(closeness) && closeness.length === 2) {
                        state.ui.filters.closenessMin = closeness[0];
                        state.ui.filters.closenessMax = closeness[1];
                    }
                }

                const scaleStr = localStorage.getItem('snq.filter.closenessScale');
                if (scaleStr) {
                    const scale = JSON.parse(scaleStr);
                    if (Array.isArray(scale) && scale.length === 2) {
                        state.ui.filters.closenessScaleMin = scale[0];
                        state.ui.filters.closenessScaleMax = scale[1];
                    }
                }
            } catch (error) {
                console.warn('Failed to load range filters from localStorage:', error);
            }
        }
        
        // Reset all state on page load to prevent carryover from previous sessions
        function resetStateOnPageLoad() {
            console.log('Resetting state on page load to prevent session carryover');
            console.log('Current zoomTransform before reset:', state.ui.zoomTransform);
            
            // Generate a new session ID to track this session
            state.ui.sessionId = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            console.log('New session ID:', state.ui.sessionId);
            
            // Clear localStorage to prevent old values from being loaded
            localStorage.removeItem('snq.filter.hours');
            localStorage.removeItem('snq.filter.closeness');
            localStorage.removeItem('sidebarWidth');
            localStorage.removeItem('wholeDataSidebarWidth');
            localStorage.removeItem('bottomDetailsHeight');
            console.log('Cleared localStorage to prevent session carryover');
            
            // Reset all filters
            state.ui.filters.gender.clear();
            state.ui.filters.race.clear();
            state.ui.filters.language.clear();
            state.ui.filters.kin.clear();
            state.ui.filters.contactMode.clear();
            state.ui.filters.ageCategory.clear();
            
            // Reset range filters to default values (normalized scales)
            state.ui.filters.weeklyHoursMinPct = 0;
            state.ui.filters.weeklyHoursMaxPct = 1; // 0–1 percent-of-week
            state.ui.filters.closenessMin = 0;
            state.ui.filters.closenessMax = 4; // 0–4 closeness score
            
            // Reset display options to defaults
            state.ui.colorBy = 'context';
            state.ui.nodeSizeBy = 'closeness_score';
            state.ui.layoutStyle = 'grouped';
            
            // Reset other UI state
            state.ui.selectedNode = null;
            state.ui.selectedContext = null;
            state.ui.detailsType = null;
            state.ui.zoomTransform = null; // Reset zoom state
            state.ui.isNewDataUpload = true; // Set to true for new session
            
            console.log('State reset complete for new session');
            console.log('zoomTransform after reset:', state.ui.zoomTransform);
        }

        // Reset all filters when new data is uploaded
        function resetAllFilters() {
            console.log('Resetting all filters for new data upload');
            console.log('Current filter state before reset:', {
                gender: Array.from(state.ui.filters.gender),
                race: Array.from(state.ui.filters.race),
                language: Array.from(state.ui.filters.language),
                kin: Array.from(state.ui.filters.kin),
                contactMode: Array.from(state.ui.filters.contactMode),
                ageCategory: Array.from(state.ui.filters.ageCategory)
            });
            
            // Reset all demographic filters
            state.ui.filters.gender.clear();
            state.ui.filters.race.clear();
            state.ui.filters.language.clear();
            state.ui.filters.kin.clear();
            state.ui.filters.contactMode.clear();
            state.ui.filters.ageCategory.clear();
            
            // Reset range filters to default values (normalized scales)
            state.ui.filters.weeklyHoursMinPct = 0;
            state.ui.filters.weeklyHoursMaxPct = 1; // 0–1 percent-of-week
            state.ui.filters.closenessMin = 0;
            state.ui.filters.closenessMax = 4; // 0–4 closeness score
            
            // Reset display options to defaults
            state.ui.colorBy = 'context';
            state.ui.nodeSizeBy = 'closeness_score';
            state.ui.layoutStyle = 'grouped';
            
            // Reset other UI state
            state.ui.selectedAlter = null;
            state.ui.selectedContext = null;
            state.ui.detailsType = null;
            state.ui.zoomTransform = null; // Reset zoom state for new data
            
            console.log('All filters and settings reset for new data');
            console.log('Filter state after reset:', {
                gender: Array.from(state.ui.filters.gender),
                race: Array.from(state.ui.filters.race),
                language: Array.from(state.ui.filters.language),
                kin: Array.from(state.ui.filters.kin),
                contactMode: Array.from(state.ui.filters.contactMode),
                ageCategory: Array.from(state.ui.filters.ageCategory)
            });
        }

        // Reset UI elements to reflect the reset state
        function resetUIElements() {
            console.log('Resetting UI elements to reflect reset state');
            
            // Reset dropdowns to default values
            const colorBySelect = document.getElementById('colorBySelect');
            const colorByMain = document.getElementById('colorBy');
            const sizeBySelect = document.getElementById('sizeBySelect');
            const sizeByMain = document.getElementById('nodeSizeBy');
            const layoutSelect = document.getElementById('layoutStyle');
            const layoutDisplay = document.getElementById('layoutStyleDisplayOptions');
            
            if (colorBySelect) colorBySelect.value = 'context';
            if (colorByMain) colorByMain.value = 'context';
            if (sizeBySelect) sizeBySelect.value = 'closeness_score';
            if (sizeByMain) sizeByMain.value = 'closeness_score';
            if (layoutSelect) layoutSelect.value = 'grouped';
            if (layoutDisplay) layoutDisplay.value = 'grouped';
            
            // Reset range filter inputs
            const weeklyHoursMin = document.getElementById('weeklyHoursMin');
            const weeklyHoursMax = document.getElementById('weeklyHoursMax');
            const closenessMin = document.getElementById('closenessMin');
            const closenessMax = document.getElementById('closenessMax');
            
            if (weeklyHoursMin) {
                weeklyHoursMin.value = 0;
                const weeklyHoursValue = document.getElementById('weeklyHoursValue');
                if (weeklyHoursValue) weeklyHoursValue.textContent = '0';
            }
            if (weeklyHoursMax) {
                weeklyHoursMax.value = 100;
                const weeklyHoursMaxValue = document.getElementById('weeklyHoursMaxValue');
                if (weeklyHoursMaxValue) weeklyHoursMaxValue.textContent = '100';
            }
            if (closenessMin) {
                closenessMin.value = 0;
                const closenessValue = document.getElementById('closenessValue');
                if (closenessValue) closenessValue.textContent = '0';
            }
            if (closenessMax) {
                closenessMax.value = 100;
                const closenessMaxValue = document.getElementById('closenessMaxValue');
                if (closenessMaxValue) closenessMaxValue.textContent = '100';
            }
            
            // Clear all checkboxes (they will be re-rendered when filters are initialized)
            const filterContainers = document.querySelectorAll('.filter-options');
            filterContainers.forEach(container => {
                const checkboxes = container.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(checkbox => {
                    checkbox.checked = false;
                });
            });
            
            // Hide details panels
            const alterSection = document.getElementById('alterDetailsSection');
            const unifiedDetails = document.getElementById('unifiedDetailsCard');
            const fixedDetails = document.getElementById('fixedDetailsPanel');
            
            if (alterSection) alterSection.style.display = 'none';
            if (unifiedDetails) unifiedDetails.style.display = 'none';
            if (fixedDetails) fixedDetails.style.display = 'none';
            
            console.log('UI elements reset to default state');
        }
        
        // Enhanced reset filters function (unified)
        function resetFilters() {
            // Reset categorical filters to include all current options
            if (state.current && state.current.filterOptions) {
                Object.entries(state.current.filterOptions).forEach(([key, vals]) => {
                    state.ui.filters[key] = new Set(vals || []);
                });
                // Ensure numeric checkbox filters are fully selected even if options missing
                state.ui.filters.closenessScore = new Set([0, 1, 2, 3, 4]);
                state.ui.filters.closenessScale = new Set([1, 2, 3, 4, 5, 6, 7]);
            }

            // Reset weekly hours range
            state.ui.filters.weeklyHoursMinPct = 0;
            state.ui.filters.weeklyHoursMaxPct = 1;
            if (typeof weeklyHoursSlider !== 'undefined' && weeklyHoursSlider) weeklyHoursSlider.setValues(0, 1);
            const whLabel = document.getElementById('weeklyHoursRangeValue');
            if (whLabel) whLabel.textContent = '0 - 1';

            // Reset closeness score range
            state.ui.filters.closenessMin = 0;
            state.ui.filters.closenessMax = 4;
            if (typeof closenessSlider !== 'undefined' && closenessSlider) closenessSlider.setValues(0, 4);
            const cLabel = document.getElementById('closenessRangeValue');
            if (cLabel) cLabel.textContent = '0 - 4';

            // Update all number input fields in both panels
            const hoursMinMain = document.getElementById('weeklyHoursMin');
            const hoursMaxMain = document.getElementById('weeklyHoursMax');
            const hoursMinDisp = document.getElementById('weeklyHoursMinDisplay');
            const hoursMaxDisp = document.getElementById('weeklyHoursMaxDisplay');
            if (hoursMinMain) hoursMinMain.value = 0;
            if (hoursMaxMain) hoursMaxMain.value = 1;
            if (hoursMinDisp) hoursMinDisp.value = 0;
            if (hoursMaxDisp) hoursMaxDisp.value = 1;

            const closeMinMain = document.getElementById('closenessMin');
            const closeMaxMain = document.getElementById('closenessMax');
            const closeMinDisp = document.getElementById('closenessMinDisplay');
            const closeMaxDisp = document.getElementById('closenessMaxDisplay');
            if (closeMinMain) closeMinMain.value = 0;
            if (closeMaxMain) closeMaxMain.value = 4;
            if (closeMinDisp) closeMinDisp.value = 0;
            if (closeMaxDisp) closeMaxDisp.value = 4;

            // Re-render all filter checkboxes to show all checked
            renderAllFilterOptions();

            // Explicitly check all boxes for closeness filters in both panels
            ['closenessScore', 'closenessScale'].forEach(type => {
                const container = document.getElementById(`${type}Filters`);
                const containerDisplay = document.getElementById(`${type}FiltersDisplay`);
                [container, containerDisplay].forEach(c => {
                    if (!c) return;
                    c.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = true; });
                });
            });

            // Save to storage and update visuals
            saveRangeFiltersToStorage();
            notifyFilterChange && notifyFilterChange();
            updateGraphWithFilters && updateGraphWithFilters();
            updateVisualization();
        }
  
        function populateFilterCheckboxes(containerId, values, filterType) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            values.forEach(value => {
                const div = document.createElement('div');
                div.className = 'checkbox-group';
                div.innerHTML = `
                    <input type="checkbox" id="${filterType}_${value}" checked onchange="toggleDemographicFilter('${filterType}', '${value}')">
                    <label for="${filterType}_${value}" style="margin: 0; font-size: 0.85rem;">${value}</label>
                `;
                container.appendChild(div);
                
                // Initialize filter set
                state.ui.filters[filterType].add(value);
            });
        }
  
        function formatMetric(value, decimals = 2, isPercent = false) {
            if (value === null || value === undefined || value === '' || isNaN(value)) {
                console.log(`formatMetric: returning '?' for value:`, value);
                return '?';
            }
            const num = parseFloat(value);
            if (isNaN(num)) {
                console.log(`formatMetric: parseFloat returned NaN for value:`, value);
                return '?';
            }
            if (isPercent) {
                return (num * 100).toFixed(1) + '%';
            }
            return num.toFixed(decimals);
        }
        
        // Helper function to clean childcare type text
        function formatChildcareType(childcareType) {
            if (!childcareType || childcareType === '') {
                return 'N/A';
            }
            
            // Split by commas and clean each type
            const types = childcareType.split(',').map(type => {
                // Remove content in parentheses and clean up
                let cleanType = type.trim();
                
                // Remove text in parentheses
                cleanType = cleanType.replace(/\([^)]*\)/g, '').trim();
                
                // Clean up common patterns
                cleanType = cleanType.replace(/^Day care center.*$/i, 'Day care center');
                cleanType = cleanType.replace(/^Licensed family day care.*$/i, 'Licensed family day care');
                cleanType = cleanType.replace(/^Family child care.*$/i, 'Family child care');
                cleanType = cleanType.replace(/^In-home care.*$/i, 'In-home care');
                cleanType = cleanType.replace(/^Nanny.*$/i, 'Nanny');
                cleanType = cleanType.replace(/^Au pair.*$/i, 'Au pair');
                cleanType = cleanType.replace(/^Relative.*$/i, 'Relative');
                cleanType = cleanType.replace(/^Other.*$/i, 'Other');
                
                return cleanType;
            }).filter(type => type.length > 0);
            
            return types.join(', ');
        }
  
        function updateNetworkStats() {
            // Only update sidebar stats content
            const sidebarStatsContent = document.getElementById('networkStatsContent');
            
            if (!state.current.childData) {
                // Show no data message in sidebar
                if (sidebarStatsContent) {
                    sidebarStatsContent.innerHTML = '<div style="color: #6c757d; font-style: italic; text-align: center; padding: 2rem;">Select a child to view network statistics</div>';
                }
                return;
            }
  
            const childData = state.current.childData;
            
            // Use ego_level_network_summary data directly, not computed from filtered view
            const networkSize = childData.network_size || '?';
            const networkDensity = formatMetric(childData.network_density, 3);
            const edgesNumber = childData.network_edges_number || childData.edges_number || '?';
            // Robust field access for components (handle case/spacing variations)
            const componentCountRaw = childData.network_component_count || childData.component_count || childData.Component_Count || childData['component count'];
            const componentRatioRaw = childData.network_component_ratio || childData.component_ratio || childData.Component_Ratio || childData['component ratio'];
            
            console.log('Component debugging:');
            console.log('component_count value:', componentCountRaw);
            console.log('component_ratio value:', componentRatioRaw);
            console.log('Child data keys:', Object.keys(childData));
            
            const componentCount = componentCountRaw || '?';
            const componentRatio = formatMetric(componentRatioRaw, 3);
            const propAdult = formatMetric(childData.network_prop_adult_relationship || childData.prop_adult_relationship, 1, true);
            const propKin = formatMetric(childData.network_prop_kin_relationship || childData.prop_kin_relationship, 1, true);
            const raceEntropy = formatMetric(childData.network_racial_entropy || childData.race_entropy, 2);
            const racialEI = formatMetric(childData.network_racial_ei_index || childData.racial_ei_index, 2);
            const languageEntropy = formatMetric(childData.network_language_entropy || childData.language_entropy, 2);
            const linguisticEI = formatMetric(childData.network_linguistic_ei_index || childData.linguistic_ei_index, 2);
            const surveyRespondent = childData.survey_respondent || childData.Survey_Respondent || childData['survey respondent'] || childData['survey_respondent'] || '?';
            
            // New network statistics fields
            const racialPLabels = childData.network_racial_p_labels || '?';
            const racialPVector = childData.network_racial_p_vector || '?';
            const racialIngroup = childData.network_racial_ingroup || '?';
            const racialOutgroup = childData.network_racial_outgroup || '?';
            const languagePLabels = childData.network_language_p_labels || '?';
            const languagePVector = childData.network_language_p_vector || '?';
            const languageIngroup = childData.network_lang_ingroup || '?';
            const languageOutgroup = childData.network_lang_outgroup || '?';
            const sizeValidLang = childData.network_size_valid_lang || '?';
            // 75% cutoff fields removed
            
            // Helper: render a 2-column table from label/vector strings
            const renderLabelVectorTable = (labelsRaw, vectorRaw) => {
                const cleanParen = (s) => String(s || '')
                    .replace(/^.*?\(/, '(')
                    .replace(/^[\s(]+/, '')
                    .replace(/[\s)]+$/, '')
                    .trim();
                const splitLabels = (s) => cleanParen(s)
                    .split(';')
                    .map(x => x.trim())
                    .filter(x => x.length > 0);
                const labels = splitLabels(labelsRaw);
                const vectorClean = String(vectorRaw || '')
                    .replace(/^[^\(]*\(/, '(')
                    .replace(/^[\s(]+/, '')
                    .replace(/[\s)]+$/, '')
                    .replace(/X\s*=\s*/i, '');
                const vectors = vectorClean
                    .split(/;|,/)
                    .map(v => v.trim())
                    .filter(v => v.length > 0)
                    .map(v => {
                        const n = parseFloat(v);
                        return isNaN(n) ? v : n.toFixed(4);
                    });
                const n = Math.min(labels.length, vectors.length);
                if (n === 0) return '<span>—</span>';
                const rows = [];
                for (let i = 0; i < n; i++) {
                    rows.push(`<tr>
                        <td style="padding:4px 6px; vertical-align:top;">${labels[i]}</td>
                        <td style="padding:4px 6px; text-align:right; white-space:nowrap; font-variant-numeric: tabular-nums;">${vectors[i]}</td>
                    </tr>`);
                }
                return `<table style="width:100%; border-collapse:separate; border-spacing:0 4px; font-size:0.9rem;">
                    <colgroup><col style=\"width:auto;\"><col style=\"width:90px;\"></colgroup>
                    <thead><tr><th style=\"text-align:left; padding:2px 6px;\">Label</th><th style=\"text-align:right; padding:2px 6px;\">P</th></tr></thead>
                    <tbody>${rows.join('')}</tbody>
                </table>`;
            };

            const racialPTable = renderLabelVectorTable(racialPLabels, racialPVector);
            const languagePTable = renderLabelVectorTable(languagePLabels, languagePVector);

            // Update the sidebar stats section
            if (sidebarStatsContent) {
                sidebarStatsContent.innerHTML = `
                    <div style="font-size: 0.9rem; line-height: 1.5; display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                        <div title="Person who completed the survey"><strong>Survey Respondent:</strong> ${surveyRespondent}</div>
                        <div title="Total number of alters in network"><strong>Size:</strong> ${networkSize}</div>
                        <div title="Network density: edges / possible edges"><strong>Density:</strong> ${networkDensity}</div>
                        <div title="Number of connections between alters"><strong>Edges:</strong> ${edgesNumber}</div>
                        <div title="Number of disconnected network components"><strong>Components:</strong> ${componentCount}</div>
                        <div title="Network fragmentation measure"><strong>Component Ratio:</strong> ${componentRatio}</div>
                        <div title="Percentage of adult relationships"><strong>% Adult:</strong> ${propAdult}</div>
                        <div title="Percentage of kin relationships"><strong>% Kin:</strong> ${propKin}</div>
                        
                        <div class=\"stat-section-title\">Race</div>
                        <div title=\"Shannon entropy of racial diversity\"><strong>Race Entropy:</strong> ${raceEntropy}</div>
                        <div title=\"Racial homophily index\"><strong>Racial EI:</strong> ${racialEI}</div>
                        <div title=\"Racial probability\" style=\"grid-column: span 2;\"><strong>Racial P:</strong><div style=\"margin-top:4px;\">${racialPTable}</div></div>
                        <div title=\"Racial groups\" style=\"grid-column: span 2; display:flex; gap:1.5rem;\"><div><strong>Racial In-group#:</strong> ${racialIngroup}</div><div><strong>Racial Out-group#:</strong> ${racialOutgroup}</div></div>
                        
                        <div class=\"stat-section-title\">Language</div>
                        <div title=\"Shannon entropy of language diversity\"><strong>Language Entropy:</strong> ${languageEntropy}</div>
                        <div title=\"Language homophily index\"><strong>Linguistic EI:</strong> ${linguisticEI}</div>
                        <div title=\"Language probability\" style=\"grid-column: span 2;\"><strong>Language P:</strong><div style=\"margin-top:4px;\">${languagePTable}</div></div>
                        <div title=\"Language groups\" style=\"grid-column: span 2; display:flex; gap:1.5rem;\"><div><strong>Language In-group# :</strong> ${languageIngroup}</div><div><strong>Language Out-group#:</strong> ${languageOutgroup}</div></div>
                        <div title=\"Network size with valid language data\"><strong># of Valid node with lang:</strong> ${sizeValidLang}</div>
                        
                    </div>
                `;
            }
        }
  
        function updateColorBy() {
            const colorBy = document.getElementById('colorBySelect').value;
            console.log('updateColorBy called with:', colorBy);
            state.ui.colorBy = colorBy;
            // Sync with main controls dropdown
            const colorByMain = document.getElementById('colorBy');
            if (colorByMain) {
                colorByMain.value = colorBy;
            }
            if (state.current.nodeData && state.current.nodeData.length > 0) {
                console.log('Redrawing visualization with new color scheme');
                createGroupedVisualization();
                // Force legend update
                setTimeout(() => {
                    updateLegend();
                    updateSizeLegend();
                }, 100);
                // Ensure legend is visible after color change
                const legend = document.getElementById('legend');
                if (legend) {
                    legend.style.display = 'block';
                }
            } else {
                console.log('No alter data available for redraw');
            }
        }

        function updateSizeBy() {
            const sizeBy = document.getElementById('sizeBySelect').value;
            console.log('updateSizeBy called with:', sizeBy);
            state.ui.nodeSizeBy = sizeBy;
            // Sync with main controls dropdown
            const sizeByMain = document.getElementById('nodeSizeBy');
            if (sizeByMain) {
                sizeByMain.value = sizeBy;
            }
            if (state.current.nodeData && state.current.nodeData.length > 0) {
                console.log('Redrawing visualization with new size scheme');
                createGroupedVisualization();
                // Force legend update
                setTimeout(() => {
                    updateLegend();
                    updateSizeLegend();
                }, 100);
                // Ensure legend is visible after size change
                const legend = document.getElementById('legend');
                if (legend) {
                    legend.style.display = 'block';
                }
            } else {
                console.log('No alter data available for redraw');
            }
        }

        function updateColorByMain() {
            const colorBy = document.getElementById('colorBy').value;
            console.log('updateColorByMain called with:', colorBy);
            state.ui.colorBy = colorBy;
            // Sync with display options dropdown
            const colorBySelect = document.getElementById('colorBySelect');
            if (colorBySelect) {
                colorBySelect.value = colorBy;
            }
            if (state.current.nodeData && state.current.nodeData.length > 0) {
                console.log('Redrawing visualization with new color scheme');
                createGroupedVisualization();
                // Force legend update
                setTimeout(() => {
                    updateLegend();
                    updateSizeLegend();
                }, 100);
                // Ensure legend is visible after color change
                const legend = document.getElementById('legend');
                if (legend) {
                    legend.style.display = 'block';
                }
            } else {
                console.log('No alter data available for redraw');
            }
        }

        function updateSizeByMain() {
            const sizeBy = document.getElementById('nodeSizeBy').value;
            console.log('updateSizeByMain called with:', sizeBy);
            state.ui.nodeSizeBy = sizeBy;
            // Sync with display options dropdown
            const sizeBySelect = document.getElementById('sizeBySelect');
            if (sizeBySelect) {
                sizeBySelect.value = sizeBy;
            }
            if (state.current.nodeData && state.current.nodeData.length > 0) {
                console.log('Redrawing visualization with new size scheme');
                createGroupedVisualization();
                // Force legend update
                setTimeout(() => {
                    updateLegend();
                    updateSizeLegend();
                }, 100);
                // Ensure legend is visible after size change
                const legend = document.getElementById('legend');
                if (legend) {
                    legend.style.display = 'block';
                }
            } else {
                console.log('No alter data available for redraw');
            }
        }

        function resetDisplayOptions() {
            // Defaults
            state.ui.colorBy = 'context';
            state.ui.nodeSizeBy = 'default';
            state.ui.layoutStyle = 'grouped';
            state.ui.edgeVisibility = 'all';
            state.ui.visibleContexts = new Set(Object.keys(CONTEXTS));
            const colorSelect = document.getElementById('colorBySelect');
            const sizeSelect = document.getElementById('sizeBySelect');
            if (colorSelect) colorSelect.value = 'context';
            if (sizeSelect) sizeSelect.value = 'default';
            const layoutSelNew = document.getElementById('layoutStyleDisplayOptions');
            if (layoutSelNew) layoutSelNew.value = 'grouped';
            const layoutSelOld = document.getElementById('layoutStyle');
            if (layoutSelOld) layoutSelOld.value = 'grouped';
            const edgeSelNew = document.getElementById('edgeVisibilityDisplayOptions');
            if (edgeSelNew) edgeSelNew.value = 'all';
            const edgeSelOld = document.getElementById('edgeVisibility');
            if (edgeSelOld) edgeSelOld.value = 'all';
            // Rebuild context toggles (both places)
            initializeContextToggles();
            if (typeof renderContextTogglesDisplayOptions === 'function') renderContextTogglesDisplayOptions();
            if (state.current.child) {
                createGroupedVisualization();
            }
        }

        // Preserve display options and filters when switching children
        function preserveSettingsAndInitializeFilters() {
            console.log('Preserving display options and filters for new child');
            console.log('isNewDataUpload flag:', state.ui.isNewDataUpload);
            
            // Keep current display options (colorBy, nodeSizeBy, layoutStyle, etc.)
            // Don't reset them - they should carry over to the new child
            console.log('Preserved settings:', {
                colorBy: state.ui.colorBy,
                nodeSizeBy: state.ui.nodeSizeBy,
                layoutStyle: state.ui.layoutStyle
            });
            
            // Preserve range filters as well
            console.log('Preserved range filters:', {
                weeklyHoursMinPct: state.ui.filters.weeklyHoursMinPct,
                weeklyHoursMaxPct: state.ui.filters.weeklyHoursMaxPct,
                closenessMin: state.ui.filters.closenessMin,
                closenessMax: state.ui.filters.closenessMax
            });
            
            // Preserve categorical filter selections
            console.log('Preserved categorical filters:', {
                gender: Array.from(state.ui.filters.gender),
                race: Array.from(state.ui.filters.race),
                language: Array.from(state.ui.filters.language),
                kin: Array.from(state.ui.filters.kin),
                contactMode: Array.from(state.ui.filters.contactMode),
                ageCategory: Array.from(state.ui.filters.ageCategory)
            });
            
            // Reset categorical filters on child switch so all values are shown by default
            state.ui.filters.gender = new Set();
            state.ui.filters.race = new Set();
            state.ui.filters.language = new Set();
            state.ui.filters.kin = new Set();
            state.ui.filters.accent = new Set();
            state.ui.filters.contactMode = new Set();
            state.ui.filters.ageCategory = new Set();
            state.ui.filters.closenessScore = new Set();
            state.ui.filters.closenessScale = new Set();
            state.ui.filters.weeklyHoursBucket = new Set();
            
            // Update UI elements to reflect the preserved state
            updateUIFromPreservedSettings();
            
            // Ensure dropdowns reflect the preserved settings
            const colorBySelect = document.getElementById('colorBySelect');
            const colorByMain = document.getElementById('colorBy');
            const sizeBySelect = document.getElementById('sizeBySelect');
            const sizeByMain = document.getElementById('nodeSizeBy');
            const layoutSelect = document.getElementById('layoutStyle');
            const layoutDisplay = document.getElementById('layoutStyleDisplayOptions');
            
            if (colorBySelect) colorBySelect.value = state.ui.colorBy;
            if (colorByMain) colorByMain.value = state.ui.colorBy;
            if (sizeBySelect) sizeBySelect.value = state.ui.nodeSizeBy;
            if (sizeByMain) sizeByMain.value = state.ui.nodeSizeBy;
            if (layoutSelect) layoutSelect.value = state.ui.layoutStyle;
            if (layoutDisplay) layoutDisplay.value = state.ui.layoutStyle;
        }

        // Update UI elements from preserved settings
        function updateUIFromPreservedSettings() {
            // Update range filter inputs
            const weeklyHoursMinEl = document.getElementById('weeklyHoursMin');
            const weeklyHoursMaxEl = document.getElementById('weeklyHoursMax');
            const closenessMinEl = document.getElementById('closenessMin');
            const closenessMaxEl = document.getElementById('closenessMax');
            
            if (weeklyHoursMinEl) weeklyHoursMinEl.value = state.ui.filters.weeklyHoursMinPct;
            if (weeklyHoursMaxEl) weeklyHoursMaxEl.value = state.ui.filters.weeklyHoursMaxPct;
            if (closenessMinEl) closenessMinEl.value = state.ui.filters.closenessMin;
            if (closenessMaxEl) closenessMaxEl.value = state.ui.filters.closenessMax;
            
            // Update range filter display inputs
            const weeklyHoursMinDisplayEl = document.getElementById('weeklyHoursMinDisplay');
            const weeklyHoursMaxDisplayEl = document.getElementById('weeklyHoursMaxDisplay');
            const closenessMinDisplayEl = document.getElementById('closenessMinDisplay');
            const closenessMaxDisplayEl = document.getElementById('closenessMaxDisplay');
            
            if (weeklyHoursMinDisplayEl) weeklyHoursMinDisplayEl.value = state.ui.filters.weeklyHoursMinPct;
            if (weeklyHoursMaxDisplayEl) weeklyHoursMaxDisplayEl.value = state.ui.filters.weeklyHoursMaxPct;
            if (closenessMinDisplayEl) closenessMinDisplayEl.value = state.ui.filters.closenessMin;
            if (closenessMaxDisplayEl) closenessMaxDisplayEl.value = state.ui.filters.closenessMax;
            
            // Update range labels
            const weeklyHoursLabel = document.getElementById('weeklyHoursRangeValue');
            const closenessLabel = document.getElementById('closenessRangeValue');
            if (weeklyHoursLabel) weeklyHoursLabel.textContent = `${state.ui.filters.weeklyHoursMinPct} - ${state.ui.filters.weeklyHoursMaxPct}`;
            if (closenessLabel) closenessLabel.textContent = `${state.ui.filters.closenessMin} - ${state.ui.filters.closenessMax}`;
            // sync closeness scale inputs if present
            const csMin = document.getElementById('closenessScaleMin');
            const csMax = document.getElementById('closenessScaleMax');
            if (csMin) csMin.value = state.ui.filters.closenessScaleMin ?? 1;
            if (csMax) csMax.value = state.ui.filters.closenessScaleMax ?? 7;
        }

        // Update UI elements after reset
        function updateUIFromReset() {
            // Update range filter inputs
            const weeklyHoursMinEl = document.getElementById('weeklyHoursMin');
            const weeklyHoursMaxEl = document.getElementById('weeklyHoursMax');
            const closenessMinEl = document.getElementById('closenessMin');
            const closenessMaxEl = document.getElementById('closenessMax');
            
            if (weeklyHoursMinEl) weeklyHoursMinEl.value = state.ui.filters.weeklyHoursMinPct;
            if (weeklyHoursMaxEl) weeklyHoursMaxEl.value = state.ui.filters.weeklyHoursMaxPct;
            if (closenessMinEl) closenessMinEl.value = state.ui.filters.closenessMin;
            if (closenessMaxEl) closenessMaxEl.value = state.ui.filters.closenessMax;
            
            // Update range filter display inputs
            const weeklyHoursMinDisplayEl = document.getElementById('weeklyHoursMinDisplay');
            const weeklyHoursMaxDisplayEl = document.getElementById('weeklyHoursMaxDisplay');
            const closenessMinDisplayEl = document.getElementById('closenessMinDisplay');
            const closenessMaxDisplayEl = document.getElementById('closenessMaxDisplay');
            
            if (weeklyHoursMinDisplayEl) weeklyHoursMinDisplayEl.value = state.ui.filters.weeklyHoursMinPct;
            if (weeklyHoursMaxDisplayEl) weeklyHoursMaxDisplayEl.value = state.ui.filters.weeklyHoursMaxPct;
            if (closenessMinDisplayEl) closenessMinDisplayEl.value = state.ui.filters.closenessMin;
            if (closenessMaxDisplayEl) closenessMaxDisplayEl.value = state.ui.filters.closenessMax;
            
            // Update range labels
            const weeklyHoursLabel = document.getElementById('weeklyHoursRangeValue');
            const closenessLabel = document.getElementById('closenessRangeValue');
            if (weeklyHoursLabel) weeklyHoursLabel.textContent = '0 - 1';
            if (closenessLabel) closenessLabel.textContent = '0 - 4';
        }

        function updateContextFilter() {
            const contextFilter = document.getElementById('contextFilter').value;
            state.ui.contextFilter = contextFilter;
            if (state.current.nodeData && state.current.nodeData.length > 0) {
                createGroupedVisualization();
            }
        }

        function updateTieStrengthFilter() {
            const tieStrength = document.getElementById('tieStrengthSlider').value;
            document.getElementById('tieStrengthValue').textContent = tieStrength === '0' ? 'All' : tieStrength;
            state.ui.tieStrengthFilter = tieStrength;
            if (state.current.nodeData && state.current.nodeData.length > 0) {
                createGroupedVisualization();
            }
        }

        function updateVisualization() {
            const layoutMain = document.getElementById('layoutStyle');
            const layoutDisplay = document.getElementById('layoutStyleDisplayOptions');
            state.ui.layoutStyle = (layoutDisplay && layoutDisplay.value) || (layoutMain && layoutMain.value) || state.ui.layoutStyle;
            if (layoutMain && layoutDisplay && layoutMain.value !== layoutDisplay.value) {
                layoutMain.value = layoutDisplay.value;
            }
            state.ui.nodeSizeBy = document.getElementById('nodeSizeBy').value;
            state.ui.colorBy = document.getElementById('colorBy').value;
            
            if (state.current.child) {
                createGroupedVisualization();
            }
        }

        function syncLayoutStyle() {
            const layoutDisplay = document.getElementById('layoutStyleDisplayOptions');
            const layoutMain = document.getElementById('layoutStyle');
            if (layoutDisplay && layoutMain) {
                layoutMain.value = layoutDisplay.value;
                // Update the layout style in state without resetting other settings
                state.ui.layoutStyle = layoutDisplay.value;
                // Only redraw the visualization without resetting color/size settings
                if (state.current.child) {
                    createGroupedVisualization();
                }
            }
        }
        
        function changeLayoutStyle() {
            const layoutSelect = document.getElementById('layoutStyle');
            if (layoutSelect) {
                // Update the layout style in state without resetting other settings
                state.ui.layoutStyle = layoutSelect.value;
                // Only redraw the visualization without resetting color/size settings
                if (state.current.child) {
                    createGroupedVisualization();
                }
            }
        }
        
        function takeScreenshot(format) {
            // Check if there's a visualization to capture
            if (!state.current.child || !state.current.nodeData) {
                alert('Please select a child and visualize the network first.');
                return;
            }
            
            // Get selected format if not provided
            if (!format) {
            const formatSelect = document.getElementById('exportFormat');
            if (!formatSelect) {
                alert('Export format selector not found.');
                return;
            }
                format = formatSelect.value;
            }
            
            // For SVG format, export directly (this always works)
            if (format === 'svg') {
                const svg = document.getElementById('networkSvg');
                const legend = document.getElementById('legend');
                
                if (!svg) {
                    alert('No network visualization found. Please visualize a network first.');
                    return;
                }
                
                // Clone the SVG to avoid modifying the original
                const svgClone = svg.cloneNode(true);
                
                // If legend exists, add it to the SVG
                if (legend) {
                    const legendClone = legend.cloneNode(true);
                    legendClone.style.position = 'absolute';
                    legendClone.style.top = '20px';
                    legendClone.style.right = '20px';
                    legendClone.style.backgroundColor = 'white';
                    legendClone.style.padding = '10px';
                    legendClone.style.borderRadius = '8px';
                    legendClone.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
                    
                    // Create a foreignObject to embed the legend in SVG
                    const foreignObject = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
                    foreignObject.setAttribute('x', svg.getAttribute('width') - 200);
                    foreignObject.setAttribute('y', '20');
                    foreignObject.setAttribute('width', '180');
                    foreignObject.setAttribute('height', '200');
                    
                    // Convert legend to HTML string
                    const legendHTML = legendClone.outerHTML;
                    foreignObject.innerHTML = legendHTML;
                    
                    svgClone.appendChild(foreignObject);
                }
                
                const svgData = new XMLSerializer().serializeToString(svgClone);
                const svgBlob = new Blob([svgData], {type: 'image/svg+xml;charset=utf-8'});
                const svgUrl = URL.createObjectURL(svgBlob);
                
                const link = document.createElement('a');
                const childName = state.current.childData?.child_name || 'Unknown';
                const layoutStyle = state.ui.layoutStyle || 'grouped';
                const colorBy = state.ui.colorBy || 'default';
                const timestamp = new Date().toISOString().slice(0, 10);
                
                link.download = `network_${childName}_${layoutStyle}_${colorBy}_${timestamp}.svg`;
                link.href = svgUrl;
                link.click();
                
                URL.revokeObjectURL(svgUrl);
                alert('SVG saved successfully!');
                return;
            }
            
            // For PNG/JPG, capture the visualization area including the legend
            try {
                // Hide the sidebar temporarily
                const sidebar = document.querySelector('.sidebar');
                const originalSidebarDisplay = sidebar ? sidebar.style.display : 'none';
                if (sidebar) {
                    sidebar.style.display = 'none';
                }
                
                // Hide the screenshot controls temporarily
                const screenshotControls = document.querySelector('.screenshot-controls');
                const originalControlsDisplay = screenshotControls ? screenshotControls.style.display : 'none';
                if (screenshotControls) {
                    screenshotControls.style.display = 'none';
                }
                
                // Hide the bottom details panel temporarily
                const bottomDetails = document.getElementById('bottomDetails');
                const originalBottomDetailsDisplay = bottomDetails ? bottomDetails.style.display : 'none';
                if (bottomDetails) {
                    bottomDetails.style.display = 'none';
                }
                
                // Wait a moment for the layout to adjust
                setTimeout(() => {
                    // Create a container that includes both the network and legend
                    const networkContainer = document.createElement('div');
                    networkContainer.style.position = 'relative';
                    networkContainer.style.width = '100%';
                    networkContainer.style.minHeight = '100vh';
                    networkContainer.style.backgroundColor = 'white';
                    networkContainer.style.overflow = 'visible';
                    
                    // Get the network SVG
                    const svg = document.getElementById('networkSvg');
                    const legend = document.getElementById('legend');
                    
                    if (!svg) {
                        alert('No network visualization found. Please visualize a network first.');
                        restoreElements();
                        return;
                    }
                    
                    // Clone the SVG and legend
                    const svgClone = svg.cloneNode(true);
                    const legendClone = legend ? legend.cloneNode(true) : null;
                    
                    // Position the legend on the cloned SVG
                    if (legendClone) {
                        legendClone.style.position = 'absolute';
                        legendClone.style.top = '20px';
                        legendClone.style.right = '20px';
                        legendClone.style.zIndex = '1000';
                        legendClone.style.backgroundColor = 'white';
                        legendClone.style.padding = '10px';
                        legendClone.style.borderRadius = '8px';
                        legendClone.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
                        legendClone.style.display = 'block';
                    }
                    
                    // Add clones to container
                    networkContainer.appendChild(svgClone);
                    if (legendClone) {
                        networkContainer.appendChild(legendClone);
                    }
                    
                    // Temporarily add to body for capture
                    document.body.appendChild(networkContainer);
                    
                    // Use html2canvas to capture the container
                    html2canvas(networkContainer, {
                        backgroundColor: 'white',
                        scale: 2,
                        useCORS: true,
                        allowTaint: true,
                        logging: false,
                        width: networkContainer.scrollWidth,
                        height: networkContainer.scrollHeight,
                        scrollX: 0,
                        scrollY: 0,
                        windowWidth: networkContainer.scrollWidth,
                        windowHeight: networkContainer.scrollHeight
                    }).then(canvas => {
                        // Create download link
                        const dataURL = format === 'jpg' ? 
                            canvas.toDataURL('image/jpeg', 0.9) : 
                            canvas.toDataURL('image/png', 1.0);
                        
                        const link = document.createElement('a');
                        link.href = dataURL;
                        
                        // Set filename
                        const childName = state.current.childData?.child_name || 'Unknown';
                        const layoutStyle = state.ui.layoutStyle || 'grouped';
                        const colorBy = state.ui.colorBy || 'default';
                        const timestamp = new Date().toISOString().slice(0, 10);
                        const fileExtension = format === 'jpg' ? 'jpg' : 'png';
                        
                        link.download = `network_${childName}_${layoutStyle}_${colorBy}_${timestamp}.${fileExtension}`;
                        link.click();
                        
                        // Clean up
                        document.body.removeChild(networkContainer);
                        restoreElements();
                        alert('Screenshot saved successfully!');
                    }).catch(error => {
                        console.error('Screenshot error:', error);
                        alert('Error taking screenshot. Please try again.');
                        if (document.body.contains(networkContainer)) {
                            document.body.removeChild(networkContainer);
                        }
                        restoreElements();
                    });
                }, 100);
                
                function restoreElements() {
                    // Restore sidebar
                    if (sidebar) {
                        sidebar.style.display = originalSidebarDisplay;
                    }
                    // Restore screenshot controls
                    if (screenshotControls) {
                        screenshotControls.style.display = originalControlsDisplay;
                    }
                    // Restore bottom details
                    if (bottomDetails) {
                        bottomDetails.style.display = originalBottomDetailsDisplay;
                    }
                }
            } catch (error) {
                console.error('Screenshot error:', error);
                alert('Error taking screenshot. Please try again.');
            }
        }
        
        // Header control functions for child page
        function toggleHeader() {
            const breadcrumb = document.getElementById('breadcrumb');
            const toggleIcon = document.getElementById('toggleIcon');
            
            if (!breadcrumb || !toggleIcon) {
                console.error('Header elements not found');
                return;
            }
            
            if (breadcrumb.classList.contains('collapsed')) {
                breadcrumb.classList.remove('collapsed');
                toggleIcon.textContent = '▼';
            } else {
                breadcrumb.classList.add('collapsed');
                toggleIcon.textContent = '▲';
            }
        }
        
        function startHeaderDrag(event) {
            event.preventDefault();
            event.stopPropagation();
            
            const breadcrumb = document.getElementById('breadcrumb');
            if (!breadcrumb) return;
            
            // Store initial position
            const initialLeft = parseInt(breadcrumb.style.left) || 400;
            const initialTop = parseInt(breadcrumb.style.top) || 80;
            
            // Store mouse start position
            const mouseStartX = event.clientX;
            const mouseStartY = event.clientY;
            
            breadcrumb.classList.add('dragging');
            
            function onMouseMove(e) {
                const deltaX = e.clientX - mouseStartX;
                const deltaY = e.clientY - mouseStartY;
                
                const newLeft = initialLeft + deltaX;
                const newTop = initialTop + deltaY;
                
                // Keep within viewport bounds
                const maxLeft = window.innerWidth - breadcrumb.offsetWidth;
                const maxTop = window.innerHeight - breadcrumb.offsetHeight;
                
                breadcrumb.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
                breadcrumb.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';
            }
            
            function onMouseUp() {
                breadcrumb.classList.remove('dragging');
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }
  
        function createGroupedVisualization() {
            console.log('createGroupedVisualization called with', state.current.nodeData?.length || 0, 'alters');
            
            if (!state.current.nodeData || state.current.nodeData.length === 0) {
                console.log('No alter data available for visualization');
                return;
            }
            
            // Only show context visibility controls when in grouped layout
            const contextToggles = document.getElementById('contextToggles');
            const contextTogglesDisplay = document.getElementById('contextTogglesDisplayOptions');
            const isGrouped = state.ui.layoutStyle === 'grouped';
            if (contextToggles) contextToggles.style.display = isGrouped ? 'block' : 'none';
            if (contextTogglesDisplay) contextTogglesDisplay.style.display = isGrouped ? 'block' : 'none';
  
            const svg = d3.select('#networkSvg');
            if (svg.empty()) {
                console.error('SVG element not found!');
                return;
            }
            
            // Show the network SVG and legend
            svg.style('display', 'block');
            
            // Hide welcome message
            const welcomeMessage = document.getElementById('welcomeMessage');
            if (welcomeMessage) {
                welcomeMessage.style.display = 'none';
            }
            
            // Show legend if it exists
            const legend = document.getElementById('legend');
            if (legend) {
                legend.style.display = 'block';
            }
            
            svg.selectAll('*').remove();
  
            const sidebar = document.getElementById('sidebar');
            const sidebarWidth = sidebar ? parseInt(getComputedStyle(sidebar).width, 10) : 340;
            const mainContent = document.querySelector('.main-content');
            
            // Set more reasonable default dimensions for better overview
            const maxWidth = 1000; // Cap the maximum width
            const maxHeight = 600; // Cap the maximum height
            const width = Math.min(window.innerWidth - sidebarWidth, maxWidth);
            const height = Math.min(window.innerHeight - 100, maxHeight); // Subtract 100px for UI elements
            
            // Add zoom behavior with better default scale
            const zoom = d3.zoom()
                .scaleExtent([0.5, 4]) // Allow more zoom range
                .on('zoom', (event) => {
                    container.attr('transform', event.transform);
                    // Store the current zoom transform in state
                    state.ui.zoomTransform = event.transform;
                    console.log('Zoom changed, stored transform:', event.transform);
                });
            
            svg.call(zoom);
            
            // Set SVG dimensions
            svg.attr('width', width).attr('height', height);
            
            const container = svg.append('g').attr('class', 'main-container');
            
            // Create explicit SVG layers in correct order
            const backgroundLayer = container.append('g').attr('class', 'background-layer');
            const edgesLayer = container.append('g').attr('class', 'edges-layer');
            const nodesLayer = container.append('g').attr('class', 'nodes-layer');
  
            // Group alters by context
            const contextGroups = groupAltersByContext(state.current.nodeData);
            
            // Create ego node - position it lower to give more space at top
            const ego = {
                id: 'ego',
                name: state.current.childData?.child_name || 'Child',
                x: width / 2,
                y: height / 2 + 80, // Move down 80px to give more space at top
                type: 'ego'
            };
  
            console.log('Layout style:', state.ui.layoutStyle, 'Context groups:', Object.keys(contextGroups));
            if (state.ui.layoutStyle === 'grouped') {
                console.log('Drawing grouped layout');
                drawGroupedLayout(container, ego, contextGroups, width, height);
            } else if (state.ui.layoutStyle === 'component') {
                console.log('Drawing component membership layout');
                drawComponentLayout(container, ego, contextGroups, width, height);
            } else {
                console.log('Drawing traditional layout');
                drawTraditionalLayout(container, ego, contextGroups, width, height);
            }
            
            // Apply zoom transform - preserve existing zoom or use default
            console.log('About to apply zoom transform. Current zoomTransform:', state.ui.zoomTransform);
            console.log('Zoom variable available:', typeof zoom);
            console.log('isNewDataUpload flag:', state.ui.isNewDataUpload);
            
            if (state.ui.zoomTransform && !state.ui.isNewDataUpload) {
                // Restore the previous zoom state only if not a new data upload
                console.log('Restoring zoom state:', state.ui.zoomTransform);
                svg.call(zoom.transform, state.ui.zoomTransform);
            } else {
                // Set a default zoom level for better overview
                const defaultScale = 0.7; // Start at 70% scale for better overview
                const defaultTransform = d3.zoomIdentity.scale(defaultScale).translate(0, 0);
                console.log('Using default zoom state:', defaultTransform);
                svg.call(zoom.transform, defaultTransform);
                // Store the default transform
                state.ui.zoomTransform = defaultTransform;
            }
            
            // Ensure info icons are present after visualization is created
            ensureInfoIcons();
            setTimeout(() => {
                ensureInfoIcons();
            }, 100);
        }
  
        function normId(x) {
            return String(x || '').trim().toLowerCase();
        }
  
        function edgeEnd(a, b, ra, rb) {
            const dx = b.x - a.x, dy = b.y - a.y;
            const d = Math.hypot(dx, dy) || 1;
            const ux = dx / d, uy = dy / d, pad = 2;
            return {
                x1: a.x + ux * (ra + pad), y1: a.y + uy * (ra + pad),
                x2: b.x - ux * (rb + pad), y2: b.y - uy * (rb + pad)
            };
        }
  
        function canonRace(r) {
            r = String(r || '').toLowerCase().trim();
            if (!r) return 'Other';
            
            // Handle comma-separated values by taking the first one
            if (r.includes(',')) {
                r = r.split(',')[0].trim();
            }
            
            if (r.includes('white')) return 'White';
            if (r.includes('black') || r.includes('african')) return 'Black';
            if (r.includes('hisp') || r.includes('latino') || r.includes('latinx')) return 'Hispanic/Latino';
            if (r.includes('asian')) return 'Asian';
            if (r.includes('native') && (r.includes('american') || r.includes('alaska'))) return 'Native/Alaska';
            if (r.includes('middle east') || r.includes('mena') || r.includes('north africa')) return 'MENA';
            if (r.includes('mixed') || r.includes('multi')) return 'Multiracial';
            return 'Other';
        }
  
        function canonKin(v) {
            const s = String(v || '').toLowerCase().trim();
            if (s === '1' || s === 'y' || s === 'yes' || s === 'true') return 'Yes';
            return 'No';
        }
  
        function parseContactContext(contextText) {
            if (!contextText) return 'Unknown';
            
            // Split by semicolon and process each part
            const parts = String(contextText).split(/[;,]/).map(part => part.trim()).filter(part => part.length > 0);
            const contexts = new Set(); // Use Set to avoid duplicates
            
            parts.forEach(part => {
                const text = part.toLowerCase();
                
                if (text.includes('at home') || text.includes('family member who lives at home')) {
                    contexts.add('At home');
                } else if (text.includes('extended family')) {
                    contexts.add('Extended Family');
                } else if (text.includes('daycare') || text.includes('school')) {
                    contexts.add('Daycare/School');
                } else if (text.includes('activity1') || text.includes('activity 1')) {
                    contexts.add('Activity 1');
                } else if (text.includes('activity2') || text.includes('activity 2')) {
                    contexts.add('Activity 2');
                } else if (text.includes('activity3') || text.includes('activity 3')) {
                    contexts.add('Activity 3');
                } else if (text.includes('activity4') || text.includes('activity 4')) {
                    contexts.add('Activity 4');
                } else if (text.includes('activity5') || text.includes('activity 5')) {
                    contexts.add('Activity 5');
                } else if (text.includes('activity6') || text.includes('activity 6')) {
                    contexts.add('Activity 6');
                } else if (text.includes('activity7') || text.includes('activity 7')) {
                    contexts.add('Activity 7');
                } else if (part.trim().length > 0) {
                    // Only add "Other" if there's actual content that doesn't match any category
                    contexts.add('Other');
                }
            });
            
            // Return comma-separated list or "Unknown" if no contexts found
            return contexts.size > 0 ? Array.from(contexts).join(', ') : 'Unknown';
        }
  
        function parseAlterEdges(alterData) {
            const edges = [];
            const nodeMap = new Map();
            
            // Create mapping of normalized node_mapping_code to alter data
            alterData.forEach((alter, index) => {
                const originalId = alter.node_mapping_code || `alter_${index}`;
                const normalizedId = normId(originalId);
                if (normalizedId) {
                    nodeMap.set(normalizedId, { ...alter, originalId });
                }
            });
            
            // Parse node_mapping field to extract connections
            alterData.forEach((alter, index) => {
                const sourceOriginalId = alter.node_mapping_code || `alter_${index}`;
                const sourceId = normId(sourceOriginalId);
                const nodeMapping = alter.node_mapping;
                
                if (nodeMapping && typeof nodeMapping === 'string' && sourceId) {
                    // Parse the node_mapping field - support comma, semicolon, space separation
                    const connections = nodeMapping.split(/[,;\s]+/).filter(id => id.trim());
                    
                    connections.forEach(targetCode => {
                        const targetId = normId(targetCode);
                        if (targetId && targetId !== sourceId && nodeMap.has(targetId)) {
                            // Store edges with normalized endpoints
                            const edge = sourceId < targetId ? 
                                { source: sourceId, target: targetId } :
                                { source: targetId, target: sourceId };
                            
                            // Check if edge already exists
                            if (!edges.some(e => e.source === edge.source && e.target === edge.target)) {
                                edges.push(edge);
                            }
                        }
                    });
                }
            });
            
            return edges;
        }
  
        function applyFilters(alterData) {
            // Consider a categorical filter active only if not all options are selected
            const isActive = (type) => {
                const set = state.ui.filters[type];
                if (!set || set.size === 0) return false;
                const all = state.current.filterOptions?.[type] || [];
                // Robust domain for closeness filters irrespective of dynamic options
                if (type === 'closenessScore') {
                    return set.size < 5; // 0-4
                }
                if (type === 'closenessScale') {
                    return set.size < 7; // 1-7
                }
                return set.size < all.length;
            };
            return alterData.filter(alter => {
                // Gender filter
                if (isActive('gender') && !state.ui.filters.gender.has(alter.node_gender || 'Unknown')) {
                    console.warn('FILTER_DROP', {
                        child: state.current.child, 
                        id: alter.node_mapping_code, 
                        name: alter.node_name, 
                        reason: 'gender/no-match',
                        value: alter.node_gender
                    });
                    return false;
                }
                
                // Race filter (with canonicalization)
                if (isActive('race')) {
                    const canonicalRace = canonRace(alter.node_race);
                    if (!state.ui.filters.race.has(canonicalRace)) {
                        console.warn('FILTER_DROP', {
                            child: state.current.child, 
                            id: alter.node_mapping_code, 
                            name: alter.node_name, 
                            reason: 'race/no-match',
                            value: alter.node_race,
                            canonical: canonicalRace
                        });
                        return false;
                    }
                }
                
                // Language filter (multilingual support) - use new normLangList
                if (isActive('language')) {
                    const langs = new Set(normLangList(alter.node_language));
                    const has = [...state.ui.filters.language].some(opt => langs.has(String(opt).toLowerCase()));
                    if (!has) {
                        console.warn('FILTER_DROP', {
                            child: state.current.child, 
                            id: alter.node_mapping_code, 
                            name: alter.node_name, 
                            reason: 'language/no-intersection',
                            value: alter.node_language,
                            normalized: Array.from(langs)
                        });
                        return false;
                    }
                }

                // Accent filter (multi-value from node_accent_specific; case-insensitive)
                if (isActive('accent')) {
                    const accs = String(alter.node_accent_specific || '')
                        .split(';')
                        .map(s => s.trim().toLowerCase())
                        .filter(Boolean);
                    const accSet = new Set(accs);
                    const hasAccent = [...state.ui.filters.accent]
                        .some(opt => accSet.has(String(opt).toLowerCase()));
                    if (!hasAccent) {
                        return false;
                    }
                }

                // Closeness score checkbox filter (0–4)
                if (isActive('closenessScore')) {
                    const score = parseInt(alter.node_closeness_score ?? 0, 10);
                    if (!state.ui.filters.closenessScore.has(score)) {
                        return false;
                    }
                }
                // Closeness scale checkbox filter (1–7)
                if (isActive('closenessScale')) {
                    const scale = parseInt(alter.node_closeness_scale ?? 0, 10);
                    if (!state.ui.filters.closenessScale.has(scale)) {
                        return false;
                    }
                }
                
                // Kin filter (with canonicalization)
                if (isActive('kin')) {
                    const canonicalKin = canonKin(alter.node_kin);
                    if (!state.ui.filters.kin.has(canonicalKin)) {
                        console.warn('FILTER_DROP', {
                            child: state.current.child, 
                            id: alter.node_mapping_code, 
                            name: alter.node_name, 
                            reason: 'kin/no-match',
                            value: alter.node_kin,
                            canonical: canonicalKin
                        });
                        return false;
                    }
                }
                
                // Mode of contact filter
                if (isActive('contactMode') && !state.ui.filters.contactMode.has(alter.node_mode_of_contact || 'Unknown')) {
                    console.warn('FILTER_DROP', {
                        child: state.current.child, 
                        id: alter.node_mapping_code, 
                        name: alter.node_name, 
                        reason: 'contact-mode/no-match',
                        value: alter.node_mode_of_contact
                    });
                    return false;
                }
                
                // Contact context filter removed per UI update
                
                // Age category filter
                if (isActive('ageCategory') && !state.ui.filters.ageCategory.has(alter.node_age_categorized || 'Unknown')) {
                    console.warn('FILTER_DROP', {
                        child: state.current.child, 
                        id: alter.node_mapping_code, 
                        name: alter.node_name, 
                        reason: 'age-category/no-match',
                        value: alter.node_age_categorized
                    });
                    return false;
                }
                
                // Weekly hours percentage range filter (0-1)
                const weeklyHours = parseFloat(alter.node_weekly_hour_summarized || alter.node_weekly_hour || 0);
                const pct = isNaN(weeklyHours) ? 0 : Math.min(1, Math.max(0, weeklyHours / 168));
                // Optional bucket filter, if enabled
                if (isActive('weeklyHoursBucket')) {
                    const bucketLabel = (p => {
                        if (p < 0.05) return '0–5%';
                        if (p < 0.10) return '5–10%';
                        if (p < 0.20) return '10–20%';
                        if (p < 0.40) return '20–40%';
                        return '40–100%';
                    })(pct);
                    if (!state.ui.filters.weeklyHoursBucket.has(bucketLabel)) {
                        return false;
                    }
                }
                if (pct < state.ui.filters.weeklyHoursMinPct || pct > state.ui.filters.weeklyHoursMaxPct) {
                    console.warn('FILTER_DROP', {
                        child: state.current.child, 
                        id: alter.node_mapping_code, 
                        name: alter.node_name, 
                        reason: 'weekly-hours/out-of-range',
                        value_hours: weeklyHours,
                        value_pct: pct,
                        min_pct: state.ui.filters.weeklyHoursMinPct,
                        max_pct: state.ui.filters.weeklyHoursMaxPct
                    });
                    return false;
                }
                
                // Closeness score range filter (0-4)
                const closeness = parseFloat(alter.node_closeness_score || 0);
                if (closeness < state.ui.filters.closenessMin || closeness > state.ui.filters.closenessMax) {
                    console.warn('FILTER_DROP', {
                        child: state.current.child, 
                        id: alter.node_mapping_code, 
                        name: alter.node_name, 
                        reason: 'closeness/out-of-range',
                        value: closeness,
                        min: state.ui.filters.closenessMin,
                        max: state.ui.filters.closenessMax
                    });
                    return false;
                }
                
                return true;
            });
        }
  
        function groupAltersByContext(alterData) {
            console.log('groupAltersByContext called with', alterData?.length || 0, 'alters');
            // Apply filters first
            const filteredData = applyFilters(alterData);
            console.log('After filtering:', filteredData?.length || 0, 'alters remain');
            const groups = {};
            
            filteredData.forEach((alter, index) => {
                const context = canonContext(alter.node_type);
                const contextKey = getContextKey(context, alter);
                
                if (!groups[contextKey]) {
                    groups[contextKey] = {
                        context: context,
                        label: getContextLabel(context, alter),
                        color: getContextColor(context),
                        alters: []
                    };
                }
                
                groups[contextKey].alters.push({
                    id: normId(alter.node_mapping_code) || `alter_${index}`,
                    name: alter.node_name || `${alter.node_type}_${index}`,
                    data: alter,
                    context: context
                });
            });
  
            // Self-test for Orca child
            if (state.current.child === 'Orca') {
                const must = {
                    caregiver: ['Jolly'],
                    daycare: ['Amy','Willy'],
                    extended_family: ['Nana','Eugene'],
                    home: ['Molly','Tom'],
                    sibling: ['Bentley','Georgie'],
                    'activity_1': ['Jen','Gigi'],
                    'activity_2': ['Orleo','Joey'],
                    anyoneelse: ['Hookie']
                };
                const misses = [];
                for (const [ctx, names] of Object.entries(must)) {
                    const have = new Set((groups[ctx]?.alters||[]).map(a=>a.name));
                    names.forEach(n => { if (!have.has(n)) misses.push(`${ctx}:${n}`); });
                }
                if (misses.length) {
                    console.error('CONTEXT_ASSIGNMENT_FAIL', misses, {
                        preview: Object.fromEntries(Object.entries(groups).map(([k,v])=>[k,(v.alters||[]).map(a=>a.name)]))
                    });
                }
            }
  
            return groups;
        }
  
        function groupAltersByComponent(contextGroups) {
            // Extract all alters from context groups and regroup by node_component_group
            const componentGroups = {};
            
            Object.values(contextGroups).forEach(contextGroup => {
                contextGroup.alters.forEach(alter => {
                    const groupName = alter.data.node_component_group || alter.data.component_membership || 'Unlabeled';
                    
                    if (!componentGroups[groupName]) {
                        componentGroups[groupName] = {
                            componentId: groupName,
                            label: groupName,
                            color: getComponentColor(groupName),
                            alters: []
                        };
                    }
                    
                    componentGroups[groupName].alters.push(alter);
                });
            });
            
            return componentGroups;
        }
  
        function getComponentColor(componentId) {
            // Generate distinct colors for different component/group names (string-safe)
            const colors = ['#ffb3ba', '#ffdfba', '#baffc9', '#bae1ff', '#d4baff', '#ffb3d9', '#b3ffba'];
            const str = String(componentId || '0');
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash |= 0; // Convert to 32bit integer
            }
            const index = Math.abs(hash) % colors.length;
            return colors[index];
        }
  
        function determineContext(alter) {
            // Legacy wrapper - use canonContext instead
            return canonContext(alter.node_type);
        }
  
        function getContextKey(context, alter) {
            if (context.startsWith('activity_')) {
                const activityId = context.split('_')[1];
                const activityData = state.data.activityIndex[state.current.child]?.[activityId];
                return `activity_${activityId}_${activityData?.activity_name || 'Unknown'}`;
            }
            return context;
        }
  
        function getContextLabel(context, alter) {
            if (context.startsWith('activity_')) {
                const activityId = context.split('_')[1];
                const activityData = state.data.activityIndex[state.current.child]?.[activityId];
                return `Activity ${activityId}: ${activityData?.activity_name || 'Unknown'}`;
            }
            return CONTEXTS[context]?.label || context.charAt(0).toUpperCase() + context.slice(1);
        }
  
        function getContextColor(context) {
            if (context.startsWith('activity_')) {
                const activityId = context.split('_')[1];
                const activityNum = parseInt(activityId) - 1;
                return ACTIVITY_COLORS[activityNum % ACTIVITY_COLORS.length] || CONTEXTS.activity.color;
            }
            return CONTEXTS[context]?.color || CONTEXTS.anyoneelse.color;
        }
  
        function drawGroupedLayout(container, ego, contextGroups, width, height) {
            const groups = Object.entries(contextGroups).filter(([key, group]) => {
                const baseContext = group.context.startsWith('activity_') ? 'activity' : group.context;
                return state.ui.visibleContexts.has(baseContext);
            });
            
            console.log('Filtered groups for grouped layout:', groups.map(([k, g]) => k));
  
            // Calculate positions for context boxes
            const positions = calculateGroupPositions(groups.length, width, height, ego);
            
            // Create a map of alter IDs to their positions (will be populated after drawing context boxes)
            const alterPositions = new Map();
            
            // Get the explicit layers from the container
            const backgroundLayer = container.select('.background-layer');
            const edgesLayer = container.select('.edges-layer');
            const nodesLayer = container.select('.nodes-layer');
            
            // Removed ego-to-context dash lines for grouped layout as requested
            
            // Draw context boxes in background layer
            groups.forEach(([key, group], i) => {
                const pos = positions[i];
                drawContextBox(backgroundLayer, group, pos, key, alterPositions);
            });
            
            // Draw alter-alter edges in edges layer (above background, below nodes)
            if (state.current.nodeEdges.length > 0) {
                drawAlterEdges(edgesLayer, alterPositions);
            }
  
            // Draw ego node in nodes layer (on top)
            drawEgoNode(nodesLayer, ego);
            
            // Update legends
            updateLegend();
            updateSizeLegend();
        }
  
        function drawComponentLayout(container, ego, contextGroups, width, height) {
            // Group alters by component membership instead of context
            const componentGroups = groupAltersByComponent(contextGroups);
            
            // Calculate positions for component boxes
            const positions = calculateGroupPositions(Object.keys(componentGroups).length, width, height, ego);
            
            // Create a map of alter IDs to their positions
            const alterPositions = new Map();
            
            // Get the explicit layers from the container
            const backgroundLayer = container.select('.background-layer');
            const edgesLayer = container.select('.edges-layer');
            const nodesLayer = container.select('.nodes-layer');
            
            // Note: Ego-to-component connections removed for cleaner component view
            
            // Draw component boxes in background layer
            Object.entries(componentGroups).forEach(([componentId, group], i) => {
                const pos = positions[i];
                drawComponentBox(backgroundLayer, group, pos, componentId, alterPositions);
            });
            
            // Draw alter-alter edges in edges layer (above background, below nodes)
            if (state.current.nodeEdges.length > 0) {
                drawAlterEdges(edgesLayer, alterPositions);
            }
  
            // Draw ego node in nodes layer (on top)
            drawEgoNode(nodesLayer, ego);
            
            // Update legends
            updateLegend();
            updateSizeLegend();
        }
  
        function drawComponentBox(container, group, position, componentId, alterPositions) {
            // Similar to drawContextBox but for component membership
            const alters = group.alters;
            const boxPadding = 20;
            const nodeRadius = 25;
            const spacing = nodeRadius * 3.5; // INCREASED SPACING from 2.2 to 3.5
            
            // Calculate box dimensions - simplified since labels are inside circles
            const cols = Math.ceil(Math.sqrt(alters.length));
            const rows = Math.ceil(alters.length / cols);
            const minSpacing = 60; // Minimum distance between node centers
            const actualSpacing = Math.max(spacing, minSpacing);
            const boxWidth = Math.max(140, cols * actualSpacing + boxPadding * 2);
            const boxHeight = Math.max(80, rows * actualSpacing + boxPadding * 2 + 30);
            
            // Position box
            const boxX = position.x - boxWidth / 2;
            const boxY = position.y - boxHeight / 2;
            
            // Create component box group with drag functionality
            const boxGroup = container.append('g')
                .attr('class', 'component-box')
                .attr('data-component-id', componentId)
                .style('cursor', 'move');
            
            // Draw box background
            boxGroup.append('rect')
                .attr('x', boxX)
                .attr('y', boxY)
                .attr('width', boxWidth)
                .attr('height', boxHeight)
                .attr('rx', 12)
                .attr('ry', 12)
                .style('fill', group.color)
                .style('stroke', '#495057')
                .style('stroke-width', 2)
                .style('opacity', 0.8);
            
            // Draw box label
            boxGroup.append('text')
                .attr('x', position.x)
                .attr('y', boxY + 20)
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .style('fill', '#2c3e50')
                .text(group.label);
            
            // Position and draw alters within the box (same logic as drawContextBox)
            alters.forEach((alter, i) => {
                const col = i % cols;
                const row = Math.floor(i / cols);
                const alterX = boxX + boxPadding + col * actualSpacing + actualSpacing / 2;
                const alterY = boxY + boxPadding + 30 + row * actualSpacing + actualSpacing / 2;
                
                alter.x = alterX;
                alter.y = alterY;
                
                // Ensure alter.id is normalized consistently
                alter.id = normId(alter.data.node_mapping_code) || `alter_${i}`;
                
                // Store position for edge drawing
                if (alterPositions) {
                    alterPositions.set(alter.id, { x: alterX, y: alterY });
                }
                
                // Get node size and positioning info
                const nodeRadius = getNodeSize(alter);
                
                // Draw alter node (same as in drawContextBox)
                const alterGroup = boxGroup.append('g')
                    .attr('class', 'alter-node')
                    .datum({
                        id: alter.id,
                        x: alterX,
                        y: alterY,
                        data: alter.data,
                        name: alter.name
                    })
                    .style('cursor', 'pointer')
                    .on('click', (event) => {
                        event.stopPropagation();
                        selectAlterNode(alter);
                    });
  
                // Handle pie charts for multilingual nodes OR multi-race nodes
                let shouldDrawPieChart = false;
                let pieData = [];
                let piePalette = {};
                
                if (state.ui.colorBy === 'language') {
                    const languages = normalizeLanguage(alter.data.node_language);
                    if (languages.length > 1) {
                        shouldDrawPieChart = true;
                        pieData = languages;
                        piePalette = {
                            'English': '#1f77b4',
                            'German': '#ff7f0e', 
                            'Spanish': '#2ca02c',
                            'Portuguese': '#d62728',
                            'Italian': '#9467bd',
                            'Thai': '#8c564b',
                            'Pre-verbal/Non-verbal': '#7f7f7f',
                            'Unknown': '#cccccc'
                        };
                    }
                } else if (state.ui.colorBy === 'race') {
                    const races = normalizeRace(alter.data.node_race);
                    if (races.length > 1) {
                        shouldDrawPieChart = true;
                        pieData = races;
                        piePalette = {
                            'White': '#76b7b2',
                            'Black': '#59a14f',
                            'Hispanic/Latino': '#edc949',
                            'Asian': '#af7aa1',
                            'Native/Alaska': '#8dd3c7',
                            'MENA': '#fb8072',
                            'Multiracial': '#bc80bd',
                            'Other': '#d9d9d9'
                        };
                    }
                }
                
                if (shouldDrawPieChart) {
                    // Create clipPath for pie chart nodes
                    const clipId = `clip-${alter.id}`;
                    const defs = alterGroup.append('defs');
                    defs.append('clipPath')
                        .attr('id', clipId)
                        .append('circle')
                        .attr('cx', alterX)
                        .attr('cy', alterY)
                        .attr('r', nodeRadius);
                    
                    // Create pie wedges
                    const pieGroup = alterGroup.append('g')
                        .attr('clip-path', `url(#${clipId})`);
                    
                    const anglePerSlice = (2 * Math.PI) / pieData.length;
                    pieData.forEach((item, i) => {
                        const startAngle = i * anglePerSlice - Math.PI / 2; // Start from top
                        const endAngle = (i + 1) * anglePerSlice - Math.PI / 2;
                        
                        const x1 = alterX + nodeRadius * Math.cos(startAngle);
                        const y1 = alterY + nodeRadius * Math.sin(startAngle);
                        const x2 = alterX + nodeRadius * Math.cos(endAngle);
                        const y2 = alterY + nodeRadius * Math.sin(endAngle);
                        
                        const largeArcFlag = anglePerSlice > Math.PI ? 1 : 0;
                        const pathData = `M ${alterX} ${alterY} L ${x1} ${y1} A ${nodeRadius} ${nodeRadius} 0 ${largeArcFlag} 1 ${x2} ${y2} Z`;
                        
                        pieGroup.append('path')
                            .attr('d', pathData)
                            .style('fill', piePalette[item] || '#cccccc')
                            .style('stroke', 'none');
                    });
                    
                    // Add stroke around the whole circle
                    alterGroup.append('circle')
                        .attr('cx', alterX)
                        .attr('cy', alterY)
                        .attr('r', nodeRadius)
                        .style('fill', 'none')
                        .style('stroke', '#666666')
                        .style('stroke-width', 3);
                } else {
                    // Regular circle for single values or other color modes
                    let nodeColor = getNodeColor(alter, 'white');
                    const strokeColor = state.ui.colorBy === 'context' ? group.color : '#666666';
                    
                    // Only apply special highlighting for context mode when a node is selected
                    if (state.ui.colorBy === 'context' && state.ui.selectedAlter) {
                        // Check if this alter is connected to the selected alter
                        const isConnectedToSelected = state.current.nodeEdges.some(edge => 
                            (edge.source === alter.id && edge.target === state.ui.selectedAlter.id) ||
                            (edge.target === alter.id && edge.source === state.ui.selectedAlter.id)
                        );
                        
                        if (isConnectedToSelected) {
                            nodeColor = '#ffa500'; // Orange for alters connected to selected alter
                        } else {
                            nodeColor = 'white'; // White for other alters (context color)
                        }
                    }
                    
                    alterGroup.append('circle')
                        .attr('cx', alterX)
                        .attr('cy', alterY)
                        .attr('r', nodeRadius)
                        .style('fill', nodeColor)
                        .style('stroke', strokeColor)
                        .style('stroke-width', 3);
                }
                
                // Add label text INSIDE the circle with auto-fit
                const labelCore = alterGroup.append('text')
                    .attr('x', alterX)
                    .attr('y', alterY)
                    .style('text-anchor', 'middle')
                    .style('dominant-baseline', 'middle')
                    .style('font-size', '12px')
                    .style('font-weight', '600')
                    .style('fill', '#2c3e50')
                    .style('pointer-events', 'auto')
                    .style('cursor', 'pointer')
                    .style('text-shadow', '0 0 3px rgba(255,255,255,0.8)')
                    .text(getAnonymizedText(alter, false))
                    .on('click', (event) => {
                        event.stopPropagation();
                        selectAlterNode(alter);
                    });
                if (typeof fitTextToCircle === 'function') { fitTextToCircle(labelCore.node(), nodeRadius); }
  
                // Add metric label under name based on sizing mode
                if (state.ui.nodeSizeBy === 'weekly_hours') {
                    const weeklyHours = parseFloat(alter.data.node_weekly_hour_summarized || alter.data.node_weekly_hour || 0);
                    alterGroup.append('text')
                        .attr('x', alterX)
                        .attr('y', alterY + 8)
                        .style('text-anchor', 'middle')
                        .style('dominant-baseline', 'middle')
                        .style('font-size', '8px')
                        .style('font-weight', '400')
                        .style('fill', '#6c757d')
                        .style('pointer-events', 'none')
                        .text(`${weeklyHours}h`);
                } else if (state.ui.nodeSizeBy === 'closeness') {
                    const closeness = parseFloat(alter.data.node_closeness_score || 0);
                    alterGroup.append('text')
                        .attr('x', alterX)
                        .attr('y', alterY + 8)
                        .style('text-anchor', 'middle')
                        .style('dominant-baseline', 'middle')
                        .style('font-size', '8px')
                        .style('font-weight', '400')
                        .style('fill', '#6c757d')
                        .style('pointer-events', 'none')
                        .text(`${Math.round(isNaN(closeness) ? 0 : closeness)}`);
                } else if (state.ui.nodeSizeBy === 'closeness_intensity_z') {
                    const zScore = getClosenessIntensityZFromData(alter.data);
                    alterGroup.append('text')
                        .attr('x', alterX)
                        .attr('y', alterY + 8)
                        .style('text-anchor', 'middle')
                        .style('dominant-baseline', 'middle')
                        .style('font-size', '8px')
                        .style('font-weight', '400')
                        .style('fill', '#6c757d')
                        .style('pointer-events', 'none')
                        .text(zScore.toFixed(2));
                }
  
                // Add survey respondent indicator if applicable
                if (isShowingRespondent(alter)) {
                    alterGroup.classed('survey-respondent', true);
                }
            });
            
            // Add drag functionality to the component box
            let initialTransform = { x: 0, y: 0 };
            
            boxGroup.call(d3.drag()
                .on('start', function(event, d) {
                    d3.select(this).style('opacity', 0.8);
                    initialTransform.x = 0;
                    initialTransform.y = 0;
                })
                .on('drag', function(event, d) {
                    // Calculate relative movement from start of drag
                    initialTransform.x += event.dx;
                    initialTransform.y += event.dy;
                    
                    // Apply transform to follow mouse smoothly
                    d3.select(this).attr('transform', `translate(${initialTransform.x}, ${initialTransform.y})`);
                    
                    // Redraw edges that connect to this component
                    redrawAlterEdges();
                })
                .on('end', function(event, d) {
                    d3.select(this).style('opacity', 1);
                    
                    // Apply final displacement to position and alter data
                    const finalDx = initialTransform.x;
                    const finalDy = initialTransform.y;
                    
                    position.x += finalDx;
                    position.y += finalDy;
                    
                    group.alters.forEach(alter => {
                        alter.x += finalDx;
                        alter.y += finalDy;
                        if (alterPositions && alterPositions.has(alter.id)) {
                            const pos = alterPositions.get(alter.id);
                            alterPositions.set(alter.id, {
                                x: pos.x + finalDx,
                                y: pos.y + finalDy
                            });
                        }
                    });
                    
                    // Update data bound to DOM elements
                    d3.select(this).selectAll('.alter-node').each(function() {
                        const currentData = d3.select(this).datum();
                        if (currentData) {
                            currentData.x += finalDx;
                            currentData.y += finalDy;
                        }
                    });
                    
                    // Reset transform and apply position changes directly
                    d3.select(this).attr('transform', null);
                    
                    // Redraw component at new permanent position
                    d3.select(this).selectAll('rect')
                        .attr('x', position.x - (boxWidth / 2))
                        .attr('y', position.y - (boxHeight / 2));
                    
                    d3.select(this).selectAll('text')
                        .attr('x', position.x)
                        .attr('y', position.y - (boxHeight / 2) + 20);
                    
                    // Update alter positions in DOM
                    d3.select(this).selectAll('.alter-node').each(function(alterData) {
                        if (alterData && typeof alterData.x === 'number' && typeof alterData.y === 'number') {
                            const alterGroup = d3.select(this);
                            alterGroup.selectAll('circle')
                                .attr('cx', alterData.x)
                                .attr('cy', alterData.y);
                            alterGroup.selectAll('text')
                                .attr('x', alterData.x)
                                .attr('y', alterData.y);
                        }
                    });
                    
                    // Final edge redraw with permanent positions
                    redrawAlterEdges();
                }));
        }
  
        function drawAlterEdges(container, alterPositions) {
            // Clear existing edges
            container.selectAll('*').remove();
            
            // Initialize edge visibility if not set
            if (!state.ui.edgeVisibility) {
                state.ui.edgeVisibility = 'all'; // Default to showing all edges
            }
            
            // Filter edges based on visibility setting
            let edgesToDraw = [];
            
            if (state.ui.edgeVisibility === 'all') {
                // Show ALL edges - this is the default view
                edgesToDraw = state.current.nodeEdges;
            } else if (state.ui.edgeVisibility === 'ego-only') {
                // No alter-alter edges in ego-only mode
                edgesToDraw = [];
            } else if (state.ui.edgeVisibility === 'selected-only') {
                // Only show edges connected to selected alter
                if (state.ui.selectedAlter) {
                    edgesToDraw = state.current.nodeEdges.filter(edge => 
                        edge.source === state.ui.selectedAlter.id || edge.target === state.ui.selectedAlter.id
                    );
                } else {
                    // If no alter is selected, show no edges
                    edgesToDraw = [];
                }
            }
            
            if (edgesToDraw.length === 0) {
                return;
            }
            edgesToDraw.forEach((edge, index) => {
                const sourcePos = alterPositions.get(edge.source);
                const targetPos = alterPositions.get(edge.target);
                
                if (sourcePos && targetPos) {
                    // Check if this edge is connected to selected alter
                    const isSelectedEdge = state.ui.selectedAlter && 
                        (edge.source === state.ui.selectedAlter.id || edge.target === state.ui.selectedAlter.id);
                    
                    // Determine edge color and styling based on visibility mode and selection
                    let edgeColor, edgeWidth, edgeOpacity;
                    
                    // For edge visibility 'all', we'll use CSS classes for styling
                    // The actual colors will be applied via CSS classes in updateNodeSelection
                    
                    if (state.ui.edgeVisibility === 'selected-only') {
                        // In selected-only mode, all visible edges are red (selected)
                        edgeColor = '#ef4444';  // Red
                        edgeWidth = '3.5';
                        edgeOpacity = '0.95';
                    } else {
                        // For 'all' and 'ego-only' modes, use default styling
                        // The selected edges will be highlighted via CSS classes
                        edgeColor = '#4A5568';  // Default gray
                        edgeWidth = '1.5';
                        edgeOpacity = '0.35';
                    }
                    
                    // Get node sizes for edge endpoint calculation
                    const sourceAlter = state.current.nodeData.find(a => 
                        normId(a.node_mapping_code) === edge.source
                    );
                    const targetAlter = state.current.nodeData.find(a => 
                        normId(a.node_mapping_code) === edge.target
                    );
                    
                    const sourceRadius = sourceAlter ? getNodeSize({data: sourceAlter}) : 20;
                    const targetRadius = targetAlter ? getNodeSize({data: targetAlter}) : 20;
                    
                    // Check if both nodes are in the same context box
                    const sameBox = areSameContextBox(edge.source, edge.target);
                    
                    if (sameBox) {
                        // Draw curved edge within the same box (from perimeter to perimeter)
                        const endpoints = edgeEnd(sourcePos, targetPos, sourceRadius, targetRadius);
                        const midX = (endpoints.x1 + endpoints.x2) / 2;
                        const midY = (endpoints.y1 + endpoints.y2) / 2;
                        const distance = Math.sqrt(Math.pow(endpoints.x2 - endpoints.x1, 2) + Math.pow(endpoints.y2 - endpoints.y1, 2));
                        const curvature = Math.min(distance * 0.2, 20);
                        
                        // Calculate control point perpendicular to the line
                        const dx = endpoints.x2 - endpoints.x1;
                        const dy = endpoints.y2 - endpoints.y1;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        const perpX = length > 0 ? -dy / length * curvature : 0;
                        const perpY = length > 0 ? dx / length * curvature : 0;
                        
                        const path = `M ${endpoints.x1} ${endpoints.y1} Q ${midX + perpX} ${midY + perpY} ${endpoints.x2} ${endpoints.y2}`;
                        
                        const edgeElement = container.append('path')
                            .attr('class', 'alter-edge')
                            .attr('d', path)
                            .style('stroke', edgeColor)
                            .style('stroke-width', edgeWidth)
                            .style('stroke-linecap', 'round')
                            .style('opacity', edgeOpacity)
                            .style('fill', 'none')
                            .style('pointer-events', 'auto')
                            .attr('data-source', edge.source)
                            .attr('data-target', edge.target);
                        

                    } else {
                        // Draw straight line across boxes (from perimeter to perimeter)
                        const endpoints = edgeEnd(sourcePos, targetPos, sourceRadius, targetRadius);
                        
                        const edgeElement = container.append('line')
                            .attr('class', 'alter-edge')
                            .attr('x1', endpoints.x1)
                            .attr('y1', endpoints.y1)
                            .attr('x2', endpoints.x2)
                            .attr('y2', endpoints.y2)
                            .style('stroke', edgeColor)
                            .style('stroke-width', edgeWidth)
                            .style('stroke-linecap', 'round')
                            .style('opacity', edgeOpacity)
                            .style('pointer-events', 'auto')
                            .attr('data-source', edge.source)
                            .attr('data-target', edge.target);
                        

                    }
                }
            });
        }
  
        function redrawAlterEdges() {
            // Redraw edges for both layout styles when needed
            if (state.ui.layoutStyle === 'component') {
                const container = d3.select('#networkSvg').select('.edges-layer');
                const alterPositions = new Map();
                
                // Collect current alter positions from all component boxes
                d3.selectAll('.component-box').each(function() {
                    const boxGroup = d3.select(this);
                    const transform = boxGroup.attr('transform');
                    let transformX = 0, transformY = 0;
                    
                    // Parse transform if exists
                    if (transform) {
                        const match = transform.match(/translate\(([^,)]+),([^)]+)\)/);
                        if (match) {
                            transformX = parseFloat(match[1]);
                            transformY = parseFloat(match[2]);
                        }
                    }
                    
                    // Find all alter nodes within this component box
                    boxGroup.selectAll('.alter-node').each(function(d) {
                        if (d && d.id && typeof d.x === 'number' && typeof d.y === 'number') {
                            const x = d.x + transformX;
                            const y = d.y + transformY;
                            alterPositions.set(d.id, { x, y });
                        }
                    });
                });
                
                // Redraw edges with updated positions
                drawAlterEdges(container, alterPositions);
            } else if (state.ui.layoutStyle === 'grouped') {
                // For grouped context layout, use the existing function
                redrawContextBoxEdges();
            }
        }
  
        function areSameContextBox(sourceId, targetId) {
            // Find the context groups for both nodes
            let sourceContext = null;
            let targetContext = null;
            
            // This is a simplified check - in practice, you'd maintain context mappings
            const sourceAlter = state.current.nodeData.find(a => 
                normId(a.node_mapping_code) === sourceId
            );
            const targetAlter = state.current.nodeData.find(a => 
                normId(a.node_mapping_code) === targetId
            );
            
            if (sourceAlter && targetAlter) {
                sourceContext = canonContext(sourceAlter.node_type);
                targetContext = canonContext(targetAlter.node_type);
                
                // For activities, check if they're the same specific activity
                if (sourceContext.startsWith('activity_') && targetContext.startsWith('activity_')) {
                    return sourceContext === targetContext;
                }
                
                return sourceContext === targetContext;
            }
            
            return false;
        }
        
        function redrawContextBoxEdges() {
            // Redraw edges for grouped context layout when boxes are dragged
            if (state.ui.layoutStyle === 'grouped') {
                const container = d3.select('#networkSvg').select('.edges-layer');
                const alterPositions = new Map();
                
                // Collect current alter positions from all context boxes
                d3.selectAll('.context-box').each(function() {
                    const boxGroup = d3.select(this);
                    const transform = boxGroup.attr('transform');
                    let transformX = 0, transformY = 0;
                    
                    // Parse transform if exists
                    if (transform) {
                        const match = transform.match(/translate\(([^,)]+),([^)]+)\)/);
                        if (match) {
                            transformX = parseFloat(match[1]);
                            transformY = parseFloat(match[2]);
                        }
                    }
                    
                    // Find all alter nodes within this context box
                    boxGroup.selectAll('.alter-node').each(function(d) {
                        if (d && d.id && typeof d.x === 'number' && typeof d.y === 'number') {
                            const x = d.x + transformX;
                            const y = d.y + transformY;
                            alterPositions.set(d.id, { x, y });
                        }
                    });
                });
                
                // Redraw edges with updated positions
                drawAlterEdges(container, alterPositions);
            }
        }
  
        function calculateGroupPositions(groupCount, width, height, ego) {
            const positions = [];
            // Further increase radius to eliminate overlap between context boxes
            const maxRadius = Math.min(width, height) * 0.45; // Increased from 0.35 to 0.45
            const radius = Math.min(maxRadius, 400); // Increased cap from 300px to 400px
            const centerX = ego.x;
            const centerY = ego.y;
            
            for (let i = 0; i < groupCount; i++) {
                const angle = (i / groupCount) * 2 * Math.PI - Math.PI / 2;
                positions.push({
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                });
            }
            
            return positions;
        }
  
        function drawContextBox(container, group, position, groupKey, alterPositions) {
            const alters = group.alters;
            const boxPadding = 30; // Increased from 20 to 30
            const nodeRadius = 25;
            const spacing = nodeRadius * 4.5; // INCREASED SPACING from 3.5 to 4.5
            
            // Calculate box dimensions - simplified since labels are inside circles
            const cols = Math.ceil(Math.sqrt(alters.length));
            const rows = Math.ceil(alters.length / cols);
            const minSpacing = 80; // Increased minimum distance from 60 to 80
            const actualSpacing = Math.max(spacing, minSpacing);
            // Expand box to fit all alters without capping, so no nodes are dropped
            const boxWidth = Math.max(160, cols * actualSpacing + boxPadding * 2);
            const boxHeight = Math.max(100, rows * actualSpacing + boxPadding * 2 + 40);
            
            // Position box
            const boxX = position.x - boxWidth / 2;
            const boxY = position.y - boxHeight / 2;
            
            // Determine if clickable
            const isClickable = false; // remove info icon on daycare
            
            // Create context box group with drag functionality
            const boxGroup = container.append('g')
                .attr('class', 'context-box')
                .attr('data-context-key', groupKey)
                .style('cursor', 'move');
            
            if (isClickable) {
                boxGroup.classed('clickable', true)
                    .on('click', (event) => {
                        event.stopPropagation();
                        selectContextBox(groupKey, group);
                    });
            }
            
            // Draw box background
            boxGroup.append('rect')
                .attr('x', boxX)
                .attr('y', boxY)
                .attr('width', boxWidth)
                .attr('height', boxHeight)
                .attr('rx', 12)
                .attr('ry', 12)
                .style('fill', group.color)
                .style('stroke', isClickable ? '#495057' : 'none')
                .style('stroke-width', isClickable ? 2 : 0)
                .style('stroke-dasharray', isClickable ? '5,5' : 'none')
                .style('opacity', 0.8);
            
            // Draw box label
            boxGroup.append('text')
                .attr('x', position.x)
                .attr('y', boxY + 20)
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .style('fill', '#2c3e50')
                .text(group.label);
            
            // Add info icon for contexts with detailed information (daycare only)
            if (isClickable) {
                console.log('Creating info icon for context:', groupKey);
                const iconSize = 16;
                const iconX = boxX + boxWidth - iconSize - 6;
                const iconY = boxY + 6;
                
                // Remove any existing info icon first
                boxGroup.selectAll('.info-icon').remove();
                
                // Create info icon group
                const infoIcon = boxGroup.append('g')
                    .attr('class', 'info-icon')
                    .attr('id', `info-icon-${groupKey}`)
                    .style('pointer-events', 'none')
                    .attr('transform', `translate(${iconX}, ${iconY})`);
                
                // Draw info icon as a single SVG path (question mark in circle)
                infoIcon.append('path')
                    .attr('d', `M8,0C3.6,0,0,3.6,0,8s3.6,8,8,8s8-3.6,8-8S12.4,0,8,0z M8,14c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S11.3,14,8,14z M8,4c-1.1,0-2,0.9-2,2h1c0-0.6,0.4-1,1-1s1,0.4,1,1c0,1-1.5,1.5-1.5,2.5h1c0-0.8,1.5-1.2,1.5-2.5C10,4.9,9.1,4,8,4z M7,10h2v1H7V10z`)
                    .style('fill', '#8b0000')
                    .style('opacity', 0.9);
                
                console.log('Info icon created for context:', groupKey);
            }
            
            // Position and draw alters within the box
            alters.forEach((alter, i) => {
                const col = i % cols;
                const row = Math.floor(i / cols);
                const alterX = boxX + boxPadding + col * actualSpacing + actualSpacing / 2;
                const alterY = boxY + boxPadding + 30 + row * actualSpacing + actualSpacing / 2;
                
                alter.x = alterX;
                alter.y = alterY;
                
                // Ensure alter.id is normalized consistently
                alter.id = normId(alter.data.node_mapping_code) || `alter_${i}`;
                
                // Store position for edge drawing (key by normalized ID)
                if (alterPositions) {
                    alterPositions.set(alter.id, { x: alterX, y: alterY });
                }
                
                // Get node size and positioning info
                const nodeRadius = getNodeSize(alter);
                
                // Draw alter node
                const alterGroup = boxGroup.append('g')
                    .attr('class', 'alter-node')
                    .datum({
                        id: alter.id,
                        x: alterX,
                        y: alterY,
                        data: alter.data,
                        name: alter.name
                    })
                    .style('cursor', 'pointer')
                    .on('click', (event) => {
                        event.stopPropagation();
                        selectAlterNode(alter);
                    })
                    .on('mouseover', (event) => {
                        // Show tooltip with full name
                        const tooltip = document.getElementById('tooltip');
                        if (tooltip) {
                            tooltip.innerHTML = alter.name;
                            tooltip.style.left = (event.pageX + 10) + 'px';
                            tooltip.style.top = (event.pageY - 10) + 'px';
                            tooltip.style.opacity = '1';
                            tooltip.style.display = 'block';
                        }
                    })
                    .on('mouseout', () => {
                        // Hide tooltip
                        const tooltip = document.getElementById('tooltip');
                        if (tooltip) {
                            tooltip.style.opacity = '0';
                            tooltip.style.display = 'none';
                        }
                    });
  
                // Handle language pie charts when in language color mode
                if (state.ui.colorBy === 'language') {
                    const languages = normalizeLanguage(alter.data.node_language);
                    
                    if (languages.length > 1) {
                        // Create clipPath for multilingual nodes
                        const clipId = `clip-${alter.id}`;
                        const defs = alterGroup.append('defs');
                        defs.append('clipPath')
                            .attr('id', clipId)
                            .append('circle')
                            .attr('cx', alterX)
                            .attr('cy', alterY)
                            .attr('r', nodeRadius);
                        
                        // Create pie wedges
                        const pieGroup = alterGroup.append('g')
                            .attr('clip-path', `url(#${clipId})`);
                        
                        const anglePerLang = (2 * Math.PI) / languages.length;
                        languages.forEach((lang, i) => {
                            const startAngle = i * anglePerLang - Math.PI / 2; // Start from top
                            const endAngle = (i + 1) * anglePerLang - Math.PI / 2;
                            
                            const x1 = alterX + nodeRadius * Math.cos(startAngle);
                            const y1 = alterY + nodeRadius * Math.sin(startAngle);
                            const x2 = alterX + nodeRadius * Math.cos(endAngle);
                            const y2 = alterY + nodeRadius * Math.sin(endAngle);
                            
                            const largeArcFlag = anglePerLang > Math.PI ? 1 : 0;
                            const pathData = `M ${alterX} ${alterY} L ${x1} ${y1} A ${nodeRadius} ${nodeRadius} 0 ${largeArcFlag} 1 ${x2} ${y2} Z`;
                            
                            const languagePalette = {};
                            languages.forEach((lang, index) => {
                                languagePalette[lang] = getLanguageColor(lang, index);
                            });
                            
                            pieGroup.append('path')
                                .attr('d', pathData)
                                .style('fill', languagePalette[lang] || '#cccccc')
                                .style('stroke', 'none');
                        });
                        
                        // Add stroke around the whole circle
                alterGroup.append('circle')
                    .attr('cx', alterX)
                    .attr('cy', alterY)
                            .attr('r', nodeRadius)
                            .style('fill', 'none')
                            .style('stroke', '#666666')
                    .style('stroke-width', 3);
                    } else {
                                            // Single language - regular circle
                    let nodeColor = getNodeColor(alter, 'white');
                    
                    // Preserve original colors - don't change node colors when selected
                    // Only edges will change to red to show connections
                    
                    alterGroup.append('circle')
                        .attr('cx', alterX)
                        .attr('cy', alterY)
                        .attr('r', nodeRadius)
                        .style('fill', nodeColor)
                        .style('stroke', '#666666')
                        .style('stroke-width', 3);
                    }
                } else {
                    // Regular circle for non-language modes
                    let nodeColor = getNodeColor(alter, 'white');
                    const strokeColor = state.ui.colorBy === 'context' ? group.color : '#666666';
                    
                    // Only apply special highlighting for context mode when a node is selected
                    if (state.ui.colorBy === 'context' && state.ui.selectedAlter) {
                        // Check if this alter is connected to the selected alter
                        const isConnectedToSelected = state.current.nodeEdges.some(edge => 
                            (edge.source === alter.id && edge.target === state.ui.selectedAlter.id) ||
                            (edge.target === alter.id && edge.source === state.ui.selectedAlter.id)
                        );
                        
                        if (isConnectedToSelected) {
                            nodeColor = '#ffa500'; // Orange for alters connected to selected alter
                        } else {
                            nodeColor = 'white'; // White for other alters (context color)
                        }
                    }
                    
                    alterGroup.append('circle')
                        .attr('cx', alterX)
                        .attr('cy', alterY)
                        .attr('r', nodeRadius)
                        .style('fill', nodeColor)
                        .style('stroke', strokeColor)
                        .style('stroke-width', 3);
                }
                
                // Always place label inside the circle and auto-fit font size
                const labelInside = alterGroup.append('text')
                    .attr('x', alterX)
                    .attr('y', alterY)
                    .style('text-anchor', 'middle')
                    .style('dominant-baseline', 'middle')
                    .style('font-size', '13px')
                    .style('font-weight', '600')
                    .style('fill', '#2c3e50')
                    .style('pointer-events', 'auto')
                    .style('cursor', 'pointer')
                    .style('text-shadow', '0 0 3px rgba(255,255,255,0.8)')
                    .text(getAnonymizedText(alter, false))
                    .on('click', (event) => {
                        event.stopPropagation();
                        selectAlterNode(alter);
                    });
                if (typeof fitTextToCircle === 'function') { fitTextToCircle(labelInside.node(), nodeRadius); }
            });
            
            // Add drag functionality to the context box
            let initialTransform = { x: 0, y: 0 };
            
            boxGroup.call(d3.drag()
                .on('start', function(event, d) {
                    d3.select(this).style('opacity', 0.8);
                    initialTransform.x = 0;
                    initialTransform.y = 0;
                })
                .on('drag', function(event, d) {
                    // Calculate relative movement from start of drag
                    initialTransform.x += event.dx;
                    initialTransform.y += event.dy;
                    
                    // Apply transform to follow mouse smoothly
                    d3.select(this).attr('transform', `translate(${initialTransform.x}, ${initialTransform.y})`);
                    
                    // Redraw edges that connect to this context box
                    redrawContextBoxEdges();
                })
                .on('end', function(event, d) {
                    d3.select(this).style('opacity', 1);
                    
                    // Apply final displacement to position and alter data
                    const finalDx = initialTransform.x;
                    const finalDy = initialTransform.y;
                    
                    position.x += finalDx;
                    position.y += finalDy;
                    
                    group.alters.forEach(alter => {
                        alter.x += finalDx;
                        alter.y += finalDy;
                        if (alterPositions && alterPositions.has(alter.id)) {
                            const pos = alterPositions.get(alter.id);
                            alterPositions.set(alter.id, {
                                x: pos.x + finalDx,
                                y: pos.y + finalDy
                            });
                        }
                    });
                    
                    // Update data bound to DOM elements
                    d3.select(this).selectAll('.alter-node').each(function() {
                        const currentData = d3.select(this).datum();
                        if (currentData) {
                            currentData.x += finalDx;
                            currentData.y += finalDy;
                        }
                    });
                    
                    // Reset transform and apply position changes directly
                    d3.select(this).attr('transform', null);
                    
                    // Redraw context box at new permanent position
                    d3.select(this).selectAll('rect')
                        .attr('x', position.x - (boxWidth / 2))
                        .attr('y', position.y - (boxHeight / 2));
                    
                    d3.select(this).selectAll('text')
                        .attr('x', position.x)
                        .attr('y', position.y - (boxHeight / 2) + 20);
                    
                    // Update alter positions in DOM
                    d3.select(this).selectAll('.alter-node').each(function(alterData) {
                        if (alterData && typeof alterData.x === 'number' && typeof alterData.y === 'number') {
                            const alterGroup = d3.select(this);
                            alterGroup.selectAll('circle')
                                .attr('cx', alterData.x)
                                .attr('cy', alterData.y);
                            alterGroup.selectAll('text')
                                .attr('x', alterData.x)
                                .attr('y', alterData.y);
                        }
                    });
                    
                    // Final edge redraw with permanent positions
                    redrawContextBoxEdges();
                }));
        }
  
        function drawTraditionalLayout(container, ego, contextGroups, width, height) {
            // Flatten all alters and assign fixed positions
            const allAlters = [];
            Object.values(contextGroups).forEach(group => {
                group.alters.forEach(alter => {
                    alter.context = group.context;
                    alter.color = group.color;
                    allAlters.push(alter);
                });
            });
  
            // Set fixed positions for ego and alters (simple circular layout)
            ego.x = width / 2;
            ego.y = height / 2;
            
            const radius = Math.min(width, height) * 0.3;
            allAlters.forEach((alter, i) => {
                const angle = (i / allAlters.length) * 2 * Math.PI;
                alter.x = ego.x + radius * Math.cos(angle);
                alter.y = ego.y + radius * Math.sin(angle);
            });
  
            // Get the explicit layers from the container
            const backgroundLayer = container.select('.background-layer');
            const edgesLayer = container.select('.edges-layer');
            const nodesLayer = container.select('.nodes-layer');
  
            // Create ego-alter links
            const egoLinks = allAlters.map(alter => ({ source: ego, target: alter }));
            
            // Create alter-alter links from the parsed edges
            const alterLinks = state.current.nodeEdges.map(edge => {
                const sourceAlter = allAlters.find(a => normId(a.data.node_mapping_code) === edge.source);
                const targetAlter = allAlters.find(a => normId(a.data.node_mapping_code) === edge.target);
                if (sourceAlter && targetAlter) {
                    return { source: sourceAlter, target: targetAlter };
                }
                return null;
            }).filter(link => link !== null);
            
            // Combine all links
            const allLinks = [...egoLinks, ...alterLinks];
            
            // Draw all links in edges layer (above background, below nodes)
            edgesLayer.selectAll('.link')
                .data(allLinks)
                .join('line')
                .attr('class', d => {
                    // Use 'alter-edge' class for alter-alter connections to enable highlighting
                    if (d.source.type !== 'ego' && d.target.type !== 'ego') {
                        return 'link alter-edge';
                    }
                    return 'link ego-edge';
                })
                .attr('data-source', d => d.source.id || d.source.name)
                .attr('data-target', d => d.target.id || d.target.name)
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y)
                .style('stroke', '#4A5568')
                .style('stroke-width', '1.5')
                .style('stroke-linecap', 'round')
                .style('opacity', '0.35');
  
            // Draw alter nodes with FULL functionality (same as grouped layout)
            allAlters.forEach((alter, i) => {
                const alterX = alter.x;
                const alterY = alter.y;
                
                // Ensure alter.id is normalized consistently
                alter.id = normId(alter.data.node_mapping_code) || `alter_${i}`;
                
                // Get node size and positioning info
                const nodeRadius = getNodeSize(alter);
                
                // Draw alter node group in nodes layer
                const alterGroup = nodesLayer.append('g')
                    .attr('class', 'alter-node')
                    .datum({
                        id: alter.id,
                        x: alterX,
                        y: alterY,
                        data: alter.data,
                        name: alter.name
                    })
                    .style('cursor', 'pointer')
                    .on('click', (event) => {
                        event.stopPropagation();
                        selectAlterNode(alter);
                    })
                    .on('mouseover', (event) => {
                        // Show tooltip with full name
                        const tooltip = document.getElementById('tooltip');
                        if (tooltip) {
                            tooltip.innerHTML = alter.name;
                            tooltip.style.left = (event.pageX + 10) + 'px';
                            tooltip.style.top = (event.pageY - 10) + 'px';
                            tooltip.style.opacity = '1';
                            tooltip.style.display = 'block';
                        }
                    })
                    .on('mouseout', () => {
                        // Hide tooltip
                        const tooltip = document.getElementById('tooltip');
                        if (tooltip) {
                            tooltip.style.opacity = '0';
                            tooltip.style.display = 'none';
                        }
                    });
  
                // Handle pie charts for multilingual nodes OR multi-race nodes
                let shouldDrawPieChart = false;
                let pieData = [];
                let piePalette = {};
                
                if (state.ui.colorBy === 'language') {
                    const languages = normalizeLanguage(alter.data.node_language);
                    if (languages.length > 1) {
                        shouldDrawPieChart = true;
                        pieData = languages;
                        piePalette = {
                            'English': '#1f77b4',
                            'German': '#ff7f0e', 
                            'Spanish': '#2ca02c',
                            'Portuguese': '#d62728',
                            'Italian': '#9467bd',
                            'Thai': '#8c564b',
                            'Pre-verbal/Non-verbal': '#7f7f7f',
                            'Unknown': '#cccccc'
                        };
                    }
                } else if (state.ui.colorBy === 'race') {
                    const races = normalizeRace(alter.data.node_race);
                    if (races.length > 1) {
                        shouldDrawPieChart = true;
                        pieData = races;
                        piePalette = {
                            'White': '#76b7b2',
                            'Black': '#59a14f',
                            'Hispanic/Latino': '#edc949',
                            'Asian': '#af7aa1',
                            'Native/Alaska': '#8dd3c7',
                            'MENA': '#fb8072',
                            'Multiracial': '#bc80bd',
                            'Other': '#d9d9d9'
                        };
                    }
                }
                
                if (shouldDrawPieChart) {
                    // Create clipPath for pie chart nodes
                    const clipId = `clip-${alter.id}`;
                    const defs = alterGroup.append('defs');
                    defs.append('clipPath')
                        .attr('id', clipId)
                        .append('circle')
                        .attr('cx', alterX)
                        .attr('cy', alterY)
                        .attr('r', nodeRadius);
                    
                    // Create pie wedges
                    const pieGroup = alterGroup.append('g')
                        .attr('clip-path', `url(#${clipId})`);
                    
                    const anglePerSlice = (2 * Math.PI) / pieData.length;
                    pieData.forEach((item, i) => {
                        const startAngle = i * anglePerSlice - Math.PI / 2; // Start from top
                        const endAngle = (i + 1) * anglePerSlice - Math.PI / 2;
                        
                        const x1 = alterX + nodeRadius * Math.cos(startAngle);
                        const y1 = alterY + nodeRadius * Math.sin(startAngle);
                        const x2 = alterX + nodeRadius * Math.cos(endAngle);
                        const y2 = alterY + nodeRadius * Math.sin(endAngle);
                        
                        const largeArcFlag = anglePerSlice > Math.PI ? 1 : 0;
                        const pathData = `M ${alterX} ${alterY} L ${x1} ${y1} A ${nodeRadius} ${nodeRadius} 0 ${largeArcFlag} 1 ${x2} ${y2} Z`;
                        
                        pieGroup.append('path')
                            .attr('d', pathData)
                            .style('fill', piePalette[item] || '#cccccc')
                            .style('stroke', 'none');
                    });
                    
                    // Add stroke around the whole circle
                    alterGroup.append('circle')
                        .attr('cx', alterX)
                        .attr('cy', alterY)
                        .attr('r', nodeRadius)
                        .style('fill', 'none')
                        .style('stroke', '#666666')
                        .style('stroke-width', 3);
                } else {
                    // Regular circle for single values or other color modes
                    let nodeColor = getNodeColor(alter, 'white');
                    const strokeColor = state.ui.colorBy === 'context' ? alter.color : '#666666';
                    
                    // Only apply special highlighting for context mode when a node is selected
                    if (state.ui.colorBy === 'context' && state.ui.selectedAlter) {
                        // Check if this alter is connected to the selected alter
                        const isConnectedToSelected = state.current.nodeEdges.some(edge => 
                            (edge.source === alter.id && edge.target === state.ui.selectedAlter.id) ||
                            (edge.target === alter.id && edge.source === state.ui.selectedAlter.id)
                        );
                        
                        if (isConnectedToSelected) {
                            nodeColor = '#ffa500'; // Orange for alters connected to selected alter
                        } else {
                            nodeColor = 'white'; // White for other alters (context color)
                        }
                    }
                    
                    alterGroup.append('circle')
                        .attr('cx', alterX)
                        .attr('cy', alterY)
                        .attr('r', nodeRadius)
                        .style('fill', nodeColor)
                        .style('stroke', strokeColor)
                        .style('stroke-width', 3);
                }
                
                // Always place label inside the circle and auto-fit font size
                const labelInside2 = alterGroup.append('text')
                    .attr('x', alterX)
                    .attr('y', alterY)
                    .style('text-anchor', 'middle')
                    .style('dominant-baseline', 'middle')
                    .style('font-size', '13px')
                    .style('font-weight', '600')
                    .style('fill', '#2c3e50')
                    .style('pointer-events', 'auto')
                    .style('cursor', 'pointer')
                    .style('text-shadow', '0 0 3px rgba(255,255,255,0.8)')
                    .text(getAnonymizedText(alter, false))
                    .on('click', (event) => {
                        event.stopPropagation();
                        selectAlterNode(alter);
                    });
                if (typeof fitTextToCircle === 'function') { fitTextToCircle(labelInside2.node(), nodeRadius); }
  
                // Add metric under name based on sizing mode
                if (state.ui.nodeSizeBy === 'weekly_hours') {
                    const weeklyHours = parseFloat(alter.data.node_weekly_hour_summarized || alter.data.node_weekly_hour || 0);
                    alterGroup.append('text')
                        .attr('x', alterX)
                        .attr('y', alterY + 8)
                        .style('text-anchor', 'middle')
                        .style('dominant-baseline', 'middle')
                        .style('font-size', '8px')
                        .style('font-weight', '400')
                        .style('fill', '#6c757d')
                        .style('pointer-events', 'none')
                        .text(`${weeklyHours}h`);
                } else if (state.ui.nodeSizeBy === 'closeness') {
                    const closeness = parseFloat(alter.data.node_closeness_score || 0);
                    alterGroup.append('text')
                        .attr('x', alterX)
                        .attr('y', alterY + 8)
                        .style('text-anchor', 'middle')
                        .style('dominant-baseline', 'middle')
                        .style('font-size', '8px')
                        .style('font-weight', '400')
                        .style('fill', '#6c757d')
                        .style('pointer-events', 'none')
                        .text(`${Math.round(isNaN(closeness) ? 0 : closeness)}`);
                } else if (state.ui.nodeSizeBy === 'closeness_intensity_z') {
                    const zScore = getClosenessIntensityZFromData(alter.data);
                    alterGroup.append('text')
                        .attr('x', alterX)
                        .attr('y', alterY + 8)
                        .style('text-anchor', 'middle')
                        .style('dominant-baseline', 'middle')
                        .style('font-size', '8px')
                        .style('font-weight', '400')
                        .style('fill', '#6c757d')
                        .style('pointer-events', 'none')
                        .text(zScore.toFixed(2));
                }
  
  
  
                // Add survey respondent indicator if applicable
                if (isShowingRespondent(alter)) {
                    alterGroup.classed('survey-respondent', true);
                }
            });
  
            // Draw distinctive ego node in nodes layer
            const egoGroup = nodesLayer.append('g')
                .attr('class', 'ego-node')
                .datum({
                    id: 'ego',
                    x: ego.x,
                    y: ego.y,
                    data: ego,
                    name: ego.name,
                    type: 'ego'
                })
                .style('cursor', 'pointer')
                .on('click', showEgoInfo);
            
            const size = 30;
            const rx = size * 0.3;
            
            egoGroup.append('rect')
                .attr('x', ego.x - size)
                .attr('y', ego.y - size)
                .attr('width', size * 2)
                .attr('height', size * 2)
                .attr('rx', rx)
                .attr('ry', rx)
                .style('fill', getEgoColor())
                .style('stroke', 'white')
                .style('stroke-width', 3);
  
            // Add ego label
            egoGroup.append('text')
                .attr('x', ego.x)
                .attr('y', ego.y)
                .style('text-anchor', 'middle')
                .style('dominant-baseline', 'middle')
                .style('font-size', '12px')
                .style('font-weight', 'bold')
                .style('fill', 'white')
                .style('pointer-events', 'none')
                .text(truncateName(getAnonymizedText(ego, true), 30));
        }
  
        function drawEgoNode(container, ego) {
            const egoGroup = container.append('g')
                .attr('class', 'ego-node')
                .datum({
                    id: 'ego',
                    x: ego.x,
                    y: ego.y,
                    data: ego,
                    name: ego.name,
                    type: 'ego'
                })
                .style('cursor', 'pointer')
                .on('click', showEgoInfo);
            
            const size = 30;
            const rx = size * 0.3;
            const childData = state.current.childData;
            
            // Check if ego should have pie chart for multiple languages or races
            let shouldDrawPieChart = false;
            let pieData = [];
            let piePalette = {};
            
            if (childData && state.ui.colorBy === 'language') {
                const languages = normalizeLanguage(childData.child_lang);
                if (languages.length > 1) {
                    shouldDrawPieChart = true;
                    pieData = languages;
                    piePalette = {
                        'English': '#1f77b4',
                        'German': '#ff7f0e', 
                        'Spanish': '#2ca02c',
                        'Portuguese': '#d62728',
                        'Italian': '#9467bd',
                        'Thai': '#8c564b',
                        'Chinese': '#ff69b4',
                        'Chinese (Cantonese)': '#ff69b4',
                        'Chinese (Mandarin)': '#ff1493',
                        'French': '#32cd32',
                        'Japanese': '#ff4500',
                        'Korean': '#9932cc',
                        'Arabic': '#20b2aa',
                        'Hindi': '#ff6347',
                        'Russian': '#4169e1',
                        'Dutch': '#ff8c00',
                        'Swedish': '#00ced1',
                        'Norwegian': '#da70d6',
                        'Danish': '#ffd700',
                        'Finnish': '#00fa9a',
                        'Polish': '#dc143c',
                        'Czech': '#8b008b',
                        'Hungarian': '#b8860b',
                        'Greek': '#2e8b57',
                        'Turkish': '#cd853f',
                        'Hebrew': '#ff69b4',
                        'Persian': '#ff4500',
                        'Vietnamese': '#32cd32',
                        'Filipino': '#9932cc',
                        'Indonesian': '#20b2aa',
                        'Malay': '#ff6347',
                        'Pre-verbal/Non-verbal': '#7f7f7f',
                        'Unknown': '#cccccc'
                    };
                }
            } else if (childData && state.ui.colorBy === 'race') {
                const races = normalizeRace(childData.child_race);
                if (races.length > 1) {
                    shouldDrawPieChart = true;
                    pieData = races;
                    piePalette = {
                        'White': '#76b7b2',
                        'Black': '#59a14f',
                        'Hispanic/Latino': '#edc949',
                        'Asian': '#af7aa1',
                        'Native/Alaska': '#8dd3c7',
                        'MENA': '#fb8072',
                        'Multiracial': '#bc80bd',
                        'Other': '#d9d9d9'
                    };
                }
            }
            
            if (shouldDrawPieChart) {
                // Create clipPath for pie chart in square shape
                const clipId = `clip-ego`;
                const defs = egoGroup.append('defs');
                defs.append('clipPath')
                    .attr('id', clipId)
                    .append('rect')
                    .attr('x', ego.x - size)
                    .attr('y', ego.y - size)
                    .attr('width', size * 2)
                    .attr('height', size * 2)
                    .attr('rx', rx)
                    .attr('ry', rx);
                
                // Create pie wedges within the clipped square
                const pieGroup = egoGroup.append('g')
                    .attr('clip-path', `url(#${clipId})`);
                
                const radius = size * 1.2; // Larger radius to fill the square
                const anglePerSlice = (2 * Math.PI) / pieData.length;
                
                pieData.forEach((item, i) => {
                    const startAngle = i * anglePerSlice - Math.PI / 2; // Start from top
                    const endAngle = (i + 1) * anglePerSlice - Math.PI / 2;
                    
                    const x1 = ego.x + radius * Math.cos(startAngle);
                    const y1 = ego.y + radius * Math.sin(startAngle);
                    const x2 = ego.x + radius * Math.cos(endAngle);
                    const y2 = ego.y + radius * Math.sin(endAngle);
                    
                    const largeArcFlag = anglePerSlice > Math.PI ? 1 : 0;
                    const pathData = `M ${ego.x} ${ego.y} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2} Z`;
                    
                    pieGroup.append('path')
                        .attr('d', pathData)
                        .style('fill', piePalette[item] || '#cccccc')
                        .style('stroke', 'none');
                });
                
                // Add stroke around the whole square
                egoGroup.append('rect')
                    .attr('x', ego.x - size)
                    .attr('y', ego.y - size)
                    .attr('width', size * 2)
                    .attr('height', size * 2)
                    .attr('rx', rx)
                    .attr('ry', rx)
                    .style('fill', 'none')
                    .style('stroke', 'white')
                    .style('stroke-width', 3);
            } else {
                // Regular solid-colored square for single values or other color modes
                egoGroup.append('rect')
                    .attr('x', ego.x - size)
                    .attr('y', ego.y - size)
                    .attr('width', size * 2)
                    .attr('height', size * 2)
                    .attr('rx', rx)
                    .attr('ry', rx)
                    .style('fill', getEgoColor())
                    .style('stroke', 'white')
                    .style('stroke-width', 3);
            }
            
            egoGroup.append('text')
                .attr('x', ego.x)
                .attr('y', ego.y)
                .style('text-anchor', 'middle')
                .style('dominant-baseline', 'middle')
                .style('font-size', '12px')
                .style('font-weight', 'bold')
                .style('fill', 'white')
                .style('pointer-events', 'none')
                .text(truncateName(getAnonymizedText(ego, true), 30));
        }
  
        function showHelp() {
            document.getElementById('helpOverlay').style.display = 'block';
        }
  
        function hideHelp() {
            document.getElementById('helpOverlay').style.display = 'none';
        }
  
        function getNodeColor(node, defaultColor) {
            if (state.ui.colorBy === 'context') {
                return defaultColor;
            }
            
            const colorPalettes = {
                gender: {
                    'Male': '#4e79a7',
                    'Female': '#f28e2c',
                    'Other': '#e15759'
                },
                race: {
                    'White': '#76b7b2',
                    'Black': '#59a14f',
                    'Hispanic/Latino': '#edc949',
                    'Asian': '#af7aa1',
                    'Native/Alaska': '#8dd3c7',
                    'MENA': '#fb8072',
                    'Multiracial': '#bc80bd',
                    'Other': '#d9d9d9'
                },
                language: {}, // Dynamic language colors will be generated
                kin: {
                    'Yes': '#E53935',
                    'No': '#9CA3AF'
                },
                age_categorized: {
                    'Younger than 2 years old': '#FFD700',  // Gold/Yellow
                    '2-5 years old': '#FF6B35',              // Bright Orange
                    '6-12 years old': '#4ECDC4',             // Teal
                    '13-17 years old': '#45B7D1',            // Sky Blue
                    '18 years old or older': '#96CEB4'       // Mint Green
                },
                weekly_hours: {
                    '≤3h': '#d1f2eb',      // Very light green
                    '3-10h': '#7fb3d3',    // Light blue  
                    '11-30h': '#5dade2',   // Medium blue
                    '30-60h': '#3498db',   // Blue
                    '>60h': '#2874a6'      // Dark blue
                }
            };
            
            // Check if this is an ego node and get child data
            let value;
            if (node.isEgo || node.type === 'ego') {
                // For ego nodes, get data from child data
                const childData = state.current.childData;
                if (childData) {
                    if (state.ui.colorBy === 'gender') {
                        value = childData.child_gender;
                    } else if (state.ui.colorBy === 'race') {
                        value = childData.child_race;
                    } else if (state.ui.colorBy === 'language') {
                        value = childData.child_lang;
                    } else if (state.ui.colorBy === 'accent') {
                        value = childData.ego_accent_specific || childData.ego_accent_categorized;
                    } else if (state.ui.colorBy === 'kin') {
                        value = 'N/A'; // Ego is always self, not kin
                    } else if (state.ui.colorBy === 'age_categorized') {
                        value = childData.child_age_categorized;
                    } else if (state.ui.colorBy === 'weekly_hours') {
                        value = 0; // Ego typically doesn't have weekly hours, so use 0 (≤3h category)
                    }
                }
            } else {
                // For alter nodes, get data from node data
                if (state.ui.colorBy === 'weekly_hours') {
                    value = node.data.node_weekly_hour_summarized || node.data.node_weekly_hour;
                } else if (state.ui.colorBy === 'age_categorized') {
                    value = node.data.node_age_categorized;
                } else if (state.ui.colorBy === 'accent') {
                    value = node.data.node_accent_specific || node.data.node_accent_categorized;
                } else {
                    value = node.data[`node_${state.ui.colorBy}`];
                }
            }
            
            const palette = colorPalettes[state.ui.colorBy];
            
            // Special handling for different modes
            if (state.ui.colorBy === 'language') {
                const languages = normalizeLanguage(value);
                if (languages.length > 0) {
                    const firstLang = languages[0];
                    return getLanguageColor(firstLang, 0);
                }
                return '#cccccc';
            } else if (state.ui.colorBy === 'race') {
                const canonicalRace = canonRace(value);
                return palette[canonicalRace] || '#cccccc';
            } else if (state.ui.colorBy === 'kin') {
                const canonicalKin = canonKin(value);
                return palette[canonicalKin] || '#cccccc';
            } else if (state.ui.colorBy === 'age_categorized') {
                // Age categories are already in the right format
                const agePalette = {
                    'Younger than 2 years old': '#FFD700',  // Gold/Yellow
                    '2-5 years old': '#FF6B35',              // Bright Orange
                    '6-12 years old': '#4ECDC4',             // Teal
                    '13-17 years old': '#45B7D1',            // Sky Blue
                    '18 years old or older': '#96CEB4'       // Mint Green
                };
                return agePalette[value] || '#cccccc';
            } else if (state.ui.colorBy === 'accent') {
                // Use first specific accent token if multiple
                const tokens = String(value || '').split(';').map(s => s.trim()).filter(Boolean);
                const first = tokens[0] || 'Unknown';
                return getAccentColor(first);
            } else if (state.ui.colorBy === 'weekly_hours') {
                // Get weekly hours value and categorize it
                const hours = parseFloat(value || 0);
                let category;
                if (hours <= 3) {
                    category = '≤3h';
                } else if (hours <= 10) {
                    category = '3-10h';
                } else if (hours <= 30) {
                    category = '11-30h';
                } else if (hours <= 60) {
                    category = '30-60h';
                } else {
                    category = '>60h';
                }
                return palette[category] || '#cccccc';
            }
            
            return palette && palette[value] ? palette[value] : '#cccccc';
        }
  
        function getEgoColor() {
            // Default strong modern blue for context mode or when no child data
            if (state.ui.colorBy === 'context' || !state.current.childData) {
                return '#2C7BE5';
            }
            
            const colorPalettes = {
                gender: {
                    'Male': '#4e79a7',
                    'Female': '#f28e2c',
                    'Other': '#e15759'
                },
                race: {
                    'White': '#76b7b2',
                    'Black': '#59a14f',
                    'Hispanic/Latino': '#edc949',
                    'Asian': '#af7aa1',
                    'Native/Alaska': '#8dd3c7',
                    'MENA': '#fb8072',
                    'Multiracial': '#bc80bd',
                    'Other': '#d9d9d9'
                },
                language: {}, // Dynamic language colors will be generated
                kin: {
                    'Yes': '#E53935',
                    'No': '#9CA3AF'
                },
                age_categorized: {
                    'Younger than 2 years old': '#FFD700',  // Gold/Yellow
                    '2-5 years old': '#FF6B35',              // Bright Orange
                    '6-12 years old': '#4ECDC4',             // Teal
                    '13-17 years old': '#45B7D1',            // Sky Blue
                    '18 years old or older': '#96CEB4'       // Mint Green
                },
                weekly_hours: {
                    '≤3h': '#d1f2eb',      // Very light green
                    '3-10h': '#7fb3d3',    // Light blue  
                    '11-30h': '#5dade2',   // Medium blue
                    '30-60h': '#3498db',   // Blue
                    '>60h': '#2874a6'      // Dark blue
                }
            };
            
            const childData = state.current.childData;
            let value;
            
            if (state.ui.colorBy === 'gender') {
                value = childData.child_gender;
            } else if (state.ui.colorBy === 'race') {
                value = childData.child_race;
            } else if (state.ui.colorBy === 'language') {
                value = childData.child_lang;
            } else if (state.ui.colorBy === 'kin') {
                value = 'No'; // Ego is never kin to themselves
            } else if (state.ui.colorBy === 'weekly_hours') {
                value = 0; // Ego typically doesn't have weekly hours, so use 0 (≤3h category)
            }
            
            const palette = colorPalettes[state.ui.colorBy];
            
            // Special handling for different modes
            if (state.ui.colorBy === 'language') {
                const languages = normalizeLanguage(value);
                if (languages.length > 0) {
                    const firstLang = languages[0];
                    return getLanguageColor(firstLang, 0);
                }
                return '#cccccc';
            } else if (state.ui.colorBy === 'race') {
                const canonicalRace = canonRace(value);
                return palette[canonicalRace] || '#cccccc';
            } else if (state.ui.colorBy === 'kin') {
                const canonicalKin = canonKin(value);
                return palette[canonicalKin] || '#cccccc';
            } else if (state.ui.colorBy === 'weekly_hours') {
                // Categorize weekly hours value
                const hours = parseFloat(value || 0);
                let category;
                if (hours <= 3) {
                    category = '≤3h';
                } else if (hours <= 10) {
                    category = '3-10h';
                } else if (hours <= 30) {
                    category = '11-30h';
                } else if (hours <= 60) {
                    category = '30-60h';
                } else {
                    category = '>60h';
                }
                return palette[category] || '#cccccc';
            }
            
            return palette && palette[value] ? palette[value] : '#cccccc';
        }
  
        function calculateQuantileBuckets(values, buckets = 5) {
            const sorted = values.filter(v => !isNaN(v) && v !== null && v !== undefined).sort((a, b) => a - b);
            if (sorted.length === 0) return [];
            
            const quantiles = [];
            for (let i = 1; i <= buckets; i++) {
                const index = Math.ceil((i / buckets) * sorted.length) - 1;
                quantiles.push(sorted[Math.min(index, sorted.length - 1)]);
            }
            return quantiles;
        }
  
        function getNodeSizeFromValue(value, quantiles, sizes = [35, 40, 45, 50, 55]) {
            if (!quantiles || quantiles.length === 0) return sizes[0];
            
            for (let i = 0; i < quantiles.length; i++) {
                if (value <= quantiles[i]) {
                    return sizes[i] || sizes[sizes.length - 1];
                }
            }
            return sizes[sizes.length - 1];
        }
  
        function getNodeSize(node) {
            const minSize = 35;
            
            if (state.ui.nodeSizeBy === 'weekly_hours_percent') {
                const hours = parseFloat(node.data?.node_weekly_hour_summarized || node.data?.node_weekly_hour || 0);
                
                if (!state.current.hourQuantiles) {
                    const allHours = state.current.nodeData.map(d => 
                        parseFloat(d.node_weekly_hour_summarized || d.node_weekly_hour || 0)
                    );
                    state.current.hourQuantiles = calculateQuantileBuckets(allHours);
                }
                
                return Math.max(minSize, getNodeSizeFromValue(hours, state.current.hourQuantiles));
            } else if (state.ui.nodeSizeBy === 'closeness') {
                const closeness = parseFloat(node.data?.node_closeness_score || 0);
                // Discrete buckets: 0,1,2,3,4
                const sizesFixed = [35, 40, 45, 50, 55];
                if (isNaN(closeness)) return sizesFixed[0];
                const idx = Math.max(0, Math.min(4, Math.round(closeness)));
                return sizesFixed[idx];
            } else if (state.ui.nodeSizeBy === 'closeness_scale') {
                const closenessScale = parseFloat(node.data?.node_closeness_scale || 0);
                // Discrete buckets: 0,1,2,3,4,5,6 (7 levels)
                const sizesFixed = [30, 35, 40, 45, 50, 55, 60];
                if (isNaN(closenessScale)) return sizesFixed[0];
                const idx = Math.max(0, Math.min(6, Math.round(closenessScale)));
                return sizesFixed[idx];
            } else if (state.ui.nodeSizeBy === 'context_count') {
                // Use node_context_count from node_level_long
                const contextCount = parseInt(node.data?.node_context_count || node.data?.context_count || 0);
                // Discrete buckets: 0,1,2,3,4+
                const sizesFixed = [35, 40, 45, 50, 55];
                if (isNaN(contextCount)) return sizesFixed[0];
                const idx = Math.max(0, Math.min(4, contextCount));
                return sizesFixed[idx];
            }
            return minSize;
        }
  
        function updateSizeLegend() {
            const sizeLegendSection = document.getElementById('sizeLegendSection');
            const sizeLegendTitle = document.getElementById('sizeLegendTitle');
            const sizeLegendItems = document.getElementById('sizeLegendItems');
            
            // Add null checks to prevent errors
            if (!sizeLegendSection || !sizeLegendTitle || !sizeLegendItems) {
                console.log('Size legend elements not found, skipping update');
                return;
            }
            
            if (state.ui.nodeSizeBy === 'default') {
                sizeLegendSection.style.display = 'none';
                return;
            }
            
            sizeLegendSection.style.display = 'block';
            const sizeLabels = {
                'weekly_hours_percent': 'Node Size: Weekly Hours (%)',
                'closeness': 'Node Size: Closeness Score',
                'closeness_scale': 'Node Size: Closeness Scale',
                'context_count': 'Node Size: Context Count'
            };
            sizeLegendTitle.textContent = sizeLabels[state.ui.nodeSizeBy] || 'Node Size';
            
            let legendItems = '';
            const sizes = [35, 40, 45, 50, 55];
            
            if (state.ui.nodeSizeBy === 'weekly_hours_percent' && state.current.hourQuantiles) {
                const quantiles = state.current.hourQuantiles;
                let prevValue = 0;
                
                quantiles.forEach((quantile, i) => {
                    const rangeLabel = i === 0 ? `≤${quantile}h` : 
                                     i === quantiles.length - 1 ? `>${prevValue}h` :
                                     `${prevValue + 0.1}-${quantile}h`;
                    
                    legendItems += `
                        <div class="size-legend-item">
                            <div class="size-circle" style="width: ${sizes[i] * 2}px; height: ${sizes[i] * 2}px;"></div>
                            <span>${rangeLabel}</span>
                        </div>
                    `;
                    prevValue = quantile;
                });
            } else if (state.ui.nodeSizeBy === 'closeness') {
                const buckets = ['0','1','2','3','4'];
                buckets.forEach((label, i) => {
                    legendItems += `
                        <div class="size-legend-item">
                            <div class="size-circle" style="width: ${sizes[i] * 2}px; height: ${sizes[i] * 2}px;"></div>
                            <span>${label}</span>
                        </div>
                    `;
                });
            } else if (state.ui.nodeSizeBy === 'closeness_scale') {
                const buckets = ['0','1','2','3','4','5','6'];
                const scaleSizes = [30, 35, 40, 45, 50, 55, 60];
                buckets.forEach((label, i) => {
                    legendItems += `
                        <div class="size-legend-item">
                            <div class="size-circle" style="width: ${scaleSizes[i] * 2}px; height: ${scaleSizes[i] * 2}px;"></div>
                            <span>${label}</span>
                        </div>
                    `;
                });
            } else if (state.ui.nodeSizeBy === 'context_count') {
                const buckets = ['0','1','2','3','4+'];
                buckets.forEach((label, i) => {
                    legendItems += `
                        <div class="size-legend-item">
                            <div class="size-circle" style="width: ${sizes[i] * 2}px; height: ${sizes[i] * 2}px;"></div>
                            <span>${label}</span>
                        </div>
                    `;
                });
            } else if (state.ui.nodeSizeBy === 'closeness_intensity_z' && state.current.closenessIntensityQuantiles) {
                const quantiles = state.current.closenessIntensityQuantiles;
                let prevValue = -Infinity;
                
                quantiles.forEach((quantile, i) => {
                    const rangeLabel = i === 0 ? `≤${quantile.toFixed(2)}` : 
                                     i === quantiles.length - 1 ? `>${prevValue.toFixed(2)}` :
                                     `${prevValue.toFixed(2)}-${quantile.toFixed(2)}`;
                    
                    legendItems += `
                        <div class="size-legend-item">
                            <div class="size-circle" style="width: ${sizes[i] * 2}px; height: ${sizes[i] * 2}px;"></div>
                            <span>${rangeLabel}</span>
                        </div>
                    `;
                    prevValue = quantile;
                });
            }
            
            if (legendItems) {
                sizeLegendItems.innerHTML = legendItems;
                sizeLegendSection.style.display = 'block';
            } else {
                sizeLegendSection.style.display = 'none';
            }
        }
  
        function truncateName(name, radius) {
            const maxChars = Math.floor(radius / 4);
            return name.length > maxChars ? name.slice(0, maxChars - 1) + '…' : name;
        }
  
        function updateLegend() {
            const colorLegendTitle = document.getElementById('colorLegendTitle');
            const colorLegendItems = document.getElementById('colorLegendItems');
            
            // Add null checks to prevent errors
            if (!colorLegendTitle || !colorLegendItems) {
                console.log('Color legend elements not found, skipping update');
                return;
            }
            
            // Update legend title based on color mode
            const colorModeMap = {
                'context': 'Color by: Context',
                'gender': 'Color by: Gender', 
                'race': 'Color by: Race',
                'language': 'Color by: Language',
                'kin': 'Color by: Kin',
                'age_categorized': 'Color by: Age Category'
            };
            colorLegendTitle.textContent = colorModeMap[state.ui.colorBy] || 'Color by: Context';
            
            colorLegendItems.innerHTML = '';
  
            // Add ego only for kin mode (since ego is not kin)
            if (state.ui.colorBy === 'kin') {
                const egoItem = document.createElement('div');
                egoItem.className = 'legend-item';
                egoItem.innerHTML = `
                    <div style="width: 16px; height: 16px; background: #2C7BE5; border-radius: 3px; border: 1px solid rgba(0,0,0,0.2);"></div>
                    <span>Child (Ego)</span>
                `;
                colorLegendItems.appendChild(egoItem);
            }
  
            if (state.ui.colorBy === 'context') {
                // Add context colors
                const activeContexts = new Set();
                
                // Find active activity contexts
                if (state.current.nodeData) {
                    state.current.nodeData.forEach(alter => {
                        const context = canonContext(alter.node_type);
                        activeContexts.add(context);
                    });
                }
  
                // Add base contexts that are visible
            Object.entries(CONTEXTS).forEach(([key, config]) => {
                    if (state.ui.visibleContexts.has(key) && activeContexts.has(key)) {
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    item.innerHTML = `
                        <div class="legend-color" style="background: ${config.color};"></div>
                        <span>${config.label}</span>
                    `;
                        colorLegendItems.appendChild(item);
                    }
                });
  
                // Add specific activity contexts
                Array.from(activeContexts).filter(ctx => ctx.startsWith('activity_')).forEach(activityContext => {
                    const activityId = activityContext.split('_')[1];
                    const activityData = state.data.activityIndex[state.current.child]?.[activityId];
                    const activityLabel = `Activity ${activityId}${activityData?.activity_name ? ': ' + activityData.activity_name : ''}`;
                    const color = getContextColor(activityContext);
  
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    item.innerHTML = `
                        <div class="legend-color" style="background: ${color};"></div>
                        <span>${activityLabel}</span>
                    `;
                    colorLegendItems.appendChild(item);
                });
            } else {
                // Color by demographic - show categories with counts
                const categories = new Map();
                
                if (state.current.nodeData) {
                    const filteredData = applyFilters(state.current.nodeData);
                    
                    filteredData.forEach(alter => {
                        if (state.ui.colorBy === 'language') {
                            // Handle multilingual nodes
                            const languages = normalizeLanguage(alter.node_language);
                            languages.forEach(lang => {
                                categories.set(lang, (categories.get(lang) || 0) + 1);
                            });
                        } else if (state.ui.colorBy === 'race') {
                            const canonicalRace = canonRace(alter.node_race);
                            categories.set(canonicalRace, (categories.get(canonicalRace) || 0) + 1);
                        } else if (state.ui.colorBy === 'kin') {
                            const canonicalKin = canonKin(alter.node_kin);
                            categories.set(canonicalKin, (categories.get(canonicalKin) || 0) + 1);
                        } else if (state.ui.colorBy === 'age_categorized') {
                            const value = alter.node_age_categorized || '?';
                            categories.set(value, (categories.get(value) || 0) + 1);
                        } else {
                            const value = alter[`node_${state.ui.colorBy}`] || '?';
                            categories.set(value, (categories.get(value) || 0) + 1);
                        }
                    });
                }
  
                const colorPalettes = {
                    gender: {
                        'Male': '#4e79a7',
                        'Female': '#f28e2c',
                        'Other': '#e15759'
                    },
                    race: {
                        'White': '#76b7b2',
                        'Black': '#59a14f',
                        'Hispanic/Latino': '#edc949',
                        'Asian': '#af7aa1',
                        'Native/Alaska': '#8dd3c7',
                        'MENA': '#fb8072',
                        'Multiracial': '#bc80bd',
                        'Other': '#d9d9d9'
                    },
                    language: {
                        'English': '#1f77b4',
                        'German': '#ff7f0e', 
                        'Spanish': '#2ca02c',
                        'Portuguese': '#d62728',
                        'Italian': '#9467bd',
                        'Thai': '#8c564b',
                        'Pre-verbal/Non-verbal': '#7f7f7f',
                        'Unknown': '#cccccc'
                    },
                    kin: {
                        'Yes': '#E53935',
                        'No': '#9CA3AF'
                    },
                    age_categorized: {
                        'Younger than 2 years old': '#FFD700',  // Gold/Yellow
                        '2-5 years old': '#FF6B35',              // Bright Orange
                        '6-12 years old': '#4ECDC4',             // Teal
                        '13-17 years old': '#45B7D1',            // Sky Blue
                        '18 years old or older': '#96CEB4'       // Mint Green
                    }
                };
  
                const palette = colorPalettes[state.ui.colorBy] || {};
                
                // Sort categories for age_categorized
                let sortedCategories = Array.from(categories.entries());
                if (state.ui.colorBy === 'age_categorized') {
                    const ageOrder = [
                        'Younger than 2 years old',
                        '2-5 years old', 
                        '6-12 years old',
                        '13-17 years old',
                        '18 years old or older'
                    ];
                    sortedCategories.sort((a, b) => {
                        const indexA = ageOrder.indexOf(a[0]);
                        const indexB = ageOrder.indexOf(b[0]);
                        return indexA - indexB;
                    });
                }
                
                sortedCategories.forEach(([value, count], index) => {
                    let color;
                    if (state.ui.colorBy === 'language') {
                        color = getLanguageColor(value, index);
                    } else {
                        color = palette[value] || '#cccccc';
                    }
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    item.innerHTML = `
                        <div class="legend-color" style="background: ${color};"></div>
                        <span>${value} (${count})</span>
                    `;
                    colorLegendItems.appendChild(item);
                });
            }
        }
  
        function showContextInfo(groupKey, group) {
            const panel = document.getElementById('contextPanel');
            const title = document.getElementById('contextTitle');
            const content = document.getElementById('contextContent');
            
            title.textContent = `${group.label} Information`;
            
            let contextDetails = '';
            
            if (group.context === 'daycare') {
                const childData = state.current.childData;
                if (childData) {
                    contextDetails = `
                        <div class="info-row">
                            <span class="info-label">Childcare Type:</span>
                            <span class="info-value">${formatChildcareType(childData.childcare_type)}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Start Age:</span>
                            <span class="info-value">${childData.childcare_start_age ? Math.round(parseFloat(childData.childcare_start_age)) : 'N/A'} months</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Group Size:</span>
                            <span class="info-value">${childData.childcare_size ? Math.round(parseFloat(childData.childcare_size)) : 'N/A'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Child Gender:</span>
                            <span class="info-value">${childData.child_gender || 'N/A'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Child Race:</span>
                            <span class="info-value">${childData.child_race || 'N/A'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Child Language:</span>
                            <span class="info-value">${childData.child_lang || 'N/A'}</span>
                        </div>
                    `;
                }
            } else if (group.context.startsWith('activity_')) {
                const activityId = group.context.split('_')[1];
                const activityData = state.data.activityIndex[state.current.child]?.[activityId];
                const childData = state.current.childData;
                
                if (activityData) {
                    contextDetails = `
                        <div class="info-row">
                            <span class="info-label">Activity Name:</span>
                            <span class="info-value">${activityData.activity_name || 'N/A'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Other Kids:</span>
                            <span class="info-value">${activityData.activity_otherkids_yn || 'N/A'}</span>
                        </div>
                        ${activityData.activity_otherkids_yn === 'Yes' ? `
                        <div class="info-row">
                            <span class="info-label"># Other Kids:</span>
                            <span class="info-value">${activityData.activity_otherkids_n || 'N/A'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Age Group:</span>
                            <span class="info-value">${activityData.activity_kids || 'N/A'}</span>
                        </div>
                        ` : ''}
                        <div class="info-row">
                            <span class="info-label">Child Gender:</span>
                            <span class="info-value">${activityData.activity_gender || childData?.child_gender || 'N/A'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Child Race:</span>
                            <span class="info-value">${activityData.activity_race || childData?.child_race || 'N/A'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Language Used:</span>
                            <span class="info-value">${activityData.activity_lang || childData?.child_lang || 'N/A'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Adults in Activity:</span>
                            <span class="info-value">${activityData.activity_adults || 'N/A'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Kids in Activity:</span>
                            <span class="info-value">${activityData.activity_kids || 'N/A'}</span>
                        </div>
                    `;
                }
            }
            
            // List of alters in this context
            const alterList = group.alters.map(alter => {
                const role = alter.data.node_relationship || alter.data.node_type || 'Unknown';
                return `<div style="margin: 0.25rem 0;">${alter.name} (${role})</div>`;
            }).join('');
            
            content.innerHTML = `
                <div class="info-row">
                    <span class="info-label">Context:</span>
                    <span class="info-value">${group.label}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Number of Alters:</span>
                    <span class="info-value">${group.alters.length}</span>
                </div>
                ${contextDetails}
                <div style="margin-top: 1.5rem; border-top: 2px solid #e9ecef; padding-top: 1rem;">
                    <div style="font-weight: 600; margin-bottom: 0.75rem; color: #495057;">Alters in this Context:</div>
                    ${alterList}
                </div>
            `;
            
            showPanel(panel);
        }
  
        function selectAlterNode(alter) {
            console.log('Selecting alter:', alter.id, alter.data?.node_name);
            
            // Set selection state
            state.ui.selectedAlter = alter;
            state.ui.selectedContext = null;
            state.ui.detailsType = 'alter';
            
            // Hide hover tooltip immediately on click
            const tooltip = document.getElementById('tooltip');
            if (tooltip) { tooltip.style.opacity = '0'; tooltip.style.display = 'none'; }
            
            // Redraw edges to reflect current visibility setting
            if (state.current.nodeEdges && state.current.nodeEdges.length > 0) {
                redrawAlterEdges();
            }
            
            // Update visual highlighting with exact colors
            updateNodeSelection();
            
            // Show unified bottom details bar with alter info
            showUnifiedDetails('alter', alter);
        }
  
        function selectAlter(alter) {
            selectAlterNode(alter);
        }
  
        function selectContextBox(groupKey, group) {
            // Clear alter selection and set context selection
            state.ui.selectedAlter = null;
            state.ui.selectedContext = { groupKey, group };
            state.ui.detailsType = 'context';
            
            // Clear visual highlighting
            clearVisualSelection();
            
            // Show unified details card with context info
            showUnifiedDetails('context', { groupKey, group });
            
            // Ensure info icons are still present after selection
            ensureInfoIcons();
        }
  
        function clearSelection() {
            state.ui.selectedNode = null;
            state.ui.selectedContext = null;
            state.ui.detailsType = null;
            
            const unifiedDetails = document.getElementById('unifiedDetailsCard');
            const fixedDetails = document.getElementById('fixedDetailsPanel');
            const nodeDetails = document.getElementById('nodeDetailsSection');
            
            if (unifiedDetails) unifiedDetails.style.display = 'none';
            if (fixedDetails) fixedDetails.style.display = 'none';
            if (nodeDetails) nodeDetails.style.display = 'none';
            
            clearVisualSelection();
        }
  
        function ensureInfoIcons() {
            // Ensure all clickable context boxes have info icons
            d3.selectAll('.context-box.clickable').each(function() {
                const boxGroup = d3.select(this);
                const groupKey = boxGroup.attr('data-context-key');
                
                if (groupKey && (groupKey.includes('daycare') || groupKey.includes('activity_'))) {
                    // Check if info icon already exists
                    if (boxGroup.select('.info-icon').empty()) {
                        console.log('Recreating missing info icon for:', groupKey);
                        
                        const boxRect = boxGroup.select('rect');
                        const boxX = parseFloat(boxRect.attr('x'));
                        const boxY = parseFloat(boxRect.attr('y'));
                        const boxWidth = parseFloat(boxRect.attr('width'));
                        
                        const iconSize = 16;
                        const iconX = boxX + boxWidth - iconSize - 6;
                        const iconY = boxY + 6;
                        
                        // Create info icon group
                        const infoIcon = boxGroup.append('g')
                            .attr('class', 'info-icon')
                            .attr('id', `info-icon-${groupKey}`)
                            .style('pointer-events', 'none')
                            .attr('transform', `translate(${iconX}, ${iconY})`);
                        
                        // Draw info icon as a single SVG path (question mark in circle)
                        infoIcon.append('path')
                            .attr('d', `M8,0C3.6,0,0,3.6,0,8s3.6,8,8,8s8-3.6,8-8S12.4,0,8,0z M8,14c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S11.3,14,8,14z M8,4c-1.1,0-2,0.9-2,2h1c0-0.6,0.4-1,1-1s1,0.4,1,1c0,1-1.5,1.5-1.5,2.5h1c0-0.8,1.5-1.2,1.5-2.5C10,4.9,9.1,4,8,4z M7,10h2v1H7V10z`)
                            .style('fill', '#8b0000')
                            .style('opacity', 0.9);
                    }
                }
            });
        }
  
        function clearVisualSelection() {
            // Remove context-mode class
            document.body.classList.remove('context-mode');
            
            // Reset all nodes to normal state by removing CSS classes
            const nodeCount = d3.selectAll('.alter-node')
                .classed('node--selected', false)
                .classed('node--neighbor', false)
                .size();
            
            // Reset ALL edges to default styling by removing CSS classes
            const edgeCount = d3.selectAll('.alter-edge')
                .classed('edge--active', false)
                .size();
            
            // Only clear edge styles if we're not in "all ties" mode
            // This ensures edges remain visible when Edge Visibility is set to "All ties (default)"
            if (state.ui.edgeVisibility !== 'all') {
                d3.selectAll('.alter-edge')
                    .style('stroke', null)
                    .style('stroke-width', null)
                    .style('opacity', null);
            } else {
                // In "all ties" mode, restore default edge styling
                d3.selectAll('.alter-edge').each(function() {
                    const element = d3.select(this);
                    element.style('stroke', '#4A5568')
                          .style('stroke-width', '1.5px')
                          .style('opacity', '0.35');
                });
            }
            
            console.log(`Cleared ${nodeCount} nodes and ${edgeCount} edges`);
        }
  
        function updateNodeSelection() {
            if (!state.ui.selectedAlter) return;
            
            const selectedId = state.ui.selectedAlter.id;
            
            // Clear previous visual selections first
            d3.selectAll('.alter-node')
                .classed('node--selected', false)
                .classed('node--neighbor', false);
            
            // Get neighbors of selected alter (direct connections only)
            const neighbors = new Set();
            state.current.nodeEdges.forEach(edge => {
                if (edge.source === selectedId) neighbors.add(edge.target);
                if (edge.target === selectedId) neighbors.add(edge.source);
            });
            
            // Update all alter nodes with CSS classes
            d3.selectAll('.alter-node').each(function(d) {
                if (!d) return;
                
                const nodeElement = d3.select(this);
                const isSelected = d.id === selectedId;
                const isNeighbor = neighbors.has(d.id);
                
                if (isSelected) {
                    nodeElement.classed('node--selected', true);
                } else if (isNeighbor) {
                    nodeElement.classed('node--neighbor', true);
                }
            });
            
            // Only apply context-mode class for context color mode
            if (state.ui.colorBy === 'context') {
                document.body.classList.add('context-mode');
            } else {
                document.body.classList.remove('context-mode');
            }
            
            // Update edges with inline styles - only for current selection
            d3.selectAll('.alter-edge').each(function() {
                const element = d3.select(this);
                const source = element.attr('data-source');
                const target = element.attr('data-target');
                const isConnectedToSelected = source === selectedId || target === selectedId;
                
                if (isConnectedToSelected) {
                    // Apply red styling to selected edges
                    element.style('stroke', '#ef4444')
                          .style('stroke-width', '3.5px')
                          .style('opacity', '0.95');
                } else {
                    // Reset to default styling for non-selected edges
                    element.style('stroke', '#4A5568')
                          .style('stroke-width', '1.5px')
                          .style('opacity', '0.35');
                }
            });
            
            // Bring selected node to front
            d3.selectAll('.alter-node').each(function(d) {
                if (d && d.id === selectedId) {
                    d3.select(this).raise();
                }
            });
        }
  
        function showUnifiedDetails(type, data) {
            // Render into fixed bottom details bar
            const panel = document.getElementById('bottomDetails');
            const title = document.getElementById('bottomDetailsTitle');
            const content = document.getElementById('bottomDetailsContent');
            
            if (type === 'alter') {
                showAlterDetails(title, content, data);
            } else if (type === 'context') {
                showContextDetails(title, content, data.group, data.groupKey);
            }
            
            panel.style.display = 'block';
            updateBottomDetailsLeft();
        }
  
        function showAlterDetails(title, content, alter) {
            title.textContent = 'Selected Alter';
            const d = alter.data;
  
            // Calculate hours percentage of week
            const weeklyHours = parseFloat(d.node_weekly_hour_summarized || d.node_weekly_hour || 0);
            const hoursPercent = ((weeklyHours / 168) * 100).toFixed(1);
            
            content.innerHTML = `
                <div class="details-grid-four">
                <div class="info-row">
                    <span class="info-label">Name:</span>
                    <span class="info-value">${d.node_name || '?'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Role/Relationship:</span>
                    <span class="info-value">${d.node_relationship || d.node_type || '?'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Gender:</span>
                    <span class="info-value">${d.node_gender || '?'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Age:</span>
                    <span class="info-value">${(() => {
                        const isSibling = false;
                        const categorizedAge = d.node_age_categorized || 'Unknown';
                        const ageInMonths = d.node_age_in_months;
                        
                        if (isSibling && ageInMonths) {
                            return `${categorizedAge} (${ageInMonths} months)`;
                        } else {
                            return categorizedAge;
                        }
                    })()}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Race:</span>
                    <span class="info-value">${d.node_race || '?'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Language:</span>
                    <span class="info-value">${d.node_language || '?'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Accent:</span>
                    <span class="info-value">${d.node_accent_specific || d.node_accent_categorized || '?'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Kin:</span>
                    <span class="info-value">${d.node_kin === '1' ? 'Yes' : d.node_kin === '0' ? 'No' : d.node_kin || '?'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Mode of Contact:</span>
                    <span class="info-value">${d.node_mode_of_contact || '?'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Contact Context:</span>
                    <span class="info-value">${parseContactContext(d.node_context) || '?'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Weekly Hours:</span>
                    <span class="info-value">${weeklyHours || '?'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Hours % of week:</span>
                    <span class="info-value">${hoursPercent}%</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Closeness Score:</span>
                    <span class="info-value">${d.node_closeness_score || '?'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Closeness Scale:</span>
                    <span class="info-value">${d.node_closeness_scale || '?'}</span>
                </div>
                        </div>
            `;
        }
  
        function showContextDetails(title, content, group, groupKey) {
            title.textContent = `Context Details: ${group.label}`;
            
            let contextDetails = '';
            
            if (group.context === 'daycare') {
                const childData = state.current.childData;
                if (childData) {
                    contextDetails = `
                        <div class="info-row">
                            <span class="info-label">Nonparental Care Type:</span>
                            <span class="info-value">${formatChildcareType(childData.childcare_type)}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Start Age (months):</span>
                            <span class="info-value">${childData.childcare_start_age ? Math.round(parseFloat(childData.childcare_start_age)) : '?'}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Group Size:</span>
                            <span class="info-value">${childData.childcare_size ? Math.round(parseFloat(childData.childcare_size)) : '?'}</span>
                        </div>
                    `;
                }
            }
            
            content.innerHTML = `
                <div class="details-grid-four">
                ${contextDetails}
                </div>
            `;
        }
  
        function positionUnifiedCard(card) {
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const legend = document.getElementById('legend');
            
            // Start with default position - always bottom-right, never center
            let bottom = 20;
            let right = 20;
            
            // Position card and check for legend overlap
            card.style.position = 'fixed';
            card.style.bottom = bottom + 'px';
            card.style.right = right + 'px';
            card.style.left = 'auto';
            card.style.top = 'auto';
            card.style.zIndex = '2000';
            card.style.display = 'block'; // Ensure visible for bbox calculations
            
            // Get bounding boxes for overlap detection
            const cardRect = card.getBoundingClientRect();
            const legendRect = legend.getBoundingClientRect();
            
            // Check for overlap and adjust position iteratively (detect collision and shift left)
            let attempts = 0;
            while (attempts < 5 && cardRect.left < legendRect.right + 10 && 
                   cardRect.bottom > legendRect.top - 10) {
                
                if (windowWidth < 1200) {
                    // On smaller screens, move down first, then left
                    if (attempts < 2) {
                        bottom += 24;
                    } else {
                        right += 24;
                    }
                } else {
                    // On larger screens, move left to avoid legend
                    right += 24;
                }
                
                card.style.bottom = bottom + 'px';
                card.style.right = right + 'px';
                
                // Recalculate after position change
                const newCardRect = card.getBoundingClientRect();
                cardRect.left = newCardRect.left;
                cardRect.bottom = newCardRect.bottom;
                
                attempts++;
            }
            
            // Ensure card doesn't go off-screen (never overlap network area)
            const cardHeight = card.offsetHeight;
            const cardWidth = card.offsetWidth;
            const availableHeight = windowHeight - 40; // Margin from top/bottom
            
            // Prevent covering network area - ensure card stays in UI zone
            const mainContentWidth = windowWidth - 380; // Subtract sidebar width
            if (cardWidth > mainContentWidth * 0.4) { // Max 40% of network area width
                card.style.maxWidth = (mainContentWidth * 0.4) + 'px';
            }
            
            if (cardHeight > availableHeight) {
                card.style.maxHeight = availableHeight + 'px';
                card.style.overflowY = 'auto';
            }
            
            // Ensure minimum distance from edges but keep modest size
            if (right < 20) right = 20;
            if (bottom < 20) bottom = 20;
            
            // Final positioning - always visible but modest
            card.style.bottom = bottom + 'px';
            card.style.right = right + 'px';
        }
  
        function isShowingRespondent(alter) {
            // Check if this alter is the survey respondent
            if (!state.current.childData || !state.current.childData.name_filloutsurvey_1) {
                return false;
            }
            
            const respondentCode = normId(state.current.childData.name_filloutsurvey_1);
            const alterCode = normId(alter.data.node_mapping_code);
            
            return respondentCode && alterCode && respondentCode === alterCode;
        }
  
  
  
        function closeUnifiedDetails() {
            document.getElementById('unifiedDetailsCard').style.display = 'none';
            state.ui.selectedAlter = null;
            state.ui.selectedContext = null;
            state.ui.detailsType = null;
            clearVisualSelection();
        }
  
        function showResizableDetails(alter) {
            const panel = document.getElementById('resizableDetailsPanel');
            const content = document.getElementById('resizableDetailsContent');
            
            if (!alter || !alter.data) {
                panel.style.display = 'none';
                return;
            }
            
            const d = alter.data;
            
            // Build the content HTML
            content.innerHTML = `
                <div class="info-row">
                    <span class="info-label">Name:</span>
                    <span class="info-value">${alter.name || d.node_name || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Role/Relationship:</span>
                    <span class="info-value">${d.node_relationship || d.node_type || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Gender:</span>
                    <span class="info-value">${d.node_gender || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Age:</span>
                    <span class="info-value">${(() => {
                        // For sibling alters, show both categorized age and months if available
                        const isSibling = false;
                        const categorizedAge = d.node_age_categorized || 'Unknown';
                        const ageInMonths = d.node_age_in_months;
                        
                        if (isSibling && ageInMonths) {
                            return `${categorizedAge} (${ageInMonths} months)`;
                        } else {
                            return categorizedAge;
                        }
                    })()}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Race:</span>
                    <span class="info-value">${d.node_race || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Language:</span>
                    <span class="info-value">${d.node_language || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Kin:</span>
                    <span class="info-value">${d.node_kin || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Lives at Home:</span>
                    <span class="info-value">${d.node_liveathome_or_not || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Mode of Contact:</span>
                    <span class="info-value">${d.node_mode_of_contact || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Contact Context:</span>
                    <span class="info-value">${parseContactContext(d.node_context)}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Weekly Hours:</span>
                    <span class="info-value">${d.node_weekly_hour_summarized || d.node_weekly_hour || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Hours % of week:</span>
                    <span class="info-value">${d.node_weekly_hour_percent ? d.node_weekly_hour_percent + '%' : 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Closeness Score:</span>
                    <span class="info-value">${d.node_closeness_score || 'N/A'}</span>
                </div>
            `;
            
            // Show the panel
            panel.style.display = 'block';
            
            // Make it draggable and resizable
            makeElementDraggable(panel);
            makeElementResizable(panel);
        }
  
        function closeResizableDetails() {
            document.getElementById('resizableDetailsPanel').style.display = 'none';
        }
  
        function makeElementDraggable(element) {
            let isDragging = false;
            let startX, startY, startLeft, startTop;
            
            const header = element.querySelector('.panel-header');
            
            header.addEventListener('mousedown', function(e) {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startLeft = parseInt(window.getComputedStyle(element).left, 10);
                startTop = parseInt(window.getComputedStyle(element).top, 10);
                
                element.style.cursor = 'grabbing';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                const newLeft = startLeft + (e.clientX - startX);
                const newTop = startTop + (e.clientY - startY);
                
                // Keep panel within viewport bounds
                const maxLeft = window.innerWidth - element.offsetWidth;
                const maxTop = window.innerHeight - element.offsetHeight;
                
                element.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
                element.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';
            });
            
            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    element.style.cursor = 'move';
                }
            });
        }
  
        function makeElementResizable(element) {
            const handles = element.querySelectorAll('.resize-handle');
            
            handles.forEach(handle => {
                handle.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const direction = handle.className.split(' ')[1].replace('resize-handle-', '');
                    const startX = e.clientX;
                    const startY = e.clientY;
                    const startWidth = parseInt(window.getComputedStyle(element).width, 10);
                    const startHeight = parseInt(window.getComputedStyle(element).height, 10);
                    const startLeft = parseInt(window.getComputedStyle(element).left, 10);
                    const startTop = parseInt(window.getComputedStyle(element).top, 10);
                    
                    function doResize(e) {
                        const deltaX = e.clientX - startX;
                        const deltaY = e.clientY - startY;
                        
                        let newWidth = startWidth;
                        let newHeight = startHeight;
                        let newLeft = startLeft;
                        let newTop = startTop;
                        
                        if (direction.includes('e')) {
                            newWidth = Math.max(250, Math.min(500, startWidth + deltaX));
                        }
                        if (direction.includes('w')) {
                            newWidth = Math.max(250, Math.min(500, startWidth - deltaX));
                            newLeft = startLeft + (startWidth - newWidth);
                        }
                        if (direction.includes('s')) {
                            newHeight = Math.max(200, Math.min(window.innerHeight - 100, startHeight + deltaY));
                        }
                        if (direction.includes('n')) {
                            newHeight = Math.max(200, Math.min(window.innerHeight - 100, startHeight - deltaY));
                            newTop = startTop + (startHeight - newHeight);
                        }
                        
                        // Apply constraints to keep panel within viewport
                        if (newLeft < 0) {
                            newWidth += newLeft;
                            newLeft = 0;
                        }
                        if (newTop < 0) {
                            newHeight += newTop;
                            newTop = 0;
                        }
                        if (newLeft + newWidth > window.innerWidth) {
                            newWidth = window.innerWidth - newLeft;
                        }
                        if (newTop + newHeight > window.innerHeight) {
                            newHeight = window.innerHeight - newTop;
                        }
                        
                        element.style.width = newWidth + 'px';
                        element.style.height = newHeight + 'px';
                        element.style.left = newLeft + 'px';
                        element.style.top = newTop + 'px';
                        
                        // Update content area height to maintain scrolling
                        const content = element.querySelector('.panel-content');
                        if (content) {
                            const headerHeight = 60; // Approximate header height
                            const contentHeight = newHeight - headerHeight;
                            content.style.height = Math.max(200, contentHeight) + 'px';
                        }
                    }
                    
                    function stopResize() {
                        document.removeEventListener('mousemove', doResize);
                        document.removeEventListener('mouseup', stopResize);
                    }
                    
                    document.addEventListener('mousemove', doResize);
                    document.addEventListener('mouseup', stopResize);
                });
            });
        }
  
        function closeFixedDetails() {
            document.getElementById('fixedDetailsPanel').style.display = 'none';
            state.ui.selectedAlter = null;
            state.ui.selectedContext = null;
            state.ui.detailsType = null;
            clearVisualSelection();
        }
  
        function showAlterInfoInSidebar(alter) {
            selectAlter(alter);
        }
  
        function showAlterInfo(alter) {
            const panel = document.getElementById('alterPanel');
            const content = document.getElementById('alterContent');
            const d = alter.data;
            
            content.innerHTML = `
                <div class="info-row">
                    <span class="info-label">Name:</span>
                    <span class="info-value">${d.node_name || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Type:</span>
                    <span class="info-value">${d.node_type || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Relationship:</span>
                    <span class="info-value">${d.node_relationship || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Context:</span>
                    <span class="info-value">${parseContactContext(d.node_context)}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Gender:</span>
                    <span class="info-value">${d.node_gender || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Age:</span>
                    <span class="info-value">${(() => {
                        const isSibling = false;
                        const categorizedAge = d.node_age_categorized || 'Unknown';
                        const ageInMonths = d.node_age_in_months;
                        
                        if (isSibling && ageInMonths) {
                            return `${categorizedAge} (${ageInMonths} months)`;
                        } else {
                            return categorizedAge;
                        }
                    })()}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Race:</span>
                    <span class="info-value">${d.node_race || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Language:</span>
                    <span class="info-value">${d.node_language || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Kin:</span>
                    <span class="info-value">${d.node_kin || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Lives at Home:</span>
                    <span class="info-value">${d.node_liveathome_or_not || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Weekly Hours:</span>
                    <span class="info-value">${d.node_weekly_hour_summarized || d.node_weekly_hour || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Closeness Score:</span>
                    <span class="info-value">${d.node_closeness_score || 'N/A'}</span>
                </div>
            `;
            
            showPanel(panel);
        }
  
        function showEgoInfo() {
            // Populate fixed bottom details with child info
            const child = state.current.childData;
            const panel = document.getElementById('bottomDetails');
            if (!child || !panel) return;
            document.getElementById('bottomDetailsTitle').textContent = child.child_name || 'Child';
            document.getElementById('bottomDetailsContent').innerHTML = `
                <div class="details-grid-two">
                <div class="info-row"><span class="info-label">Child:</span><span class="info-value">${child.child_name || '—'}</span></div>
                <div class="info-row"><span class="info-label">Gender:</span><span class="info-value">${child.child_gender || '—'}</span></div>
                <div class="info-row"><span class="info-label">Race:</span><span class="info-value">${child.child_race || '—'}</span></div>
                <div class="info-row"><span class="info-label">Language:</span><span class="info-value">${child.child_lang || '—'}</span></div>
                <div class="info-row"><span class="info-label">Accent:</span><span class="info-value">${child.ego_accent_specific || child.ego_accent_categorized || '—'}</span></div>
                </div>
            `;
            panel.style.display = 'block';
            updateBottomDetailsLeft();
        }

        function updateBottomDetailsLeft() {
            const sidebar = document.getElementById('sidebar');
            const width = sidebar ? getComputedStyle(sidebar).width : '340px';
            document.documentElement.style.setProperty('--sidebar-width', width);
        }

        window.addEventListener('resize', updateBottomDetailsLeft);
  
        function showPanel(panel) {
            // Hide all panels first
            document.querySelectorAll('.info-panel').forEach(p => p.style.display = 'none');
            
            // Show selected panel
            panel.style.display = 'block';
            panel.style.left = '50px';
            panel.style.top = '100px';
        }
  
        function closePanel(panelId) {
            document.getElementById(panelId).style.display = 'none';
        }
  
  
  
        // Event handlers
        document.addEventListener('click', function(event) {
            // Close panels when clicking outside
            if (!event.target.closest('.info-panel') && 
                !event.target.closest('.floating-card') &&
                !event.target.closest('.fixed-details-panel') &&
                !event.target.closest('.resizable-details-panel') &&
                !event.target.closest('#bottomDetails') &&
                !event.target.closest('.context-box') && 
                !event.target.closest('.alter-node') &&
                !event.target.closest('.ego-node')) {
                // Close all panels
                document.querySelectorAll('.info-panel').forEach(panel => {
                    panel.style.display = 'none';
                });
                const udc = document.getElementById('unifiedDetailsCard');
                if (udc) udc.style.display = 'none';
                const fdp = document.getElementById('fixedDetailsPanel');
                if (fdp) fdp.style.display = 'none';
                const rdp = document.getElementById('resizableDetailsPanel');
                if (rdp) rdp.style.display = 'none';
                // keep bottomDetails open unless user clicks close
                
                // Clear selection
                clearSelection();
            }
        });

        // Bottom details controls: close, collapse/expand, resize by dragging top edge
        (function initBottomDetailsControls(){
            const panel = document.getElementById('bottomDetails');
            if (!panel) return;
            const closeBtn = document.getElementById('bottomDetailsCloseBtn');
            const header = document.getElementById('bottomDetailsHeader');
            let isResizing = false;
            let startY = 0;
            let startHeight = 0;

            function getCurrentHeight(){
                const h = getComputedStyle(panel).height;
                return parseInt(h, 10) || 120;
            }

            function setHeight(h){
                const minH = 80;
                const maxH = Math.round(window.innerHeight * 0.6);
                const clamped = Math.max(minH, Math.min(maxH, h));
                document.documentElement.style.setProperty('--bottom-details-height', clamped + 'px');
            }

            if (closeBtn) closeBtn.addEventListener('click', () => {
                panel.style.display = 'none';
            });

            // Make the entire header draggable for vertical resizing only
            if (header) {
                header.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    isResizing = true;
                    startY = e.clientY;
                    startHeight = getCurrentHeight();
                    document.body.style.cursor = 'ns-resize';
                });

                window.addEventListener('mousemove', (e) => {
                    if (!isResizing) return;
                    const delta = startY - e.clientY; // dragging up increases height
                    setHeight(startHeight + delta);
                });

                window.addEventListener('mouseup', () => {
                    if (!isResizing) return;
                    isResizing = false;
                    document.body.style.cursor = '';
                    localStorage.setItem('bottomDetailsHeight', String(getCurrentHeight()));
                });
            }

            // Restore persisted state
            const savedH = localStorage.getItem('bottomDetailsHeight');
            if (savedH) document.documentElement.style.setProperty('--bottom-details-height', savedH + 'px');
        })();
  
        // Keyboard event handlers
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                // Close modals and panels
                document.getElementById('sampleModal').style.display = 'none';
                document.getElementById('helpOverlay').style.display = 'none';
                
                if (state.ui.page === 'child') {
                    // Close all panels and clear selection in child dashboard
                    document.querySelectorAll('.info-panel').forEach(panel => {
                        panel.style.display = 'none';
                    });
                    const udc = document.getElementById('unifiedDetailsCard');
                    if (udc) udc.style.display = 'none';
                    const fdp = document.getElementById('fixedDetailsPanel');
                    if (fdp) fdp.style.display = 'none';
                    const bdp = document.getElementById('bottomDetails');
                    if (bdp) bdp.style.display = 'none';
                    clearSelection();
                }
            } else if (event.key === 'Enter') {
                // Handle Enter key for primary actions on each page
                if (state.ui.page === 'welcome') {
                    const processBtn = document.getElementById('processBtn');
                    if (processBtn && !processBtn.disabled) {
                        processData();
                    }
                } else if (state.ui.page === 'validate') {
                    const continueBtn = document.getElementById('continueBtn');
                    if (continueBtn && !continueBtn.disabled) {
                        goToMode();
                    }
                } else if (state.ui.page === 'mode') {
                    startChildExploration();
                } else if (state.ui.page === 'child' && (state.ui.selectedAlter || state.ui.selectedContext)) {
                    // Toggle right panel for accessibility in child dashboard
                    const alterSection = document.getElementById('alterDetailsSection');
                    if (alterSection.style.display === 'none' && state.ui.selectedAlter) {
                        showAlterInfoInSidebar(state.ui.selectedAlter);
                    } else {
                        alterSection.style.display = 'none';
                    }
                }
            }
        });
  
          function normalizeRace(rawRace) {
         if (!rawRace) return ['Unknown'];
         
         const raceMap = {
             'white': 'White',
             'black': 'Black',
             'african': 'Black',
             'african american': 'Black',
             'hisp': 'Hispanic/Latino',
             'latino': 'Hispanic/Latino',
             'latinx': 'Hispanic/Latino',
             'hispanic': 'Hispanic/Latino',
             'asian': 'Asian',
             'native': 'Native/Alaska',
             'alaska': 'Native/Alaska',
             'american indian': 'Native/Alaska',
             'middle east': 'MENA',
             'mena': 'MENA',
             'north africa': 'MENA',
             'mixed': 'Multiracial',
             'multi': 'Multiracial',
             'multiracial': 'Multiracial',
             'unknown': 'Unknown'
         };
         
         const normalized = rawRace.split(/[,;/|]+/)
             .map(race => race.trim().toLowerCase())
             .map(race => {
                 for (const [key, value] of Object.entries(raceMap)) {
                     if (race.includes(key)) return value;
                 }
                 return 'Other';
             })
             .filter((race, index, arr) => arr.indexOf(race) === index); // Remove duplicates
         
         // Return up to first 3 races for pie charts
         const result = normalized.slice(0, 3);
         return result.length > 0 ? result : ['Unknown'];
     }
  
    // Prefer node_relationship_intensity_z, fallback to node_closeness_intensity_z
    // Utility: shrink text to fit within a circle radius
    function fitTextToCircle(textNode, radius) {
        if (!textNode) return;
        const maxWidth = radius * 1.6;
        let size = parseFloat(textNode.style.fontSize || '13');
        const minSize = 8;
        while (size > minSize && textNode.getComputedTextLength() > maxWidth) {
            size -= 1;
            textNode.style.fontSize = size + 'px';
        }
        if (textNode.getComputedTextLength() > maxWidth) {
            let t = textNode.textContent;
            while (t.length > 1 && textNode.getComputedTextLength() > maxWidth) {
                t = t.slice(0, -1);
                textNode.textContent = t + '…';
            }
        }
    }
  
    function getClosenessIntensityZFromData(d) {
        const v = parseFloat(
            d?.node_relationship_intensity_z ?? d?.node_closeness_intensity_z ?? 0
        );
        return isNaN(v) ? 0 : v;
    }
  
    // Sidebar navigation function
    function showSidebarSection(sectionId, event) {
        // Hide all sections
        document.querySelectorAll('.sidebar-section').forEach(section => {
            section.style.display = 'none';
        });
        
        // Remove active class from all tabs
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.classList.remove('active');
        });
        
        // Show selected section
        const section = document.getElementById(sectionId);
        if (section) {
            section.style.display = 'block';
        }
        
        // Add active class to clicked tab if event is provided
        if (event && event.target) {
            event.target.classList.add('active');
        }
        
        // Update child info when switching to that tab
        if (sectionId === 'child-info') {
            updateSidebarChildInfo();
        }
        
        // Update network stats when switching to stats tab
        if (sectionId === 'network-stats') {
            updateNetworkStats();
        }
        
        // Handle explore whole data tab
        if (sectionId === 'explore-whole-data') {
            // Show exploration plots area
            const explorationPlotsArea = document.getElementById('explorationPlotsArea');
            if (explorationPlotsArea) {
                explorationPlotsArea.style.display = 'block';
            }
            
            // Hide network visualization
            const networkSvg = document.getElementById('networkSvg');
            if (networkSvg) {
                networkSvg.style.display = 'none';
            }
            
            // Hide legend
            const legend = document.getElementById('legend');
            if (legend) {
                legend.style.display = 'none';
            }
        } else {
            // Show network visualization for other tabs
            const explorationPlotsArea = document.getElementById('explorationPlotsArea');
            if (explorationPlotsArea) {
                explorationPlotsArea.style.display = 'none';
            }
            
            const networkSvg = document.getElementById('networkSvg');
            if (networkSvg) {
                networkSvg.style.display = 'block';
            }
            
            const legend = document.getElementById('legend');
            if (legend) {
                legend.style.display = 'block';
            }
        }
    }
  
  
  
  
  
    // Update child info in sidebar
    function updateSidebarChildInfo() {
        const container = document.getElementById('sidebarChildInfo');
        const childData = state.current.childData;
        
        if (!container) {
            console.log('sidebarChildInfo container not found, skipping update');
            return;
        }
        
        if (!childData) {
            container.innerHTML = '<div style="color: #6c757d; font-style: italic;">Select a child to view information</div>';
        } else {
            container.innerHTML = `
                <div class="info-row">
                    <span class="info-label">Name:</span>
                    <span class="info-value">${childData.child_name || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Age:</span>
                    <span class="info-value">${childData.age_in_months || 'N/A'} months</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Gender:</span>
                    <span class="info-value">${childData.child_gender || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Race:</span>
                    <span class="info-value">${childData.child_race || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Language:</span>
                    <span class="info-value">${childData.child_lang || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Birth Date:</span>
                    <span class="info-value">${childData.birthdate || 'N/A'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Network Size:</span>
                    <span class="info-value">${state.current.nodeData?.length || 0} alters</span>
                </div>
            `;
        }
          }
        
        // ===== ENHANCED EXPLORE WHOLE DATA FUNCTIONS =====
        
        function initializeWholeDataExploration() {
            console.log('Initializing whole data exploration');
            console.log('Current state:', state);
            
            // Normalize data before exploration
            if (state.data.nodeLevelLong || state.data.egoLevelNetworkSummary || state.data.activityLevelLong) {
                console.log('Normalizing data for whole data exploration...');
                normalizeExistingData();
            }
            
            // Populate variable dropdowns
            populateWholeDataDistributionVariables();
            populateWholeDataInteractionVariables();
            
            // Show welcome message initially
            document.getElementById('wholeDataPlotsArea').style.display = 'none';
            document.getElementById('wholeDataWelcome').style.display = 'block';
            
            // Check if data is available
            if (state.data.egoLevelNetworkSummary && state.data.nodeLevelLong && state.data.activityLevelLong) {
                console.log('All datasets are available');
                console.log('Ego level network summary data sample:', state.data.egoLevelNetworkSummary.slice(0, 2));
                console.log('Node level long data sample:', state.data.nodeLevelLong.slice(0, 2));
                console.log('Activity level long data sample:', state.data.activityLevelLong.slice(0, 2));
            } else {
                console.log('Some datasets are missing');
                console.log('Ego level network summary:', !!state.data.egoLevelNetworkSummary);
                console.log('Node level long:', !!state.data.nodeLevelLong);
                console.log('Activity level long:', !!state.data.activityLevelLong);
            }
        }
        
        function updateWholeDataExplorationView() {
            const mode = document.getElementById('wholeDataExplorationMode').value;
            const distributionControls = document.getElementById('wholeDataDistributionControls');
            const interactionControls = document.getElementById('wholeDataInteractionControls');
            const distributionPlot = document.getElementById('wholeDataDistributionPlot');
            const interactionPlot = document.getElementById('wholeDataInteractionPlot');
            const plotsArea = document.getElementById('wholeDataPlotsArea');
            const welcome = document.getElementById('wholeDataWelcome');
            
            // Show/hide controls based on mode
            if (mode === 'distribution') {
                distributionControls.style.display = 'block';
                interactionControls.style.display = 'none';
                distributionPlot.style.display = 'block';
                interactionPlot.style.display = 'none';
            } else {
                distributionControls.style.display = 'none';
                interactionControls.style.display = 'block';
                distributionPlot.style.display = 'none';
                interactionPlot.style.display = 'block';
            }
            
            // Show plots area and hide welcome
            plotsArea.style.display = 'block';
            welcome.style.display = 'none';
        }
        
        function updateWholeDataDistributionPlot() {
            const variable = document.getElementById('wholeDataDistributionVariable').value;
            if (!variable) return;
            
            console.log('Updating distribution plot for variable:', variable);
            
            // Get data for the selected variable
            const data = getWholeDataVariableData(variable);
            console.log('Data retrieved:', data);
            
            if (!data) {
                alert('No data available for this variable');
                return;
            }
            
            // Create the plot
            createWholeDataDistributionPlot(variable, data);
            
            // Update summary statistics
            updateWholeDataDistributionStats(variable, data);
        }
        
        function updateWholeDataInteractionPlot() {
            const xVar = document.getElementById('wholeDataXVariable').value;
            const yVar = document.getElementById('wholeDataYVariable').value;
            
            if (!xVar || !yVar) return;
            
            // Get data for both variables
            const xData = getWholeDataVariableData(xVar);
            const yData = getWholeDataVariableData(yVar);
            
            if (!xData || !yData) {
                alert('No data available for selected variables');
                return;
            }
            
            // Create the interaction plot
            createWholeDataInteractionPlot(xVar, yVar, xData, yData);
            
            // Update interaction statistics
            updateWholeDataInteractionStats(xVar, yVar, xData, yData);
        }
        
        function getWholeDataVariableData(variable) {
            console.log('Getting data for variable:', variable);
            console.log('State data available:', {
                egoLevelNetworkSummary: !!state.data.egoLevelNetworkSummary,
                nodeLevelLong: !!state.data.nodeLevelLong,
                activityLevelLong: !!state.data.activityLevelLong
            });
            
            // Check if data is available
            if (!state.data.egoLevelNetworkSummary || !state.data.nodeLevelLong || !state.data.activityLevelLong) {
                console.log('Missing required datasets - providing sample data for testing');
                
                // Provide sample data for testing when real data isn't available
                return getSampleDataForVariable(variable);
            }
            
            // Direct columns from ego_level_network_summary
            if (variable in state.data.egoLevelNetworkSummary[0]) {
                console.log('Found direct variable in ego_level_network_summary');
                let data = state.data.egoLevelNetworkSummary.map(row => row[variable]);
                
                // Special handling for language variables
                if (variable === 'child_lang') {
                    data = categorizeLanguageData(data);
                }
                
                console.log('Direct data:', data);
                return data;
            }
            
            // Derived metrics from node_level_long
            if (variable.startsWith('kin_') || 
                variable.startsWith('extended_') || variable.startsWith('caregiver_') ||
                variable.startsWith('live_at_home_') || variable.startsWith('pct_') ||
                variable.startsWith('avg_') || variable.startsWith('max_') || 
                variable.startsWith('min_') || variable.startsWith('exposure_') ||
                variable.startsWith('mode_of_contact_')) {
                console.log('Calculating derived metrics for:', variable);
                const data = calculateDerivedMetrics(variable);
                console.log('Derived data:', data);
                return data;
            }
            
            // Activity-based metrics
            if (variable.startsWith('activity_')) {
                console.log('Calculating activity metrics for:', variable);
                const data = calculateActivityMetrics(variable);
                console.log('Activity data:', data);
                return data;
            }
            
            console.log('Variable not found in any dataset - providing sample data');
            return getSampleDataForVariable(variable);
        }
        
        function getSampleDataForVariable(variable) {
            console.log('Providing sample data for:', variable);
            
            // Generate sample data for testing
            const sampleData = {
                'age_in_months': [23, 14, 25, 18, 22, 19, 21, 16, 24, 20],
                'child_gender': ['Female', 'Female', 'Male', 'Male', 'Female', 'Male', 'Female', 'Male', 'Female', 'Male'],
                'network_size': [14, 7, 12, 9, 15, 11, 13, 8, 16, 10],
                'network_density': [0.29, 0.29, 0.31, 0.28, 0.30, 0.32, 0.27, 0.33, 0.26, 0.34],
                
                'kin_size': [4, 2, 5, 3, 4, 2, 4, 3, 5, 2],
                'extended_family_presence': [1, 0, 1, 1, 0, 1, 1, 0, 1, 1],
                'caregiver_presence': [1, 1, 0, 1, 1, 0, 1, 1, 0, 1],
                'live_at_home_size': [3, 2, 4, 2, 3, 2, 3, 2, 4, 2],
                'avg_closeness_score': [0.5, 0.3, 0.7, 0.4, 0.6, 0.3, 0.5, 0.4, 0.6, 0.3],
                'activity_count': [2, 1, 3, 1, 2, 1, 2, 1, 3, 1],
                'activity_diversity': [2, 1, 3, 1, 2, 1, 2, 1, 3, 1],
                'child_lang': ['English Only', 'Bilingual', 'Multilingual', 'Exposure', 'English Only', 'Bilingual', 'Multilingual', 'Exposure', 'English Only', 'Bilingual'],
                'childcare_type': ['Day care center', 'Licensed family day care', 'Family child care', 'In-home care', 'Nanny']
            };
            
            return sampleData[variable] || [1, 2, 3, 4, 5]; // Default fallback
        }
        
        function categorizeLanguageData(languageData) {
            console.log('Categorizing language data:', languageData);
            
            return languageData.map(lang => {
                if (!lang || lang === '') return 'Unknown';
                
                // Convert to string and get first word
                const firstWord = String(lang).trim().split(/[,\s;]+/)[0].toLowerCase();
                
                console.log('Processing language:', lang, 'First word:', firstWord);
                
                // Categorize based on first word
                if (firstWord === 'english') {
                    return 'English Only';
                } else if (firstWord === 'multilingual') {
                    return 'Multilingual';
                } else if (firstWord === 'bilingual') {
                    return 'Bilingual';
                } else if (firstWord === 'exposure' || firstWord === 'limited' || firstWord === 'basic') {
                    return 'Exposure';
                } else {
                    // If it's not English, it's likely multilingual or bilingual
                    return 'Multilingual';
                }
            });
        }
        
        function calculateDerivedMetrics(variable) {
            const metrics = {};
            
            state.data.egoLevelNetworkSummary.forEach(child => {
                const childId = child.ChildID;
                const childLongData = state.data.nodeLevelLong.filter(row => row.ChildID === childId);
                
                switch (variable) {
                    
                    case 'kin_size':
                        const kinRelationships = ['Brother', 'Sister', 'Little brother', 'Older brother', 'Cousin', 'Aunt', 'Uncle', 'Grandma', 'Grandpa'];
                        metrics[childId] = childLongData.filter(row => kinRelationships.includes(row.node_relationship)).length;
                        break;
                    case 'extended_family_presence':
                        const extendedRelationships = ['Cousin', 'Aunt', 'Uncle', 'Grandma', 'Grandpa'];
                        metrics[childId] = childLongData.some(row => extendedRelationships.includes(row.node_relationship)) ? 1 : 0;
                        break;
                    case 'caregiver_presence':
                        metrics[childId] = childLongData.some(row => row.node_relationship === 'Nanny' || row.node_relationship === 'Caregiver') ? 1 : 0;
                        break;
                    case 'live_at_home_size':
                        metrics[childId] = childLongData.filter(row => row.node_liveathome_or_not === 'yes').length;
                        break;
                    case 'avg_closeness_score':
                        const closenessScores = childLongData.map(row => row.node_closeness_score).filter(score => !isNaN(score));
                        metrics[childId] = closenessScores.length > 0 ? d3.mean(closenessScores) : 0;
                        break;
                    case 'max_closeness_score':
                        const maxScores = childLongData.map(row => row.node_closeness_score).filter(score => !isNaN(score));
                        metrics[childId] = maxScores.length > 0 ? d3.max(maxScores) : 0;
                        break;
                    case 'min_closeness_score':
                        const minScores = childLongData.map(row => row.node_closeness_score).filter(score => !isNaN(score));
                        metrics[childId] = minScores.length > 0 ? d3.min(minScores) : 0;
                        break;
                    case 'avg_weekly_exposure':
                        const exposures = childLongData.map(row => row.node_weekly_hour_percent).filter(exposure => !isNaN(exposure));
                        metrics[childId] = exposures.length > 0 ? d3.mean(exposures) : 0;
                        break;
                    case 'pct_male_alters':
                        const maleAlters = childLongData.filter(row => row.node_gender === 'Male').length;
                        const totalAlters = childLongData.length;
                        metrics[childId] = totalAlters > 0 ? (maleAlters / totalAlters) * 100 : 0;
                        break;
                    case 'pct_female_alters':
                        const femaleAlters = childLongData.filter(row => row.node_gender === 'Female').length;
                        const totalAlters2 = childLongData.length;
                        metrics[childId] = totalAlters2 > 0 ? (femaleAlters / totalAlters2) * 100 : 0;
                        break;
                }
            });
            
            return Object.values(metrics);
        }
        
        function calculateActivityMetrics(variable) {
            const metrics = {};
            
            state.data.egoLevelNetworkSummary.forEach(child => {
                const childId = child.ChildID;
                // Handle ChildID variations when filtering activity data
                const childActivityData = state.data.activityLevelLong.filter(row => {
                    const childIdVariants = ['ChildID', 'childID', 'child_id', 'Child_Id', 'child_Id', 'CHILDID', 'SubjectID', 'subjectID', 'subject_id', 'Subject_Id', 'subject_Id', 'SUBJECTID'];
                    for (const variant of childIdVariants) {
                        if (row[variant] && row[variant].toString().trim() === childId) {
                            return true;
                        }
                    }
                    return false;
                });
                
                switch (variable) {
                    case 'activity_count':
                        metrics[childId] = childActivityData.length;
                        break;
                    case 'activity_diversity':
                        const uniqueActivities = new Set(childActivityData.map(row => row.activity_name));
                        metrics[childId] = uniqueActivities.size;
                        break;
                    case 'pct_activities_with_peers':
                        const withPeers = childActivityData.filter(row => row.activity_otherkids_yn === 'yes').length;
                        metrics[childId] = childActivityData.length > 0 ? (withPeers / childActivityData.length) * 100 : 0;
                        break;
                }
            });
            
            return Object.values(metrics);
        }
        
        function createWholeDataDistributionPlot(variable, data) {
            const chartDiv = document.getElementById('wholeDataDistributionChart');
            
            // Clear previous content
            chartDiv.innerHTML = '';
            
            console.log('Creating distribution plot for:', variable, 'with data:', data);
            
            // Check if data is continuous or categorical
            const isContinuous = typeof data[0] === 'number' && !isNaN(data[0]);
            console.log('Data type detection - isContinuous:', isContinuous, 'first value:', data[0], 'type:', typeof data[0]);
            
            if (isContinuous) {
                console.log('Creating histogram for continuous data');
                createWholeDataHistogram(chartDiv, variable, data);
            } else {
                console.log('Creating bar chart for categorical data');
                createWholeDataBarChart(chartDiv, variable, data);
            }
        }
        
        function createWholeDataHistogram(container, variable, data) {
            console.log('Creating histogram for:', variable, 'with data:', data);
            
            // Validate data
            if (!data || !Array.isArray(data) || data.length === 0) {
                console.error('Invalid data for histogram:', data);
                container.innerHTML = '<p style="color: red; text-align: center; padding: 20px;">No data available for this variable</p>';
                return;
            }
            
            // Filter out undefined, null, or NaN values for numeric data
            const validData = data.filter(d => d !== undefined && d !== null && !isNaN(d));
            console.log('Valid numeric data after filtering:', validData);
            
            if (validData.length === 0) {
                container.innerHTML = '<p style="color: red; text-align: center; padding: 20px;">No valid numeric data available for this variable</p>';
                return;
            }
            
            // Create histogram using D3.js with ggplot-like styling
            const margin = {top: 30, right: 30, bottom: 50, left: 70};
            const width = container.offsetWidth - margin.left - margin.right;
            const height = 350 - margin.top - margin.bottom;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Create scales
            const x = d3.scaleLinear()
                .domain([d3.min(validData), d3.max(validData)])
                .range([0, width]);
            
            const y = d3.scaleLinear()
                .domain([0, d3.max(d3.histogram().domain(x.domain()).thresholds(x.ticks(20))(validData))])
                .range([height, 0]);
            
            // Create histogram
            const histogram = d3.histogram()
                .domain(x.domain())
                .thresholds(x.ticks(20));
            
            const bins = histogram(validData);
            
            // Add grid lines
            svg.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).tickSize(-height).tickFormat(''));
            
            svg.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(y).tickSize(-width).tickFormat(''));
            
            // Add bars with ggplot-like styling
            svg.selectAll('rect')
                .data(bins)
                .enter().append('rect')
                .attr('x', d => x(d.x0))
                .attr('width', d => Math.max(0, x(d.x1) - x(d.x0) - 1))
                .attr('y', d => y(d.length))
                .attr('height', d => height - y(d.length))
                .style('fill', '#3b82f6')
                .style('stroke', '#1e40af')
                .style('stroke-width', '1px')
                .style('opacity', 0.8);
            
            // Add axes with clean styling
            const xAxis = d3.axisBottom(x);
            const yAxis = d3.axisLeft(y);
            
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(xAxis)
                .style('font-size', '12px');
            
            svg.append('g')
                .call(yAxis)
                .style('font-size', '12px');
            
            // Add labels
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height + margin.bottom - 10)
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', '600')
                .style('fill', '#374151')
                .text(variable.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));
            
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left + 20)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', '600')
                .style('fill', '#374151')
                .text('Frequency');
            
            // Style grid lines
            svg.selectAll('.grid line')
                .style('stroke', '#e5e7eb')
                .style('stroke-width', '1px')
                .style('opacity', 0.5);
        }
        
        function createWholeDataBarChart(container, variable, data) {
            console.log('Creating bar chart for:', variable, 'with data:', data);
            
            // Validate data
            if (!data || !Array.isArray(data) || data.length === 0) {
                console.error('Invalid data for bar chart:', data);
                container.innerHTML = '<p style="color: red; text-align: center; padding: 20px;">No data available for this variable</p>';
                return;
            }
            
            // Filter out undefined, null, or empty values
            const validData = data.filter(d => d !== undefined && d !== null && d !== '');
            console.log('Valid data after filtering:', validData);
            
            if (validData.length === 0) {
                container.innerHTML = '<p style="color: red; text-align: center; padding: 20px;">No valid data available for this variable</p>';
                return;
            }
            
            // Create bar chart using D3.js with ggplot-like styling
            const margin = {top: 30, right: 30, bottom: 50, left: 70};
            const width = container.offsetWidth - margin.left - margin.right;
            const height = 350 - margin.top - margin.bottom;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Count frequencies
            const counts = {};
            validData.forEach(d => {
                const key = String(d); // Convert to string to handle any data type
                counts[key] = (counts[key] || 0) + 1;
            });
            
            console.log('Counts object:', counts);
            
            const categories = Object.keys(counts);
            const frequencies = Object.values(counts);
            
            console.log('Categories:', categories);
            console.log('Frequencies:', frequencies);
            
            // Create scales
            const x = d3.scaleBand()
                .domain(categories)
                .range([0, width])
                .padding(0.1);
            
            const y = d3.scaleLinear()
                .domain([0, d3.max(frequencies)])
                .range([height, 0]);
            
            // Handle long category labels by truncating them
            const truncatedCategories = categories.map(cat => {
                if (cat.length > 20) {
                    return cat.substring(0, 17) + '...';
                }
                return cat;
            });
            
            // Add grid lines
            svg.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(y).tickSize(-width).tickFormat(''));
            
            // Add bars with ggplot-like styling
            svg.selectAll('rect')
                .data(categories)
                .enter().append('rect')
                .attr('x', d => x(d))
                .attr('width', x.bandwidth())
                .attr('y', d => y(counts[d]))
                .attr('height', d => height - y(counts[d]))
                .style('fill', '#3b82f6')
                .style('stroke', '#1e40af')
                .style('stroke-width', '1px')
                .style('opacity', 0.8);
            
            // Add value labels on bars
            svg.selectAll('text')
                .data(categories)
                .enter().append('text')
                .attr('x', d => x(d) + x.bandwidth() / 2)
                .attr('y', d => y(counts[d]) - 5)
                .attr('text-anchor', 'middle')
                .style('font-size', '12px')
                .style('font-weight', '600')
                .style('fill', '#374151')
                .text(d => counts[d]);
            
            // Add axes with clean styling
            const xAxis = d3.axisBottom(x);
            const yAxis = d3.axisLeft(y);
            
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(xAxis)
                .style('font-size', '12px');
            
            svg.append('g')
                .call(yAxis)
                .style('font-size', '12px');
            
            // Add labels
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height + margin.bottom - 10)
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', '600')
                .style('fill', '#374151')
                .text(variable.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));
            
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left + 20)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', '600')
                .style('fill', '#374151')
                .text('Count');
            
            // Style grid lines
            svg.selectAll('.grid line')
                .style('stroke', '#e5e7eb')
                .style('stroke-width', '1px')
                .style('opacity', 0.5);
        }
        
        function createWholeDataInteractionPlot(xVar, yVar, xData, yData) {
            const chartDiv = document.getElementById('wholeDataInteractionChart');
            
            // Clear previous content
            chartDiv.innerHTML = '';
            
            // Check if both variables are continuous
            const xContinuous = typeof xData[0] === 'number';
            const yContinuous = typeof yData[0] === 'number';
            
            if (xContinuous && yContinuous) {
                createWholeDataScatterPlot(chartDiv, xVar, yVar, xData, yData);
            } else if (xContinuous || yContinuous) {
                // Use scatter plot for all continuous variables instead of box plots
                createWholeDataScatterPlot(chartDiv, xVar, yVar, xData, yData);
            } else {
                createWholeDataHeatmap(chartDiv, xVar, yVar, xData, yData);
            }
        }
        
        function createWholeDataScatterPlot(container, xVar, yVar, xData, yData) {
            // Create scatter plot using D3.js with ggplot-like styling and regression line
            const margin = {top: 30, right: 30, bottom: 50, left: 70};
            const width = container.offsetWidth - margin.left - margin.right;
            const height = 350 - margin.top - margin.bottom;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Check if variables are continuous or categorical
            const xContinuous = typeof xData[0] === 'number' && !isNaN(xData[0]);
            const yContinuous = typeof yData[0] === 'number' && !isNaN(yData[0]);
            
            // Create scales based on data type
            let x, y;
            
            if (xContinuous) {
                x = d3.scaleLinear()
                    .domain([d3.min(xData), d3.max(xData)])
                    .range([0, width]);
            } else {
                // Categorical x-axis
                const categories = [...new Set(xData)].sort();
                x = d3.scaleBand()
                    .domain(categories)
                    .range([0, width])
                    .padding(0.1);
            }
            
            if (yContinuous) {
                y = d3.scaleLinear()
                    .domain([d3.min(yData), d3.max(yData)])
                    .range([height, 0]);
            } else {
                // Categorical y-axis
                const categories = [...new Set(yData)].sort();
                y = d3.scaleBand()
                    .domain(categories)
                    .range([height, 0])
                    .padding(0.1);
            }
            
            // Add grid lines (only for continuous axes)
            if (xContinuous) {
                svg.append('g')
                    .attr('class', 'grid')
                    .attr('transform', `translate(0,${height})`)
                    .call(d3.axisBottom(x).tickSize(-height).tickFormat(''));
            }
            
            if (yContinuous) {
                svg.append('g')
                    .attr('class', 'grid')
                    .call(d3.axisLeft(y).tickSize(-width).tickFormat(''));
            }
            
            // Calculate regression line (only for continuous-continuous relationships)
            let regression = null;
            if (xContinuous && yContinuous) {
                regression = calculateRegression(xData, yData);
                
                // Add regression line
                if (regression) {
                    const line = d3.line()
                        .x(d => x(d.x))
                        .y(d => y(d.y));
                    
                    const lineData = [
                        {x: d3.min(xData), y: regression.slope * d3.min(xData) + regression.intercept},
                        {x: d3.max(xData), y: regression.slope * d3.max(xData) + regression.intercept}
                    ];
                    
                    svg.append('path')
                        .datum(lineData)
                        .attr('fill', 'none')
                        .attr('stroke', '#ef4444')
                        .attr('stroke-width', '2px')
                        .attr('stroke-dasharray', '5,5')
                        .attr('d', line);
                }
            }
            
            // Add dots with ggplot-like styling
            const dataPoints = xData.map((d, i) => ({x: d, y: yData[i]}));
            
            svg.selectAll('circle')
                .data(dataPoints)
                .enter().append('circle')
                .attr('cx', d => {
                    if (xContinuous) {
                        return x(d.x);
                    } else {
                        // For categorical x, add some jitter
                        const baseX = x(d.x);
                        const jitter = (Math.random() - 0.5) * (x.bandwidth ? x.bandwidth() * 0.8 : 10);
                        return baseX + jitter;
                    }
                })
                .attr('cy', d => {
                    if (yContinuous) {
                        return y(d.y);
                    } else {
                        // For categorical y, add some jitter
                        const baseY = y(d.y);
                        const jitter = (Math.random() - 0.5) * (y.bandwidth ? y.bandwidth() * 0.8 : 10);
                        return baseY + jitter;
                    }
                })
                .attr('r', 4)
                .style('fill', '#3b82f6')
                .style('stroke', '#1e40af')
                .style('stroke-width', '1px')
                .style('opacity', 0.7);
            
            // Add axes with clean styling
            const xAxis = d3.axisBottom(x);
            const yAxis = d3.axisLeft(y);
            
            // Format axis ticks for categorical variables
            if (!xContinuous) {
                xAxis.tickFormat(d => {
                    // Truncate long category names
                    return d.length > 10 ? d.substring(0, 10) + '...' : d;
                });
            }
            
            if (!yContinuous) {
                yAxis.tickFormat(d => {
                    // Truncate long category names
                    return d.length > 10 ? d.substring(0, 10) + '...' : d;
                });
            }
            
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(xAxis)
                .style('font-size', '12px')
                .selectAll('text')
                .style('text-anchor', 'end')
                .attr('dx', '-.8em')
                .attr('dy', '.15em')
                .attr('transform', 'rotate(-45)');
            
            svg.append('g')
                .call(yAxis)
                .style('font-size', '12px');
            
            // Add labels
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height + margin.bottom - 10)
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', '600')
                .style('fill', '#374151')
                .text(xVar.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));
            
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left + 20)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', '600')
                .style('fill', '#374151')
                .text(yVar.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));
            
            // Style grid lines
            svg.selectAll('.grid line')
                .style('stroke', '#e5e7eb')
                .style('stroke-width', '1px')
                .style('opacity', 0.5);
        }
        
        function updateWholeDataDistributionStats(variable, data) {
            const statsDiv = document.getElementById('wholeDataDistributionStats');
            
            if (typeof data[0] === 'number') {
                // Continuous variable
                const n = data.length;
                const mean = d3.mean(data);
                const median = d3.median(data);
                const std = d3.deviation(data);
                const q1 = d3.quantile(data, 0.25);
                const q3 = d3.quantile(data, 0.75);
                
                statsDiv.innerHTML = `
                    <div><strong>N:</strong> ${n}</div>
                    <div><strong>Mean:</strong> ${mean.toFixed(2)}</div>
                    <div><strong>SD:</strong> ${std.toFixed(2)}</div>
                    <div><strong>Median:</strong> ${median.toFixed(2)}</div>
                    <div><strong>Q1:</strong> ${q1.toFixed(2)}</div>
                    <div><strong>Q3:</strong> ${q3.toFixed(2)}</div>
                `;
            } else {
                // Categorical variable
                const counts = {};
                data.forEach(d => {
                    counts[d] = (counts[d] || 0) + 1;
                });
                
                const total = data.length;
                let statsHTML = `<div><strong>Total:</strong> ${total}</div>`;
                
                Object.entries(counts).forEach(([category, count]) => {
                    const proportion = (count / total * 100).toFixed(1);
                    statsHTML += `<div><strong>${category}:</strong> ${count} (${proportion}%)</div>`;
                });
                
                statsDiv.innerHTML = statsHTML;
            }
        }
        
        function updateWholeDataInteractionStats(xVar, yVar, xData, yData) {
            const statsDiv = document.getElementById('wholeDataInteractionStats');
            
            if (typeof xData[0] === 'number' && typeof yData[0] === 'number') {
                // Both continuous - calculate correlation and regression
                const correlation = calculateCorrelation(xData, yData);
                const regression = calculateRegression(xData, yData);
                const rSquared = correlation * correlation;
                
                statsDiv.innerHTML = `
                    <div><strong>Correlation (r):</strong> ${correlation.toFixed(3)}</div>
                    <div><strong>R²:</strong> ${rSquared.toFixed(3)}</div>
                    <div><strong>Slope:</strong> ${regression ? regression.slope.toFixed(3) : 'N/A'}</div>
                    <div><strong>Intercept:</strong> ${regression ? regression.intercept.toFixed(3) : 'N/A'}</div>
                    <div><strong>N:</strong> ${xData.length}</div>
                `;
            } else {
                statsDiv.innerHTML = `<div>Select variables to view relationship statistics</div>`;
            }
        }
        
        function calculateRegression(x, y) {
            const n = x.length;
            if (n < 2) return null;
            
            const sumX = d3.sum(x);
            const sumY = d3.sum(y);
            const sumXY = d3.sum(x.map((d, i) => d * y[i]));
            const sumX2 = d3.sum(x.map(d => d * d));
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            return { slope, intercept };
        }
        
        function calculateCorrelation(x, y) {
            const n = x.length;
            const sumX = d3.sum(x);
            const sumY = d3.sum(y);
            const sumXY = d3.sum(x.map((d, i) => d * y[i]));
            const sumX2 = d3.sum(x.map(d => d * d));
            const sumY2 = d3.sum(y.map(d => d * d));
            
            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
            
            return denominator === 0 ? 0 : numerator / denominator;
        }
        
        // Add missing D3.js functions if they don't exist
        if (typeof d3.quantile === 'undefined') {
            d3.quantile = function(array, p) {
                if (!array || array.length === 0) return undefined;
                const sorted = array.slice().sort((a, b) => a - b);
                const index = (sorted.length - 1) * p;
                const lower = Math.floor(index);
                const upper = Math.ceil(index);
                const weight = index - lower;
                if (upper === lower) return sorted[lower];
                return sorted[lower] * (1 - weight) + sorted[upper] * weight;
            };
        }
        
        if (typeof d3.deviation === 'undefined') {
            d3.deviation = function(array) {
                const mean = d3.mean(array);
                const squareDiffs = array.map(value => Math.pow(value - mean, 2));
                const avgSquareDiff = d3.mean(squareDiffs);
                return Math.sqrt(avgSquareDiff);
            };
        }
        
        function exportNetwork() {
            const format = document.getElementById('exportFormat').value;
            
            if (format === 'csv') {
                // Export network data as CSV
                const nodes = state.current.nodeData || [];
                const edges = state.current.nodeEdges || [];
                
                // Create nodes CSV
                const nodesCSV = 'NodeID,NodeName,NodeType,Relationship,Context,Language,Race,ClosenessScore,WeeklyHours\n' +
                    nodes.map(node => [
                        node.node_mapping_code || '',
                        node.node_name || '',
                        node.node_type || '',
                        node.node_relationship || '',
                        getNodeContext(node.node_type) || '',
                        node.node_language || '',
                        node.node_race || '',
                        node.node_closeness_score || '',
                        node.node_weekly_hour || ''
                    ].join(',')).join('\n');
                
                const blob = new Blob([nodesCSV], {type: 'text/csv'});
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `network_${state.current.child}_nodes.csv`;
                a.click();
                window.URL.revokeObjectURL(url);
                
                // Create edges CSV
                const edgesCSV = 'Source,Target,Weight,Type\n' +
                    edges.map(edge => [
                        edge.source,
                        edge.target,
                        edge.weight || 1,
                        edge.type || 'undirected'
                    ].join(',')).join('\n');
                
                const edgesBlob = new Blob([edgesCSV], {type: 'text/csv'});
                const edgesUrl = window.URL.createObjectURL(edgesBlob);
                const edgesA = document.createElement('a');
                edgesA.href = edgesUrl;
                edgesA.download = `network_${state.current.child}_edges.csv`;
                edgesA.click();
                window.URL.revokeObjectURL(edgesUrl);
                
            } else if (format === 'png') {
                // Show preview for PNG export
                showExportPreview();
            }
        }


        // ===== EXPORT PREVIEW FUNCTIONS =====
        
        let previewImageData = null;
        
        function showExportPreview() {
            // Check if there's a visualization to capture
            if (!state.current.child || !state.current.nodeData) {
                alert('Please select a child and visualize the network first.');
                return;
            }
            
            // Show loading in modal
            const modal = document.getElementById('exportPreviewModal');
            const previewImage = document.getElementById('previewImage');
            previewImage.src = '';
            previewImage.alt = 'Generating preview...';
            modal.style.display = 'flex';
            
            // Generate the preview image
            generatePreviewImage().then(imageDataUrl => {
                previewImageData = imageDataUrl;
                previewImage.src = imageDataUrl;
                previewImage.alt = 'Export Preview';
            }).catch(error => {
                console.error('Preview generation error:', error);
                alert('Error generating preview. Please try again.');
                closeExportPreview();
            });
        }
        
        function closeExportPreview() {
            const modal = document.getElementById('exportPreviewModal');
            modal.style.display = 'none';
            previewImageData = null;
        }

        // Show scatter of all children's network sizes (x=network size, y=count)
        function showAllChildrenNetworkSize() {
            if (!state.data || !state.data.egoLevelNetworkSummary || state.data.egoLevelNetworkSummary.length === 0) {
                alert('Please upload ego_level_network_summary.csv first.');
                return;
            }

            const rows = state.data.egoLevelNetworkSummary;
            const sizes = rows.map((row) => parseFloat(row.network_size || row.Network_Size || row.networkSize))
                .filter(v => isFinite(v));

            const modal = document.getElementById('allChildrenScatterModal');
            const container = document.getElementById('allChildrenScatterContainer');
            container.innerHTML = '';
            const titleEl = document.getElementById('allChildrenScatterTitle');
            if (titleEl) titleEl.textContent = 'Distribution of Network Size';
            modal.style.display = 'flex';

            drawOverviewScatter('#allChildrenScatterContainer', sizes, 'Network Size', { startXAtZero: true, integerX: true });
        }

        // Overview: render scatter for selected metric across all children (value vs count)
        function showAllChildrenOverview() {
            const metric = (document.getElementById('overviewMetric') || {}).value || 'network_size';
            const rows = (state.data && state.data.egoLevelNetworkSummary) ? state.data.egoLevelNetworkSummary : [];
            if (!rows.length) {
                alert('Please upload ego_level_network_summary.csv first.');
                return;
            }

            const metricValues = getOverviewMetricValues(rows, metric);
            if (!metricValues.length) {
                alert('Selected metric has no valid values.');
                return;
            }

            const modal = document.getElementById('allChildrenScatterModal');
            const container = document.getElementById('allChildrenScatterContainer');
            container.innerHTML = '';

            const labels = {
                'network_size': 'Network Size',
                'network_density': 'Network Density',
                'network_component_count': 'Component Count',
                'network_component_ratio': 'Component Ratio',
                'network_prop_adult_relationship': '% Adult Nodes',
                'network_prop_kin_relationship': '% Kin Nodes',
                'network_edges_number': 'Edges',
                'network_racial_entropy': 'Race Entropy',
                'network_racial_ei_index': 'Racial EI',
                'network_language_entropy': 'Language Entropy',
                'network_linguistic_ei_index': 'Linguistic EI'
            };

            const titleEl = document.getElementById('allChildrenScatterTitle');
            if (titleEl) titleEl.textContent = `Distribution of ${labels[metric] || 'Value'}`;
            modal.style.display = 'flex';

            const percentMetrics = new Set(['network_prop_adult_relationship', 'network_prop_kin_relationship']);
            let values = metricValues.slice();
            if (percentMetrics.has(metric)) {
                // Convert to 0-100 if values appear 0-1
                const maxVal = d3.max(values);
                if (maxVal <= 1.01) values = values.map(v => v * 100);
            }
            const startXAtZero = new Set(['network_size', 'network_component_count', 'network_edges_number']).has(metric) || percentMetrics.has(metric);
            const integerX = new Set(['network_size', 'network_component_count', 'network_edges_number']).has(metric);
            drawOverviewScatter('#allChildrenScatterContainer', values, labels[metric] || 'Value', { startXAtZero, integerX });
        }

        // Helper: draw scatter where X=value, Y=count (binned for continuous values)
        function drawOverviewScatter(containerSelector, values, xLabel, options = {}) {
            const container = document.querySelector(containerSelector);
            const margin = { top: 30, right: 20, bottom: 60, left: 90 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = container.clientHeight - margin.top - margin.bottom;

            const svg = d3.select(containerSelector)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const minVal = d3.min(values);
            const maxVal = d3.max(values);

            // Determine if integer data (all close to integers)
            const isIntegerish = options.integerX || values.every(v => Math.abs(v - Math.round(v)) < 1e-6);
            let points;
            if (isIntegerish) {
                const counts = d3.rollup(values, v => v.length, v => Math.round(v));
                points = Array.from(counts, ([x, y]) => ({ x: +x, y }));
            } else {
                // Bin continuous values; use 30 bins
                const binCount = 30;
                const thresholds = d3.range(0, binCount + 1).map(i => minVal + (i * (maxVal - minVal)) / binCount);
                const histogram = d3.histogram().domain([minVal, maxVal]).thresholds(thresholds);
                const bins = histogram(values);
                points = bins.filter(b => b.length > 0).map(b => ({ x: (b.x0 + b.x1) / 2, y: b.length }));
            }

            let xDomainMin = d3.min(points, d => d.x);
            if (options.startXAtZero) xDomainMin = 0;
            const x = d3.scaleLinear().domain([xDomainMin, d3.max(points, d => d.x)]).range([0, width]);
            const yMax = d3.max(points, d => d.y) || 1;
            const y = d3.scaleLinear().domain([0, yMax]).nice().range([height, 0]);

            const xAxis = d3.axisBottom(x).ticks(10);
            const yAxis = d3.axisLeft(y).ticks(Math.min(10, yMax)).tickFormat(d3.format('d'));
            svg.append('g').attr('transform', `translate(0,${height})`).call(xAxis);
            svg.append('g').call(yAxis);

            svg.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(y).tickSize(-width).tickFormat(''))
                .selectAll('line')
                .attr('stroke', '#e5e7eb');

            svg.selectAll('circle')
                .data(points)
                .enter()
                .append('circle')
                .attr('cx', d => x(d.x))
                .attr('cy', d => y(d.y))
                .attr('r', 4)
                .attr('fill', '#800000')
                .attr('opacity', 0.85);

            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height + 45)
                .attr('text-anchor', 'middle')
                .style('fill', '#374151')
                .text(xLabel);

            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', -60)
                .attr('text-anchor', 'middle')
                .style('fill', '#374151')
                .text('Count');
        }

        function getOverviewMetricValues(rows, metric) {
            const candidates = {
                'network_size': ['network_size', 'Network_Size', 'networkSize'],
                'network_density': ['network_density', 'Network_Density', 'density'],
                'network_component_count': ['network_component_count', 'component_count', 'Component_Count'],
                'network_component_ratio': ['network_component_ratio', 'component_ratio', 'Component_Ratio'],
                'network_prop_adult_relationship': ['network_prop_adult_relationship', 'prop_adult_relationship'],
                'network_prop_kin_relationship': ['network_prop_kin_relationship', 'prop_kin_relationship'],
                'network_edges_number': ['network_edges_number', 'edges_number', 'Edges'],
                'network_racial_entropy': ['network_racial_entropy', 'race_entropy'],
                'network_racial_ei_index': ['network_racial_ei_index', 'racial_ei_index'],
                'network_language_entropy': ['network_language_entropy', 'language_entropy'],
                'network_linguistic_ei_index': ['network_linguistic_ei_index', 'linguistic_ei_index']
            }[metric] || [metric];

            return rows.map(row => {
                for (const key of candidates) {
                    const v = row[key];
                    if (v !== undefined && v !== null && v !== '') {
                        const num = parseFloat(v);
                        if (isFinite(num)) return num;
                    }
                }
                return undefined;
            }).filter(v => v !== undefined);
        }
        function closeAllChildrenScatter() {
            const modal = document.getElementById('allChildrenScatterModal');
            modal.style.display = 'none';
            const container = document.getElementById('allChildrenScatterContainer');
            if (container) container.innerHTML = '';
            const tt = document.getElementById('allChildrenScatterTooltip');
            if (tt) tt.remove();
        }
        
        function downloadPreview() {
            if (!previewImageData) {
                alert('No preview available to download.');
                return;
            }
            
            // Create download link
            const link = document.createElement('a');
            link.href = previewImageData;
            
            // Set filename
            const childName = state.current.childData?.child_name || 'Unknown';
            const layoutStyle = state.ui.layoutStyle || 'grouped';
            const colorBy = state.ui.colorBy || 'default';
            const timestamp = new Date().toISOString().slice(0, 10);
            
            link.download = `network_${childName}_${layoutStyle}_${colorBy}_${timestamp}.png`;
            link.click();
            
            // Close modal
            closeExportPreview();
        }
        
        function generatePreviewImage() {
            return new Promise((resolve, reject) => {
                try {
                    // Hide the sidebar temporarily
                    const sidebar = document.querySelector('.sidebar');
                    const originalSidebarDisplay = sidebar ? sidebar.style.display : 'none';
                    if (sidebar) {
                        sidebar.style.display = 'none';
                    }
                    
                    // Hide the bottom details panel temporarily
                    const bottomDetails = document.getElementById('bottomDetails');
                    const originalBottomDetailsDisplay = bottomDetails ? bottomDetails.style.display : 'none';
                    if (bottomDetails) {
                        bottomDetails.style.display = 'none';
                    }
                    
                    // Wait a moment for the layout to adjust
                    setTimeout(() => {
                        // Create a container that includes both the network and legend
                        const networkContainer = document.createElement('div');
                        networkContainer.style.position = 'relative';
                        networkContainer.style.width = '100%';
                        networkContainer.style.minHeight = '100vh';
                        networkContainer.style.backgroundColor = 'white';
                        networkContainer.style.overflow = 'visible';
                        
                        // Get the network SVG
                        const svg = document.getElementById('networkSvg');
                        const legend = document.getElementById('legend');
                        
                        if (!svg) {
                            reject(new Error('No network visualization found. Please visualize a network first.'));
                            restoreElements();
                            return;
                        }
                        
                        // Clone the SVG and legend
                        const svgClone = svg.cloneNode(true);
                        const legendClone = legend ? legend.cloneNode(true) : null;
                        
                        // Position the legend on the cloned SVG
                        if (legendClone) {
                            legendClone.style.position = 'absolute';
                            legendClone.style.top = '20px';
                            legendClone.style.right = '20px';
                            legendClone.style.zIndex = '1000';
                            legendClone.style.backgroundColor = 'white';
                            legendClone.style.padding = '10px';
                            legendClone.style.borderRadius = '8px';
                            legendClone.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
                            legendClone.style.display = 'block';
                        }
                        
                        // Add clones to container
                        networkContainer.appendChild(svgClone);
                        if (legendClone) {
                            networkContainer.appendChild(legendClone);
                        }
                        
                        // Temporarily add to body for capture
                        document.body.appendChild(networkContainer);
                        
                        // Use html2canvas to capture the container
                        html2canvas(networkContainer, {
                            backgroundColor: 'white',
                            scale: 2,
                            useCORS: true,
                            allowTaint: true,
                            logging: false,
                            width: networkContainer.scrollWidth,
                            height: networkContainer.scrollHeight,
                            scrollX: 0,
                            scrollY: 0,
                            windowWidth: networkContainer.scrollWidth,
                            windowHeight: networkContainer.scrollHeight
                        }).then(canvas => {
                            // Get the image data URL
                            const dataURL = canvas.toDataURL('image/png', 1.0);
                            
                            // Clean up
                            document.body.removeChild(networkContainer);
                            restoreElements();
                            
                            resolve(dataURL);
                        }).catch(error => {
                            console.error('Canvas error:', error);
                            if (document.body.contains(networkContainer)) {
                                document.body.removeChild(networkContainer);
                            }
                            restoreElements();
                            reject(error);
                        });
                        
                        function restoreElements() {
                            // Restore sidebar
                            if (sidebar) {
                                sidebar.style.display = originalSidebarDisplay;
                            }
                            // Restore bottom details
                            if (bottomDetails) {
                                bottomDetails.style.display = originalBottomDetailsDisplay;
                            }
                        }
                    }, 100);
                } catch (error) {
                    console.error('Preview generation error:', error);
                    reject(error);
                }
            });
        }

        // ===== BATCH EXPORT FUNCTIONS =====
        
        // Export all children with current settings
        function exportAllChildren() {
            if (!state.data.egoLevelNetworkSummary || state.data.egoLevelNetworkSummary.length === 0) {
                alert('No children data available for export');
                return;
            }
            
            const format = document.getElementById('exportFormat').value;
            const children = state.data.egoLevelNetworkSummary.map(row => row.ChildID).filter(id => id);
            
            if (children.length === 0) {
                alert('No valid children found for export');
                return;
            }
            
            // Show progress modal
            showExportProgressModal(children.length, format, children);
        }

        // Show export progress modal
        function showExportProgressModal(totalChildren, format, children) {
            const modal = document.createElement('div');
            modal.id = 'exportProgressModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                padding: 2rem;
                border-radius: 8px;
                max-width: 400px;
                width: 90%;
                text-align: center;
            `;
            
            content.innerHTML = `
                <h3 style="margin: 0 0 1rem 0;">Exporting All Children</h3>
                <div id="exportProgressText">Exporting 0 of ${totalChildren}...</div>
                <div style="width: 100%; height: 8px; background: #f0f0f0; border-radius: 4px; margin: 1rem 0;">
                    <div id="exportProgressBar" style="width: 0%; height: 100%; background: #007bff; border-radius: 4px; transition: width 0.3s;"></div>
                </div>
                <button id="cancelExportBtn" style="padding: 0.5rem 1rem; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; margin-top: 1rem;">
                    Cancel
                </button>
            `;
            
            modal.appendChild(content);
            document.body.appendChild(modal);
            
            // Start export process
            startBatchExport(children, format, modal);
        }

        // Start batch export process
        async function startBatchExport(children, format, modal) {
            const progressText = document.getElementById('exportProgressText');
            const progressBar = document.getElementById('exportProgressBar');
            const cancelBtn = document.getElementById('cancelExportBtn');
            
            let cancelled = false;
            let completed = 0;
            const zip = new JSZip();
            const timestamp = new Date().toISOString().slice(0, 16).replace(/[-:]/g, '').replace('T', '_');
            
            // Cancel handler
            cancelBtn.onclick = () => {
                cancelled = true;
                closeExportModal(modal);
            };
            
            // Store original child
            const originalChild = state.current.child;
            
            try {
                console.log('Starting batch export for children:', children);
                
                for (let i = 0; i < children.length; i++) {
                    if (cancelled) break;
                    
                    const childId = children[i];
                    console.log(`Processing child ${i + 1}/${children.length}: ${childId}`);
                    
                    // Update progress
                    progressText.textContent = `Exporting ${i + 1} of ${children.length}...`;
                    progressBar.style.width = `${((i + 1) / children.length) * 100}%`;
                    
                    try {
                        // Load child data
                        console.log('Loading child data...');
                        await loadChildData(childId);
                        
                        // Wait for visualization to render
                        console.log('Waiting for visualization to render...');
                        await new Promise(resolve => setTimeout(resolve, 1500));
                        
                        // Export current child to zip
                        console.log('Exporting child...');
                        await exportCurrentChildToZip(childId, format, zip, timestamp);
                        
                        completed++;
                        console.log(`Successfully exported child ${childId} (${completed}/${children.length})`);
                        
                    } catch (childError) {
                        console.error(`Error processing child ${childId}:`, childError);
                        // Continue with next child instead of stopping
                        const errorMessage = childError?.message || childError?.toString() || 'Unknown error';
                        alert(`Error exporting ${childId}: ${errorMessage}. Continuing with next child...`);
                    }
                }
                
                if (!cancelled) {
                    // Create and download zip file
                    progressText.textContent = 'Creating zip file...';
                    progressBar.style.width = '100%';
                    progressBar.style.background = '#28a745';
                    
                    try {
                        const zipBlob = await zip.generateAsync({type: 'blob'});
                        const zipUrl = URL.createObjectURL(zipBlob);
                        const link = document.createElement('a');
                        link.href = zipUrl;
                        link.download = `network_exports_${timestamp}.zip`;
                        link.click();
                        URL.revokeObjectURL(zipUrl);
                        
                        progressText.textContent = `Done. ${completed} files exported to zip.`;
                    } catch (zipError) {
                        console.error('Error creating zip:', zipError);
                        progressText.textContent = `Done. ${completed} files exported (zip creation failed).`;
                    }
                    
                    // Restore original child after a delay
                    setTimeout(() => {
                        if (originalChild) {
                            console.log('Restoring original child:', originalChild);
                            loadChildData(originalChild);
                        }
                        closeExportModal(modal);
                    }, 2000);
                }
                
            } catch (error) {
                console.error('Export error:', error);
                alert(`Export failed: ${error.message}`);
                closeExportModal(modal);
            }
        }

        // Export current child to zip
        async function exportCurrentChildToZip(childId, format, zip, timestamp) {
            console.log(`Exporting child ${childId} as ${format} to zip`);
            
            // Generate filename with ChildID prefix
            const filename = `${childId}_${timestamp}.${format === 'jpg' ? 'jpg' : format}`;
            
            console.log(`Generated filename for child ${childId}: ${filename}`);
            
            // Export based on format
            if (format === 'csv') {
                console.log('Exporting as CSV to zip...');
                await exportChildAsCSVToZip(childId, filename, zip);
            } else {
                console.log('Exporting as image to zip...');
                await exportChildAsImageToZip(format, filename, zip);
            }
            
            console.log(`Export completed for ${childId} as ${filename} in zip`);
        }

        // Export current child
        async function exportCurrentChild(childId, format) {
            console.log(`Exporting child ${childId} as ${format}`);
            
            // Generate filename with ChildID prefix
            const timestamp = new Date().toISOString().slice(0, 16).replace(/[-:]/g, '').replace('T', '_');
            const filename = `${childId}_${timestamp}.${format === 'jpg' ? 'jpg' : format}`;
            
            console.log(`Generated filename for child ${childId}: ${filename}`);
            
            // Export based on format
            if (format === 'csv') {
                console.log('Exporting as CSV...');
                await exportChildAsCSV(childId, filename);
            } else {
                console.log('Exporting as image...');
                await exportChildAsImage(format, filename);
            }
            
            console.log(`Export completed for ${childId} as ${filename}`);
        }

        // Export child as CSV to zip
        async function exportChildAsCSVToZip(childId, filename, zip) {
            const nodes = state.current.nodeData || [];
            const edges = state.current.nodeEdges || [];
            
            // Create nodes CSV
            const nodesCSV = 'NodeID,NodeName,NodeType,Relationship,Context,Language,Race,ClosenessScore,WeeklyHours\n' +
                nodes.map(node => [
                    node.node_mapping_code || '',
                    node.node_name || '',
                    node.node_type || '',
                    node.relationship || '',
                    node.context || '',
                    node.language || '',
                    node.race || '',
                    node.closeness_score || '',
                    node.weekly_hours || ''
                ].join(',')).join('\n');
            
            // Create edges CSV
            const edgesCSV = 'Source,Target,Weight,Type\n' +
                edges.map(edge => [
                    edge.source,
                    edge.target,
                    edge.weight || 1,
                    edge.type || 'undirected'
                ].join(',')).join('\n');
            
            // Add to zip
            zip.file(filename.replace('.csv', '_nodes.csv'), nodesCSV);
            zip.file(filename.replace('.csv', '_edges.csv'), edgesCSV);
        }

        // Export child as CSV
        async function exportChildAsCSV(childId, filename) {
            const nodes = state.current.nodeData || [];
            const edges = state.current.nodeEdges || [];
            
            // Create nodes CSV
            const nodesCSV = 'NodeID,NodeName,NodeType,Relationship,Context,Language,Race,ClosenessScore,WeeklyHours\n' +
                nodes.map(node => [
                    node.node_mapping_code || '',
                    node.node_name || '',
                    node.node_type || '',
                    node.node_relationship || '',
                    getNodeContext(node.node_type) || '',
                    node.node_language || '',
                    node.node_race || '',
                    node.node_closeness_score || '',
                    node.node_weekly_hour || ''
                ].join(',')).join('\n');
            
            const blob = new Blob([nodesCSV], {type: 'text/csv'});
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename.replace('.csv', '_nodes.csv');
            a.click();
            window.URL.revokeObjectURL(url);
            
            // Create edges CSV
            const edgesCSV = 'Source,Target,Weight,Type\n' +
                edges.map(edge => [
                    edge.source,
                    edge.target,
                    edge.weight || 1,
                    edge.type || 'undirected'
                ].join(',')).join('\n');
            
            const edgesBlob = new Blob([edgesCSV], {type: 'text/csv'});
            const edgesUrl = window.URL.createObjectURL(edgesBlob);
            const edgesA = document.createElement('a');
            edgesA.href = edgesUrl;
            edgesA.download = filename.replace('.csv', '_edges.csv');
            edgesA.click();
            window.URL.revokeObjectURL(edgesUrl);
        }

        // Export child as image to zip (PNG only)
        async function exportChildAsImageToZip(format, filename, zip) {
            return new Promise((resolve, reject) => {
                try {
                    console.log(`Exporting PNG image to zip with filename: ${filename}`);
                    
                    // Only support PNG format
                    if (format !== 'png') {
                        reject(new Error('Only PNG format is supported for image exports'));
                        return;
                    }
                    
                    // Hide the sidebar temporarily
                    const sidebar = document.querySelector('.sidebar');
                    const originalSidebarDisplay = sidebar ? sidebar.style.display : 'none';
                    if (sidebar) {
                        sidebar.style.display = 'none';
                    }
                    
                    // Hide the bottom details panel temporarily
                    const bottomDetails = document.getElementById('bottomDetails');
                    const originalBottomDetailsDisplay = bottomDetails ? bottomDetails.style.display : 'none';
                    if (bottomDetails) {
                        bottomDetails.style.display = 'none';
                    }
                    
                    // Wait a moment for the layout to adjust
                    setTimeout(() => {
                        // Create a container that includes both the network and legend
                        const networkContainer = document.createElement('div');
                        networkContainer.style.position = 'relative';
                        networkContainer.style.width = '100%';
                        networkContainer.style.minHeight = '100vh';
                        networkContainer.style.backgroundColor = 'white';
                        networkContainer.style.overflow = 'visible';
                        
                        // Get the network SVG
                        const svg = document.getElementById('networkSvg');
                        const legend = document.getElementById('legend');
                        
                        if (!svg) {
                            reject(new Error('No network visualization found. Please visualize a network first.'));
                            restoreElements();
                            return;
                        }
                        
                        // Clone the SVG and legend
                        const svgClone = svg.cloneNode(true);
                        const legendClone = legend ? legend.cloneNode(true) : null;
                        
                        // Position the legend on the cloned SVG
                        if (legendClone) {
                            legendClone.style.position = 'absolute';
                            legendClone.style.top = '20px';
                            legendClone.style.right = '20px';
                            legendClone.style.zIndex = '1000';
                            legendClone.style.backgroundColor = 'white';
                            legendClone.style.padding = '10px';
                            legendClone.style.borderRadius = '8px';
                            legendClone.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
                            legendClone.style.display = 'block';
                        }
                        
                        // Add clones to container
                        networkContainer.appendChild(svgClone);
                        if (legendClone) {
                            networkContainer.appendChild(legendClone);
                        }
                        
                        // Temporarily add to body for capture
                        document.body.appendChild(networkContainer);
                        
                        // Use html2canvas to capture the container
                            html2canvas(networkContainer, {
                            backgroundColor: 'white',
                            scale: 2,
                            useCORS: true,
                            allowTaint: true,
                            logging: false,
                            width: networkContainer.scrollWidth,
                            height: networkContainer.scrollHeight,
                            scrollX: 0,
                            scrollY: 0,
                            windowWidth: networkContainer.scrollWidth,
                            windowHeight: networkContainer.scrollHeight
                        }).then(canvas => {
                            // Convert canvas to blob and add to zip
                            canvas.toBlob((blob) => {
                                if (blob) {
                                    zip.file(filename, blob);
                                    // Clean up
                                    document.body.removeChild(networkContainer);
                                    restoreElements();
                                    resolve();
                                } else {
                                    reject(new Error('Failed to convert canvas to blob'));
                                }
                            }, 'image/png');
                        }).catch(error => {
                            console.error('Canvas error:', error);
                            if (document.body.contains(networkContainer)) {
                                document.body.removeChild(networkContainer);
                            }
                            restoreElements();
                            reject(error);
                        });
                        
                        function restoreElements() {
                            // Restore sidebar
                            if (sidebar) {
                                sidebar.style.display = originalSidebarDisplay;
                            }
                            // Restore bottom details
                            if (bottomDetails) {
                                bottomDetails.style.display = originalBottomDetailsDisplay;
                            }
                        }
                    }, 100);
                } catch (error) {
                    console.error('Export error:', error);
                    reject(error);
                }
            });
        }

        // Export child as image (PNG only)
        async function exportChildAsImage(format, filename) {
            return new Promise((resolve, reject) => {
                try {
                    console.log(`Exporting PNG image with filename: ${filename}`);
                    
                    // Only support PNG format
                    if (format !== 'png') {
                        reject(new Error('Only PNG format is supported for image exports'));
                        return;
                    }
                    
                    // Hide the sidebar temporarily
                    const sidebar = document.querySelector('.sidebar');
                    const originalSidebarDisplay = sidebar ? sidebar.style.display : 'none';
                    if (sidebar) {
                        sidebar.style.display = 'none';
                    }
                    
                    // Hide the bottom details panel temporarily
                    const bottomDetails = document.getElementById('bottomDetails');
                    const originalBottomDetailsDisplay = bottomDetails ? bottomDetails.style.display : 'none';
                    if (bottomDetails) {
                        bottomDetails.style.display = 'none';
                    }
                    
                    // Wait a moment for the layout to adjust
                    setTimeout(() => {
                        // Create a container that includes both the network and legend
                        const networkContainer = document.createElement('div');
                        networkContainer.style.position = 'relative';
                        networkContainer.style.width = '100%';
                        networkContainer.style.minHeight = '100vh';
                        networkContainer.style.backgroundColor = 'white';
                        networkContainer.style.overflow = 'visible';
                        
                        // Get the network SVG
                        const svg = document.getElementById('networkSvg');
                        const legend = document.getElementById('legend');
                        
                        if (!svg) {
                            reject(new Error('No network visualization found. Please visualize a network first.'));
                            restoreElements();
                            return;
                        }
                        
                        // Clone the SVG and legend
                        const svgClone = svg.cloneNode(true);
                        const legendClone = legend ? legend.cloneNode(true) : null;
                        
                        // Position the legend on the cloned SVG
                        if (legendClone) {
                            legendClone.style.position = 'absolute';
                            legendClone.style.top = '20px';
                            legendClone.style.right = '20px';
                            legendClone.style.zIndex = '1000';
                            legendClone.style.backgroundColor = 'white';
                            legendClone.style.padding = '10px';
                            legendClone.style.borderRadius = '8px';
                            legendClone.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';
                            legendClone.style.display = 'block';
                        }
                        
                        // Add clones to container
                        networkContainer.appendChild(svgClone);
                        if (legendClone) {
                            networkContainer.appendChild(legendClone);
                        }
                        
                        // Temporarily add to body for capture
                        document.body.appendChild(networkContainer);
                        
                        // Use html2canvas to capture the container
                            html2canvas(networkContainer, {
                            backgroundColor: 'white',
                            scale: 2,
                            useCORS: true,
                            allowTaint: true,
                            logging: false,
                            width: networkContainer.scrollWidth,
                            height: networkContainer.scrollHeight,
                            scrollX: 0,
                            scrollY: 0,
                            windowWidth: networkContainer.scrollWidth,
                            windowHeight: networkContainer.scrollHeight
                        }).then(canvas => {
                            // Create download link
                            const link = document.createElement('a');
                            link.href = canvas.toDataURL('image/png', 1.0);
                            link.download = filename;
                            link.click();
                            
                            // Clean up
                            document.body.removeChild(networkContainer);
                            restoreElements();
                                    resolve();
                        }).catch(error => {
                            console.error('Canvas error:', error);
                            if (document.body.contains(networkContainer)) {
                                document.body.removeChild(networkContainer);
                            }
                            restoreElements();
                            reject(error);
                        });
                        
                        function restoreElements() {
                            // Restore sidebar
                            if (sidebar) {
                                sidebar.style.display = originalSidebarDisplay;
                            }
                            // Restore bottom details
                            if (bottomDetails) {
                                bottomDetails.style.display = originalBottomDetailsDisplay;
                            }
                        }
                    }, 100);
                } catch (error) {
                    console.error('Export error:', error);
                    reject(error);
                }
            });
        }

        // Close export modal
        function closeExportModal(modal) {
            if (modal && modal.parentNode) {
                modal.parentNode.removeChild(modal);
            }
        }

        // Load child data for batch export (without resetting settings)
        async function loadChildData(childId) {
            console.log('Loading child data for export:', childId);
            
            // Set current data directly without going through the full visualizeNetwork process
            state.current.child = childId;
            state.current.childData = state.data.egoLevelNetworkSummary ? state.data.egoLevelNetworkSummary.find(d => d.ChildID === childId) : null;
            state.current.nodeData = state.data.nodeLevelLong ? state.data.nodeLevelLong.filter(d => d.ChildID === childId) : [];
            state.current.nodeEdges = parseAlterEdges(state.current.nodeData);
            
            console.log('Child data loaded:', {
                childId,
                childData: !!state.current.childData,
                alterCount: state.current.nodeData.length,
                edgeCount: state.current.nodeEdges.length
            });
            
            // Update the child select dropdown to reflect current selection
            const childSelect = document.getElementById('childSelect');
            if (childSelect) {
                childSelect.value = childId;
            }
            
            // Create visualization without resetting settings
            if (state.current.nodeData.length > 0) {
                console.log('Creating visualization for export...');
                try {
                    // Clear existing visualization
                    clearVisualization();
                    
                    // Create new visualization with current settings
                    createGroupedVisualization();
                    
                    // Ensure legend is visible
                    const legend = document.getElementById('legend');
                    if (legend) {
                        legend.style.display = 'block';
                    }
                    
                    console.log('Visualization created successfully');
                } catch (error) {
                    console.error('Error creating visualization for export:', error);
                    // Don't throw error, just log it and continue
                    console.log('Continuing with export despite visualization error...');
                }
            } else {
                console.log('No alter data found for child:', childId);
                throw new Error(`No data found for child: ${childId}`);
            }
        }


        function exportWholeDataPlot() {
            const format = document.getElementById('wholeDataExportFormat').value;
            
            if (format === 'csv') {
                // Export data as CSV
                const mode = document.getElementById('wholeDataExplorationMode').value;
                if (mode === 'distribution') {
                    const variable = document.getElementById('wholeDataDistributionVariable').value;
                    const data = getWholeDataVariableData(variable);
                
                if (data) {
                    const csvContent = `Variable,Value\n${data.map(d => `${variable},${d}`).join('\n')}`;
                    const blob = new Blob([csvContent], {type: 'text/csv'});
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${variable}_data.csv`;
                    a.click();
                    window.URL.revokeObjectURL(url);
                    }
                } else {
                    const xVar = document.getElementById('wholeDataXVariable').value;
                    const yVar = document.getElementById('wholeDataYVariable').value;
                    const xData = getWholeDataVariableData(xVar);
                    const yData = getWholeDataVariableData(yVar);
                    
                    if (xData && yData) {
                        const csvContent = `X_Variable,Y_Variable\n${xData.map((d, i) => `${d},${yData[i] || ''}`).join('\n')}`;
                        const blob = new Blob([csvContent], {type: 'text/csv'});
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${xVar}_vs_${yVar}_data.csv`;
                        a.click();
                        window.URL.revokeObjectURL(url);
                    }
                }
            } else {
                // Export plot as image
                const mode = document.getElementById('wholeDataExplorationMode').value;
                let chartDiv;
                
                if (mode === 'distribution') {
                    chartDiv = document.getElementById('wholeDataDistributionChart');
                } else {
                    chartDiv = document.getElementById('wholeDataInteractionChart');
                }
                
                if (chartDiv && chartDiv.querySelector('svg')) {
                    html2canvas(chartDiv, {
                        backgroundColor: 'white',
                        scale: 2
                    }).then(canvas => {
                        const link = document.createElement('a');
                        link.download = `whole_data_plot.${format}`;
                        link.href = canvas.toDataURL(`image/${format}`);
                        link.click();
                    });
                }
            }
        }
        
        // Populate whole data interaction variable dropdowns
        function populateWholeDataDistributionVariables() {
            const distributionSelect = document.getElementById('wholeDataDistributionVariable');
            if (!distributionSelect || !state.data.egoLevelNetworkSummary || state.data.egoLevelNetworkSummary.length === 0) {
                console.log('Cannot populate distribution variables - missing data or element');
                return;
            }
            
            // Get column names from ego_level_network_summary data
            const columns = Object.keys(state.data.egoLevelNetworkSummary[0]);
            console.log('Available columns for distribution:', columns);
            
            // Clear existing options
            distributionSelect.innerHTML = '<option value="">Select a variable...</option>';
            
            // Group variables by category
            const variableCategories = {
                'Demographics': ['age_in_months', 'child_gender', 'child_race', 'child_lang', 'child_lang_categorized'],
                'Childcare': ['childcare_yn', 'childcare_type', 'childcare_start_age', 'childcare_size'],
                'Network Structure': ['network_size', 'component_count', 'component_ratio', 'alters_listed', 'alters_with_demo', 'network_density', 'edges_number'],
                'Diversity Indices': ['race_entropy', 'racial_ei_index', 'language_entropy', 'linguistic_ei_index'],
                'Proportions': ['prop_adult_relationship', 'prop_kin_relationship', 'demographics_completion_rate']
            };
            
            // Add variables by category
            Object.keys(variableCategories).forEach(category => {
                const categoryVars = variableCategories[category].filter(col => columns.includes(col));
                if (categoryVars.length > 0) {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = category;
                    categoryVars.forEach(col => {
                        const option = document.createElement('option');
                        option.value = col;
                        option.textContent = col.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                        optgroup.appendChild(option);
                    });
                    distributionSelect.appendChild(optgroup);
                }
            });
            
            console.log('Distribution variables populated');
        }
        
        function populateWholeDataInteractionVariables() {
            const xSelect = document.getElementById('wholeDataXVariable');
            const ySelect = document.getElementById('wholeDataYVariable');
            const distributionSelect = document.getElementById('wholeDataDistributionVariable');
            
            // Copy options from distribution variable
            if (distributionSelect && distributionSelect.innerHTML) {
                xSelect.innerHTML = distributionSelect.innerHTML;
                ySelect.innerHTML = distributionSelect.innerHTML;
            } else {
                // Fallback: populate directly
                populateWholeDataDistributionVariables();
                xSelect.innerHTML = distributionSelect.innerHTML;
                ySelect.innerHTML = distributionSelect.innerHTML;
            }
        }
        
        // Add missing box plot and heatmap functions
        function createWholeDataBoxPlot(container, xVar, yVar, xData, yData) {
            // Create box plot for categorical x continuous y
            const margin = {top: 30, right: 30, bottom: 50, left: 70};
            const width = container.offsetWidth - margin.left - margin.right;
            const height = 350 - margin.top - margin.bottom;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Group data by x variable
            const groups = {};
            xData.forEach((x, i) => {
                if (!groups[x]) groups[x] = [];
                groups[x].push(yData[i]);
            });
            
            const categories = Object.keys(groups);
            const x = d3.scaleBand()
                .domain(categories)
                .range([0, width])
                .padding(0.1);
            
            const y = d3.scaleLinear()
                .domain([d3.min(yData), d3.max(yData)])
                .range([height, 0]);
            
            // Add grid lines
            svg.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(y).tickSize(-width).tickFormat(''));
            
            // Create box plots for each group
            categories.forEach(category => {
                const data = groups[category];
                const q1 = d3.quantile(data, 0.25);
                const median = d3.median(data);
                const q3 = d3.quantile(data, 0.75);
                const iqr = q3 - q1;
                const lowerWhisker = Math.max(q1 - 1.5 * iqr, d3.min(data));
                const upperWhisker = Math.min(q3 + 1.5 * iqr, d3.max(data));
                
                const xPos = x(category) + x.bandwidth() / 2;
                
                // Draw whiskers
                svg.append('line')
                    .attr('x1', xPos)
                    .attr('x2', xPos)
                    .attr('y1', y(lowerWhisker))
                    .attr('y2', y(upperWhisker))
                    .style('stroke', '#374151')
                    .style('stroke-width', '2px');
                
                // Draw box
                svg.append('rect')
                    .attr('x', x(category) + x.bandwidth() * 0.2)
                    .attr('y', y(q3))
                    .attr('width', x.bandwidth() * 0.6)
                    .attr('height', y(q1) - y(q3))
                    .style('fill', '#3b82f6')
                    .style('stroke', '#1e40af')
                    .style('stroke-width', '1px');
                
                // Draw median line
                svg.append('line')
                    .attr('x1', x(category) + x.bandwidth() * 0.2)
                    .attr('x2', x(category) + x.bandwidth() * 0.8)
                    .attr('y1', y(median))
                    .attr('y2', y(median))
                    .style('stroke', '#ef4444')
                    .style('stroke-width', '2px');
            });
            
            // Add axes
            const xAxis = d3.axisBottom(x);
            const yAxis = d3.axisLeft(y);
            
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(xAxis)
                .style('font-size', '12px');
            
            svg.append('g')
                .call(yAxis)
                .style('font-size', '12px');
            
            // Add labels
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height + margin.bottom - 10)
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', '600')
                .style('fill', '#374151')
                .text(xVar.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));
            
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left + 20)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', '600')
                .style('fill', '#374151')
                .text(yVar.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));
            
            // Style grid lines
            svg.selectAll('.grid line')
                .style('stroke', '#e5e7eb')
                .style('stroke-width', '1px')
                .style('opacity', 0.5);
        }
        
        function createWholeDataHeatmap(container, xVar, yVar, xData, yData) {
            // Create heatmap for categorical x categorical y
            const margin = {top: 30, right: 30, bottom: 50, left: 70};
            const width = container.offsetWidth - margin.left - margin.right;
            const height = 350 - margin.top - margin.bottom;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Count co-occurrences
            const counts = {};
            xData.forEach((x, i) => {
                const y = yData[i];
                if (!counts[x]) counts[x] = {};
                if (!counts[x][y]) counts[x][y] = 0;
                counts[x][y]++;
            });
            
            const xCategories = [...new Set(xData)];
            const yCategories = [...new Set(yData)];
            
            const x = d3.scaleBand()
                .domain(xCategories)
                .range([0, width])
                .padding(0.1);
            
            const y = d3.scaleBand()
                .domain(yCategories)
                .range([0, height])
                .padding(0.1);
            
            const colorScale = d3.scaleSequential()
                .domain([0, d3.max(Object.values(counts).flatMap(obj => Object.values(obj)))])
                .interpolator(d3.interpolateBlues);
            
            // Add cells
            xCategories.forEach(xCat => {
                yCategories.forEach(yCat => {
                    const count = counts[xCat]?.[yCat] || 0;
                    svg.append('rect')
                        .attr('x', x(xCat))
                        .attr('y', y(yCat))
                        .attr('width', x.bandwidth())
                        .attr('height', y.bandwidth())
                        .style('fill', colorScale(count))
                        .style('stroke', '#e5e7eb')
                        .style('stroke-width', '1px');
                    
                    // Add count labels
                    if (count > 0) {
                        svg.append('text')
                            .attr('x', x(xCat) + x.bandwidth() / 2)
                            .attr('y', y(yCat) + y.bandwidth() / 2)
                            .attr('text-anchor', 'middle')
                            .attr('dy', '0.35em')
                            .style('font-size', '12px')
                            .style('font-weight', '600')
                            .style('fill', count > 3 ? 'white' : '#374151')
                            .text(count);
                    }
                });
            });
            
            // Add axes
            const xAxis = d3.axisBottom(x);
            const yAxis = d3.axisLeft(y);
            
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(xAxis)
                .style('font-size', '12px');
            
            svg.append('g')
                .call(yAxis)
                .style('font-size', '12px');
            
            // Add labels
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height + margin.bottom - 10)
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', '600')
                .style('fill', '#374151')
                .text(xVar.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));
            
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left + 20)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-weight', '600')
                .style('fill', '#374151')
                .text(yVar.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()));
        }
        
        // Screenshot function for whole data page
        function takeWholeDataScreenshot() {
            const format = document.getElementById('wholeDataScreenshotFormat').value;
            const container = document.querySelector('.whole-data-page .dashboard-container');
            
            if (container) {
                html2canvas(container, {
                    backgroundColor: 'white',
                    scale: 2
                }).then(canvas => {
                    const link = document.createElement('a');
                    link.download = `whole_data_dashboard.${format}`;
                    link.href = canvas.toDataURL(`image/${format}`);
                    link.click();
                });
            }
        }
        
        // Header control functions for whole data page
        function toggleWholeDataHeader() {
            console.log('toggleWholeDataHeader called');
            const breadcrumb = document.getElementById('wholeDataBreadcrumb');
            const toggleIcon = document.getElementById('wholeDataToggleIcon');
            
            console.log('Breadcrumb element:', breadcrumb);
            console.log('Toggle icon element:', toggleIcon);
            
            if (!breadcrumb || !toggleIcon) {
                console.error('Header elements not found');
                return;
            }
            
            if (breadcrumb.classList.contains('collapsed')) {
                console.log('Expanding header');
                breadcrumb.classList.remove('collapsed');
                toggleIcon.textContent = '▼';
            } else {
                console.log('Collapsing header');
                breadcrumb.classList.add('collapsed');
                toggleIcon.textContent = '▲';
            }
        }
        
        function startWholeDataHeaderDrag(event) {
            event.preventDefault();
            event.stopPropagation();
            
            const breadcrumb = document.getElementById('wholeDataBreadcrumb');
            if (!breadcrumb) return;
            
            // Store initial position
            const initialLeft = parseInt(breadcrumb.style.left) || 400;
            const initialTop = parseInt(breadcrumb.style.top) || 80;
            
            // Store mouse start position
            const mouseStartX = event.clientX;
            const mouseStartY = event.clientY;
            
            breadcrumb.classList.add('dragging');
            
            function onMouseMove(e) {
                const deltaX = e.clientX - mouseStartX;
                const deltaY = e.clientY - mouseStartY;
                
                const newLeft = initialLeft + deltaX;
                const newTop = initialTop + deltaY;
                
                // Keep within viewport bounds
                const maxLeft = window.innerWidth - breadcrumb.offsetWidth;
                const maxTop = window.innerHeight - breadcrumb.offsetHeight;
                
                breadcrumb.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
                breadcrumb.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';
            }
            
            function onMouseUp() {
                breadcrumb.classList.remove('dragging');
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }
        
                // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize existing functionality
            if (typeof populateInteractionVariables === 'function') {
                populateInteractionVariables();
            }
            
            // Initialize edge visibility setting
            if (!state.ui.edgeVisibility) {
                state.ui.edgeVisibility = 'all';
                console.log('Initialized edge visibility to:', state.ui.edgeVisibility);
            }
            
            // Test header controls functionality
            setTimeout(() => {
                console.log('Testing header controls...');
                const wholeDataBreadcrumb = document.getElementById('wholeDataBreadcrumb');
                const childBreadcrumb = document.getElementById('breadcrumb');
                
                if (wholeDataBreadcrumb) {
                    console.log('Whole data breadcrumb found:', wholeDataBreadcrumb);
                }
                if (childBreadcrumb) {
                    console.log('Child breadcrumb found:', childBreadcrumb);
                }
            }, 1000);
        });
    </script>
  
  
  
  </body></html>